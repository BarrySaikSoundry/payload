{"version":3,"sources":["../../../src/adapters/s3/staticHandler.ts"],"sourcesContent":["import type * as AWS from '@aws-sdk/client-s3'\nimport type { CollectionConfig } from 'payload'\n\nimport path from 'path'\n\nimport type { StaticHandler } from '../../types.js'\n\nimport { getFilePrefix } from '../../utilities/getFilePrefix.js'\n\ninterface Args {\n  bucket: string\n  collection: CollectionConfig\n  getStorageClient: () => AWS.S3\n}\n\n// Convert a stream into a promise that resolves with a Buffer\nconst streamToBuffer = async (readableStream) => {\n  const chunks = []\n  for await (const chunk of readableStream) {\n    chunks.push(typeof chunk === 'string' ? Buffer.from(chunk) : chunk)\n  }\n  return Buffer.concat(chunks)\n}\n\nexport const getHandler = ({ bucket, collection, getStorageClient }: Args): StaticHandler => {\n  return async (req, { params: { filename } }) => {\n    try {\n      const prefix = await getFilePrefix({ collection, filename, req })\n\n      const object = await getStorageClient().getObject({\n        Bucket: bucket,\n        Key: path.posix.join(prefix, filename),\n      })\n\n      if (!object.Body) {\n        return new Response(null, { status: 404, statusText: 'Not Found' })\n      }\n\n      const bodyBuffer = await streamToBuffer(object.Body)\n\n      return new Response(bodyBuffer, {\n        headers: new Headers({\n          'Accept-Ranges': object.AcceptRanges,\n          'Content-Length': String(object.ContentLength),\n          'Content-Type': object.ContentType,\n          ETag: object.ETag,\n        }),\n        status: 200,\n      })\n    } catch (err) {\n      req.payload.logger.error(err)\n      return new Response('Internal Server Error', { status: 500 })\n    }\n  }\n}\n"],"names":["path","getFilePrefix","streamToBuffer","readableStream","chunks","chunk","push","Buffer","from","concat","getHandler","bucket","collection","getStorageClient","req","params","filename","prefix","object","getObject","Bucket","Key","posix","join","Body","Response","status","statusText","bodyBuffer","headers","Headers","AcceptRanges","String","ContentLength","ContentType","ETag","err","payload","logger","error"],"mappings":"AAGA,OAAOA,UAAU,OAAM;AAIvB,SAASC,aAAa,QAAQ,mCAAkC;AAQhE,8DAA8D;AAC9D,MAAMC,iBAAiB,OAAOC;IAC5B,MAAMC,SAAS,EAAE;IACjB,WAAW,MAAMC,SAASF,eAAgB;QACxCC,OAAOE,IAAI,CAAC,OAAOD,UAAU,WAAWE,OAAOC,IAAI,CAACH,SAASA;IAC/D;IACA,OAAOE,OAAOE,MAAM,CAACL;AACvB;AAEA,OAAO,MAAMM,aAAa,CAAC,EAAEC,MAAM,EAAEC,UAAU,EAAEC,gBAAgB,EAAQ;IACvE,OAAO,OAAOC,KAAK,EAAEC,QAAQ,EAAEC,QAAQ,EAAE,EAAE;QACzC,IAAI;YACF,MAAMC,SAAS,MAAMhB,cAAc;gBAAEW;gBAAYI;gBAAUF;YAAI;YAE/D,MAAMI,SAAS,MAAML,mBAAmBM,SAAS,CAAC;gBAChDC,QAAQT;gBACRU,KAAKrB,KAAKsB,KAAK,CAACC,IAAI,CAACN,QAAQD;YAC/B;YAEA,IAAI,CAACE,OAAOM,IAAI,EAAE;gBAChB,OAAO,IAAIC,SAAS,MAAM;oBAAEC,QAAQ;oBAAKC,YAAY;gBAAY;YACnE;YAEA,MAAMC,aAAa,MAAM1B,eAAegB,OAAOM,IAAI;YAEnD,OAAO,IAAIC,SAASG,YAAY;gBAC9BC,SAAS,IAAIC,QAAQ;oBACnB,iBAAiBZ,OAAOa,YAAY;oBACpC,kBAAkBC,OAAOd,OAAOe,aAAa;oBAC7C,gBAAgBf,OAAOgB,WAAW;oBAClCC,MAAMjB,OAAOiB,IAAI;gBACnB;gBACAT,QAAQ;YACV;QACF,EAAE,OAAOU,KAAK;YACZtB,IAAIuB,OAAO,CAACC,MAAM,CAACC,KAAK,CAACH;YACzB,OAAO,IAAIX,SAAS,yBAAyB;gBAAEC,QAAQ;YAAI;QAC7D;IACF;AACF,EAAC"}
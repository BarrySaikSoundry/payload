{"version":3,"sources":["../../src/fetchAPI-multipart/processMultipart.ts"],"sourcesContent":["import type { Readable } from 'stream'\n\nimport Busboy from 'busboy'\nimport httpStatus from 'http-status'\nimport { APIError } from 'payload'\n\nimport type { FetchAPIFileUploadOptions, FetchAPIFileUploadResponse } from './index.js'\n\nimport { fileFactory } from './fileFactory.js'\nimport { memHandler, tempFileHandler } from './handlers.js'\nimport { processNested } from './processNested.js'\nimport { createUploadTimer } from './uploadTimer.js'\nimport { buildFields, debugLog, isFunc, parseFileName } from './utilities.js'\n\nconst waitFlushProperty = Symbol('wait flush property symbol')\n\ntype ProcessMultipart = (args: {\n  options: FetchAPIFileUploadOptions\n  request: Request\n}) => Promise<FetchAPIFileUploadResponse>\nexport const processMultipart: ProcessMultipart = async ({ options, request }) => {\n  let parsingRequest = true\n\n  let fileCount = 0\n  let filesCompleted = 0\n  let allFilesHaveResolved: (value?: unknown) => void\n  let failedResolvingFiles: (err: Error) => void\n\n  const allFilesComplete = new Promise((res, rej) => {\n    allFilesHaveResolved = res\n    failedResolvingFiles = rej\n  })\n\n  const result: FetchAPIFileUploadResponse = {\n    fields: undefined,\n    files: undefined,\n  }\n\n  const headersObject = {}\n  request.headers.forEach((value, name) => {\n    headersObject[name] = value\n  })\n\n  function abortAndDestroyFile(file: Readable, err: APIError) {\n    file.destroy()\n    parsingRequest = false\n    failedResolvingFiles(err)\n  }\n\n  const busboy = Busboy({ ...options, headers: headersObject })\n\n  // Build multipart req.body fields\n  busboy.on('field', (field, val) => {\n    result.fields = buildFields(result.fields, field, val)\n  })\n\n  // Build req.files fields\n  busboy.on('file', (field, file, info) => {\n    fileCount += 1\n    // Parse file name(cutting huge names, decoding, etc..).\n    const { encoding, filename: name, mimeType: mime } = info\n    const filename = parseFileName(options, name)\n\n    // Define methods and handlers for upload process.\n    const { cleanup, complete, dataHandler, getFilePath, getFileSize, getHash, getWritePromise } =\n      options.useTempFiles\n        ? tempFileHandler(options, field, filename) // Upload into temporary file.\n        : memHandler(options, field, filename) // Upload into RAM.\n\n    const writePromise = options.useTempFiles\n      ? getWritePromise().catch((err) => {\n          busboy.end()\n          cleanup()\n        })\n      : getWritePromise()\n\n    const uploadTimer = createUploadTimer(options.uploadTimeout, () => {\n      return abortAndDestroyFile(\n        file,\n        new APIError(`Upload timeout for ${field}->${filename}, bytes:${getFileSize()}`),\n      )\n    })\n\n    file.on('limit', () => {\n      debugLog(options, `Size limit reached for ${field}->${filename}, bytes:${getFileSize()}`)\n      uploadTimer.clear()\n\n      if (isFunc(options.limitHandler)) {\n        options.limitHandler({ request, size: getFileSize() })\n      }\n\n      // Return error and cleanup files if abortOnLimit set.\n      if (options.abortOnLimit) {\n        debugLog(options, `Upload file size limit reached ${field}->${filename}.`)\n        cleanup()\n        abortAndDestroyFile(\n          file,\n          new APIError(options.responseOnLimit, httpStatus.REQUEST_ENTITY_TOO_LARGE, {\n            size: getFileSize(),\n          }),\n        )\n      }\n    })\n\n    file.on('data', (data) => {\n      uploadTimer.set()\n      dataHandler(data)\n    })\n\n    file.on('end', () => {\n      const size = getFileSize()\n      debugLog(options, `Upload finished ${field}->${filename}, bytes:${size}`)\n      uploadTimer.clear()\n\n      if (!name && size === 0) {\n        fileCount -= 1\n        if (options.useTempFiles) {\n          cleanup()\n          debugLog(options, `Removing the empty file ${field}->${filename}`)\n        }\n        return debugLog(options, `Don't add file instance if original name and size are empty`)\n      }\n\n      filesCompleted += 1\n\n      result.files = buildFields(\n        result.files,\n        field,\n        fileFactory(\n          {\n            name: filename,\n            buffer: complete(),\n            encoding,\n            hash: getHash(),\n            mimetype: mime,\n            size,\n            tempFilePath: getFilePath(),\n            truncated: Boolean('truncated' in file && file.truncated),\n          },\n          options,\n        ),\n      )\n\n      if (!request[waitFlushProperty]) {\n        request[waitFlushProperty] = []\n      }\n      request[waitFlushProperty].push(writePromise)\n\n      if (filesCompleted === fileCount) {\n        allFilesHaveResolved()\n      }\n    })\n\n    file.on('error', (err) => {\n      uploadTimer.clear()\n      debugLog(options, `File Error: ${err.message}`)\n      cleanup()\n      failedResolvingFiles(err)\n    })\n\n    // Start upload process.\n    debugLog(options, `New upload started ${field}->${filename}, bytes:${getFileSize()}`)\n    uploadTimer.set()\n  })\n\n  busboy.on('finish', async () => {\n    debugLog(options, `Busboy finished parsing request.`)\n    if (options.parseNested) {\n      result.fields = processNested(result.fields)\n      result.files = processNested(result.files)\n    }\n\n    if (request[waitFlushProperty]) {\n      try {\n        await Promise.all(request[waitFlushProperty]).then(() => {\n          delete request[waitFlushProperty]\n        })\n      } catch (err) {\n        debugLog(options, `Error waiting for file write promises: ${err}`)\n      }\n    }\n\n    return result\n  })\n\n  busboy.on(\n    'error',\n    (err = new APIError('Busboy error parsing multipart request', httpStatus.BAD_REQUEST)) => {\n      debugLog(options, `Busboy error`)\n      parsingRequest = false\n      throw err\n    },\n  )\n\n  const reader = request.body.getReader()\n\n  // Start parsing request\n  while (parsingRequest) {\n    const { done, value } = await reader.read()\n\n    if (done) {\n      parsingRequest = false\n    }\n\n    if (value) {\n      busboy.write(value)\n    }\n  }\n\n  if (fileCount !== 0) {\n    await allFilesComplete.catch((e) => {\n      throw e\n    })\n  }\n\n  return result\n}\n"],"names":["Busboy","httpStatus","APIError","fileFactory","memHandler","tempFileHandler","processNested","createUploadTimer","buildFields","debugLog","isFunc","parseFileName","waitFlushProperty","Symbol","processMultipart","options","request","parsingRequest","fileCount","filesCompleted","allFilesHaveResolved","failedResolvingFiles","allFilesComplete","Promise","res","rej","result","fields","undefined","files","headersObject","headers","forEach","value","name","abortAndDestroyFile","file","err","destroy","busboy","on","field","val","info","encoding","filename","mimeType","mime","cleanup","complete","dataHandler","getFilePath","getFileSize","getHash","getWritePromise","useTempFiles","writePromise","catch","end","uploadTimer","uploadTimeout","clear","limitHandler","size","abortOnLimit","responseOnLimit","REQUEST_ENTITY_TOO_LARGE","data","set","buffer","hash","mimetype","tempFilePath","truncated","Boolean","push","message","parseNested","all","then","BAD_REQUEST","reader","body","getReader","done","read","write","e"],"mappings":"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"}
{"version":3,"sources":["../../../src/transform/read/traverseFields.ts"],"sourcesContent":["/* eslint-disable no-param-reassign */\nimport type { Field, TabAsField } from 'payload'\nimport type { SanitizedConfig } from 'payload'\n\nimport { fieldAffectsData } from 'payload/shared'\n\nimport type { PostgresAdapter } from '../../types.js'\nimport type { BlocksMap } from '../../utilities/createBlocksMap.js'\n\nimport { transformHasManyNumber } from './hasManyNumber.js'\nimport { transformHasManyText } from './hasManyText.js'\nimport { transformRelationship } from './relationship.js'\n\ntype TraverseFieldsArgs = {\n  /**\n   * The DB adapter\n   */\n  adapter: PostgresAdapter\n  /**\n   * Pre-formatted blocks map\n   */\n  blocks: BlocksMap\n  /**\n   * The full Payload config\n   */\n  config: SanitizedConfig\n  /**\n   * The data reference to be mutated within this recursive function\n   */\n  dataRef: Record<string, unknown>\n  /**\n   * Data that needs to be removed from the result after all fields have populated\n   */\n  deletions: (() => void)[]\n  /**\n   * Column prefix can be built up by group and named tab fields\n   */\n  fieldPrefix: string\n  /**\n   * An array of Payload fields to traverse\n   */\n  fields: (Field | TabAsField)[]\n  /**\n   * All hasMany number fields, as returned by Drizzle, keyed on an object by field path\n   */\n  numbers: Record<string, Record<string, unknown>[]>\n  /**\n   * The current field path (in dot notation), used to merge in relationships\n   */\n  path: string\n  /**\n   * All related documents, as returned by Drizzle, keyed on an object by field path\n   */\n  relationships: Record<string, Record<string, unknown>[]>\n  /**\n   * Data structure representing the nearest table from db\n   */\n  table: Record<string, unknown>\n  /**\n   * All hasMany text fields, as returned by Drizzle, keyed on an object by field path\n   */\n  texts: Record<string, Record<string, unknown>[]>\n}\n\n// Traverse fields recursively, transforming data\n// for each field type into required Payload shape\nexport const traverseFields = <T extends Record<string, unknown>>({\n  adapter,\n  blocks,\n  config,\n  dataRef,\n  deletions,\n  fieldPrefix,\n  fields,\n  numbers,\n  path,\n  relationships,\n  table,\n  texts,\n}: TraverseFieldsArgs): T => {\n  const sanitizedPath = path ? `${path}.` : path\n\n  const formatted = fields.reduce((result, field) => {\n    if (field.type === 'tabs') {\n      traverseFields({\n        adapter,\n        blocks,\n        config,\n        dataRef,\n        deletions,\n        fieldPrefix,\n        fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n        numbers,\n        path,\n        relationships,\n        table,\n        texts,\n      })\n    }\n\n    if (\n      field.type === 'collapsible' ||\n      field.type === 'row' ||\n      (field.type === 'tab' && !('name' in field))\n    ) {\n      traverseFields({\n        adapter,\n        blocks,\n        config,\n        dataRef,\n        deletions,\n        fieldPrefix,\n        fields: field.fields,\n        numbers,\n        path,\n        relationships,\n        table,\n        texts,\n      })\n    }\n\n    if (fieldAffectsData(field)) {\n      const fieldName = `${fieldPrefix || ''}${field.name}`\n      const fieldData = table[fieldName]\n      const localizedFieldData = {}\n      const valuesToTransform: {\n        ref: Record<string, unknown>\n        table: Record<string, unknown>\n      }[] = []\n\n      if (fieldPrefix) {\n        deletions.push(() => delete table[fieldName])\n      }\n\n      if (field.type === 'array') {\n        if (Array.isArray(fieldData)) {\n          if (field.localized) {\n            result[field.name] = fieldData.reduce((arrayResult, row) => {\n              if (typeof row._locale === 'string') {\n                if (!arrayResult[row._locale]) arrayResult[row._locale] = []\n                const locale = row._locale\n                const data = {}\n                delete row._locale\n                if (row._uuid) {\n                  row.id = row._uuid\n                  delete row._uuid\n                }\n\n                const rowResult = traverseFields<T>({\n                  adapter,\n                  blocks,\n                  config,\n                  dataRef: data,\n                  deletions,\n                  fieldPrefix: '',\n                  fields: field.fields,\n                  numbers,\n                  path: `${sanitizedPath}${field.name}.${row._order - 1}`,\n                  relationships,\n                  table: row,\n                  texts,\n                })\n\n                if ('_order' in rowResult) {\n                  delete rowResult._order\n                }\n\n                arrayResult[locale].push(rowResult)\n              }\n\n              return arrayResult\n            }, {})\n          } else {\n            result[field.name] = fieldData.map((row, i) => {\n              if (row._uuid) {\n                row.id = row._uuid\n                delete row._uuid\n              }\n\n              if ('_order' in row) {\n                delete row._order\n              }\n\n              return traverseFields<T>({\n                adapter,\n                blocks,\n                config,\n                dataRef: row,\n                deletions,\n                fieldPrefix: '',\n                fields: field.fields,\n                numbers,\n                path: `${sanitizedPath}${field.name}.${i}`,\n                relationships,\n                table: row,\n                texts,\n              })\n            })\n          }\n        }\n\n        return result\n      }\n\n      if (field.type === 'blocks') {\n        const blockFieldPath = `${sanitizedPath}${field.name}`\n\n        if (Array.isArray(blocks[blockFieldPath])) {\n          if (field.localized) {\n            result[field.name] = {}\n\n            blocks[blockFieldPath].forEach((row) => {\n              if (row._uuid) {\n                row.id = row._uuid\n                delete row._uuid\n              }\n              if (typeof row._locale === 'string') {\n                if (!result[field.name][row._locale]) result[field.name][row._locale] = []\n                result[field.name][row._locale].push(row)\n                delete row._locale\n              }\n            })\n\n            Object.entries(result[field.name]).forEach(([locale, localizedBlocks]) => {\n              result[field.name][locale] = localizedBlocks.map((row) => {\n                const block = field.blocks.find(({ slug }) => slug === row.blockType)\n\n                if (block) {\n                  const blockResult = traverseFields<T>({\n                    adapter,\n                    blocks,\n                    config,\n                    dataRef: row,\n                    deletions,\n                    fieldPrefix: '',\n                    fields: block.fields,\n                    numbers,\n                    path: `${blockFieldPath}.${row._order - 1}`,\n                    relationships,\n                    table: row,\n                    texts,\n                  })\n\n                  delete blockResult._order\n                  return blockResult\n                }\n\n                return {}\n              })\n            })\n          } else {\n            result[field.name] = blocks[blockFieldPath].map((row, i) => {\n              delete row._order\n              if (row._uuid) {\n                row.id = row._uuid\n                delete row._uuid\n              }\n              const block = field.blocks.find(({ slug }) => slug === row.blockType)\n\n              if (block) {\n                return traverseFields<T>({\n                  adapter,\n                  blocks,\n                  config,\n                  dataRef: row,\n                  deletions,\n                  fieldPrefix: '',\n                  fields: block.fields,\n                  numbers,\n                  path: `${blockFieldPath}.${i}`,\n                  relationships,\n                  table: row,\n                  texts,\n                })\n              }\n\n              return {}\n            })\n          }\n        }\n\n        return result\n      }\n\n      if (field.type === 'relationship' || field.type === 'upload') {\n        if (typeof field.relationTo === 'string' && !('hasMany' in field && field.hasMany)) {\n          if (\n            field.localized &&\n            config.localization &&\n            config.localization.locales &&\n            Array.isArray(table?._locales)\n          ) {\n            table._locales.forEach((localeRow) => {\n              result[field.name] = { [localeRow._locale]: localeRow[fieldName] }\n            })\n          } else {\n            valuesToTransform.push({ ref: result, table })\n          }\n        } else {\n          const relationPathMatch = relationships[`${sanitizedPath}${field.name}`]\n          if (!relationPathMatch) {\n            if ('hasMany' in field && field.hasMany) {\n              if (field.localized && config.localization && config.localization.locales) {\n                result[field.name] = {\n                  [config.localization.defaultLocale]: [],\n                }\n              } else {\n                result[field.name] = []\n              }\n            }\n\n            return result\n          }\n\n          if (field.localized) {\n            result[field.name] = {}\n            const relationsByLocale: Record<string, Record<string, unknown>[]> = {}\n\n            relationPathMatch.forEach((row) => {\n              if (typeof row.locale === 'string') {\n                if (!relationsByLocale[row.locale]) relationsByLocale[row.locale] = []\n                relationsByLocale[row.locale].push(row)\n              }\n            })\n\n            Object.entries(relationsByLocale).forEach(([locale, relations]) => {\n              transformRelationship({\n                field,\n                locale,\n                ref: result,\n                relations,\n              })\n            })\n          } else {\n            transformRelationship({\n              field,\n              ref: result,\n              relations: relationPathMatch,\n            })\n          }\n          return result\n        }\n      }\n\n      if (field.type === 'text' && field?.hasMany) {\n        const textPathMatch = texts[`${sanitizedPath}${field.name}`]\n        if (!textPathMatch) return result\n\n        if (field.localized) {\n          result[field.name] = {}\n          const textsByLocale: Record<string, Record<string, unknown>[]> = {}\n\n          textPathMatch.forEach((row) => {\n            if (typeof row.locale === 'string') {\n              if (!textsByLocale[row.locale]) textsByLocale[row.locale] = []\n              textsByLocale[row.locale].push(row)\n            }\n          })\n\n          Object.entries(textsByLocale).forEach(([locale, texts]) => {\n            transformHasManyText({\n              field,\n              locale,\n              ref: result,\n              textRows: texts,\n            })\n          })\n        } else {\n          transformHasManyText({\n            field,\n            ref: result,\n            textRows: textPathMatch,\n          })\n        }\n\n        return result\n      }\n\n      if (field.type === 'number' && field.hasMany) {\n        const numberPathMatch = numbers[`${sanitizedPath}${field.name}`]\n        if (!numberPathMatch) return result\n\n        if (field.localized) {\n          result[field.name] = {}\n          const numbersByLocale: Record<string, Record<string, unknown>[]> = {}\n\n          numberPathMatch.forEach((row) => {\n            if (typeof row.locale === 'string') {\n              if (!numbersByLocale[row.locale]) numbersByLocale[row.locale] = []\n              numbersByLocale[row.locale].push(row)\n            }\n          })\n\n          Object.entries(numbersByLocale).forEach(([locale, numbers]) => {\n            transformHasManyNumber({\n              field,\n              locale,\n              numberRows: numbers,\n              ref: result,\n            })\n          })\n        } else {\n          transformHasManyNumber({\n            field,\n            numberRows: numberPathMatch,\n            ref: result,\n          })\n        }\n\n        return result\n      }\n\n      if (field.type === 'select' && field.hasMany) {\n        if (Array.isArray(fieldData)) {\n          if (field.localized) {\n            result[field.name] = fieldData.reduce((selectResult, row) => {\n              if (typeof row.locale === 'string') {\n                if (!selectResult[row.locale]) selectResult[row.locale] = []\n                selectResult[row.locale].push(row.value)\n              }\n\n              return selectResult\n            }, {})\n          } else {\n            result[field.name] = fieldData.map(({ value }) => value)\n          }\n        }\n        return result\n      }\n\n      if (field.localized && Array.isArray(table._locales)) {\n        table._locales.forEach((localeRow) => {\n          valuesToTransform.push({ ref: localizedFieldData, table: localeRow })\n        })\n      } else {\n        valuesToTransform.push({ ref: result, table })\n      }\n\n      valuesToTransform.forEach(({ ref, table }) => {\n        const fieldData = table[`${fieldPrefix || ''}${field.name}`]\n        const locale = table?._locale\n        let val = fieldData\n\n        switch (field.type) {\n          case 'tab':\n          case 'group': {\n            const groupFieldPrefix = `${fieldPrefix || ''}${field.name}_`\n\n            if (field.localized) {\n              if (typeof locale === 'string' && !ref[locale]) {\n                ref[locale] = {}\n                delete table._locale\n              }\n\n              Object.entries(ref).forEach(([groupLocale, groupLocaleData]) => {\n                ref[groupLocale] = traverseFields<Record<string, unknown>>({\n                  adapter,\n                  blocks,\n                  config,\n                  dataRef: groupLocaleData as Record<string, unknown>,\n                  deletions,\n                  fieldPrefix: groupFieldPrefix,\n                  fields: field.fields,\n                  numbers,\n                  path: `${sanitizedPath}${field.name}`,\n                  relationships,\n                  table,\n                  texts,\n                })\n              })\n              if ('_order' in ref) {\n                delete ref._order\n              }\n            } else {\n              const groupData = {}\n\n              ref[field.name] = traverseFields<Record<string, unknown>>({\n                adapter,\n                blocks,\n                config,\n                dataRef: groupData as Record<string, unknown>,\n                deletions,\n                fieldPrefix: groupFieldPrefix,\n                fields: field.fields,\n                numbers,\n                path: `${sanitizedPath}${field.name}`,\n                relationships,\n                table,\n                texts,\n              })\n              if ('_order' in ref) {\n                delete ref._order\n              }\n            }\n\n            return\n          }\n\n          case 'text': {\n            if (typeof fieldData === 'string') {\n              val = String(fieldData)\n            }\n\n            break\n          }\n\n          case 'number': {\n            if (typeof fieldData === 'string') {\n              val = Number.parseFloat(fieldData)\n            }\n\n            break\n          }\n\n          case 'date': {\n            if (typeof fieldData === 'string') {\n              val = new Date(fieldData).toISOString()\n            }\n\n            break\n          }\n\n          case 'relationship':\n          case 'upload': {\n            if (\n              val &&\n              typeof field.relationTo === 'string' &&\n              adapter.payload.collections[field.relationTo].customIDType === 'number'\n            ) {\n              val = Number(val)\n            }\n\n            break\n          }\n\n          default: {\n            break\n          }\n        }\n        if (typeof locale === 'string') {\n          ref[locale] = val\n        } else {\n          result[field.name] = val\n        }\n      })\n\n      if (Object.keys(localizedFieldData).length > 0) {\n        result[field.name] = localizedFieldData\n      }\n\n      return result\n    }\n\n    return result\n  }, dataRef)\n\n  if (Array.isArray(table._locales)) {\n    deletions.push(() => delete table._locales)\n  }\n\n  return formatted as T\n}\n"],"names":["fieldAffectsData","transformHasManyNumber","transformHasManyText","transformRelationship","traverseFields","adapter","blocks","config","dataRef","deletions","fieldPrefix","fields","numbers","path","relationships","table","texts","sanitizedPath","formatted","reduce","result","field","type","tabs","map","tab","fieldName","name","fieldData","localizedFieldData","valuesToTransform","push","Array","isArray","localized","arrayResult","row","_locale","locale","data","_uuid","id","rowResult","_order","i","blockFieldPath","forEach","Object","entries","localizedBlocks","block","find","slug","blockType","blockResult","relationTo","hasMany","localization","locales","_locales","localeRow","ref","relationPathMatch","defaultLocale","relationsByLocale","relations","textPathMatch","textsByLocale","textRows","numberPathMatch","numbersByLocale","numberRows","selectResult","value","val","groupFieldPrefix","groupLocale","groupLocaleData","groupData","String","Number","parseFloat","Date","toISOString","payload","collections","customIDType","keys","length"],"mappings":"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"}
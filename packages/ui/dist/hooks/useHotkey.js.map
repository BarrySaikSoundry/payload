{"version":3,"sources":["../../src/hooks/useHotkey.ts"],"sourcesContent":["'use client'\n\nimport { useModal } from '@faceless-ui/modal'\nimport { setsAreEqual } from 'payload/shared'\nimport { useCallback, useEffect } from 'react'\n\n// Required to be outside of hook, else debounce would be necessary\n// and then one could not prevent the default behaviour.\n\n// It maps the pressed keys with the time they were pressed, in order to implement a maximum time\n// for the user to press the next key in the sequence\n\n// This is necessary to prevent a bug where the keyup event, which unsets the key as pressed\n// is not fired when the window is not focused.\n// When the user then comes back to the window, the key is still registered as pressed, even though it's not.\nconst pressedKeys = new Map<string, number>([])\n\nconst map = {\n  altleft: 'alt',\n  altright: 'alt',\n  controlleft: 'ctrl',\n  controlright: 'ctrl',\n  ctrlleft: 'ctrl',\n  ctrlright: 'ctrl',\n  escape: 'esc',\n  metaleft: 'meta',\n  metaright: 'meta',\n  osleft: 'meta',\n  osright: 'meta',\n  shiftleft: 'shift',\n  shiftright: 'shift',\n}\n\nconst stripKey = (key: string) => {\n  return (map[key.toLowerCase()] || key).trim().toLowerCase().replace('key', '')\n}\n\nconst pushToKeys = (code: string) => {\n  const key = stripKey(code)\n\n  // There is a weird bug with macos that if the keys are not cleared they remain in the\n  // pressed keys set.\n  if (key === 'meta') {\n    pressedKeys.forEach(\n      (time, pressedKey) => pressedKey !== 'meta' && pressedKeys.delete(pressedKey),\n    )\n  }\n\n  pressedKeys.set(key, Date.now())\n}\n\nconst removeFromKeys = (code: string) => {\n  const key = stripKey(code)\n  // There is a weird bug with macos that if the keys are not cleared they remain in the\n  // pressed keys set.\n  if (key === 'meta') {\n    pressedKeys.clear()\n  }\n  pressedKeys.delete(key)\n}\n\n/**\n * Hook function to work with hotkeys.\n * @param param0.keyCode {string[]} The keys to listen for (`Event.code` without `'Key'` and lowercased)\n * @param param0.cmdCtrlKey {boolean} Whether Ctrl on windows or Cmd on mac must be pressed\n * @param param0.editDepth {boolean} This ensures that the hotkey is only triggered for the most top-level drawer in case there are nested drawers\n * @param func The callback function\n */\nexport const useHotkey = (\n  options: {\n    cmdCtrlKey: boolean\n    editDepth: number\n    keyCodes: string[]\n  },\n  func: (e: KeyboardEvent) => void,\n): void => {\n  const { cmdCtrlKey, editDepth, keyCodes } = options\n\n  const { modalState } = useModal()\n\n  const keydown = useCallback(\n    (event: CustomEvent | KeyboardEvent) => {\n      const e: KeyboardEvent = event.detail?.key ? event.detail : event\n      if (e.key === undefined) {\n        // Autofill events, or other synthetic events, can be ignored\n        return\n      }\n\n      // Filter out pressed keys which have been pressed > 3 seconds ago\n      pressedKeys.forEach((time, key) => {\n        if (Date.now() - time > 3000) {\n          pressedKeys.delete(key)\n        }\n      })\n\n      if (e.code) pushToKeys(e.code)\n\n      // Check for Mac and iPad\n      const hasCmd = window.navigator.userAgent.includes('Mac OS X')\n      const pressedWithoutModifier = [...pressedKeys.keys()].filter(\n        (key) => !['alt', 'ctrl', 'meta', 'shift'].includes(key),\n      )\n\n      // Check whether arrays contain the same values (regardless of number of occurrences)\n      if (\n        setsAreEqual(new Set(pressedWithoutModifier), new Set(keyCodes)) &&\n        (!cmdCtrlKey || (hasCmd && pressedKeys.has('meta')) || (!hasCmd && e.ctrlKey))\n      ) {\n        // get the maximum edit depth by counting the number of open drawers. modalState is and object which contains the state of all drawers.\n        const maxEditDepth =\n          Object.keys(modalState).filter((key) => modalState[key]?.isOpen)?.length + 1 || 1\n\n        if (maxEditDepth !== editDepth) {\n          // We only want to execute the hotkey from the most top-level drawer / edit depth.\n          return\n        }\n        // execute the function associated with the maximum edit depth\n        func(e)\n      }\n    },\n    [keyCodes, cmdCtrlKey, editDepth, modalState, func],\n  )\n\n  const keyup = useCallback((e: KeyboardEvent) => {\n    if (e.code) removeFromKeys(e.code)\n  }, [])\n\n  useEffect(() => {\n    document.addEventListener('keydown', keydown, false)\n    document.addEventListener('bypassKeyDown', keydown, false) // this is called if the keydown event's propagation is stopped by react-select\n    document.addEventListener('keyup', keyup, false)\n\n    return () => {\n      document.removeEventListener('keydown', keydown)\n      document.removeEventListener('bypassKeyDown', keydown)\n      document.removeEventListener('keyup', keyup)\n    }\n  }, [keydown, keyup])\n}\n"],"names":["useModal","setsAreEqual","useCallback","useEffect","pressedKeys","Map","map","altleft","altright","controlleft","controlright","ctrlleft","ctrlright","escape","metaleft","metaright","osleft","osright","shiftleft","shiftright","stripKey","key","toLowerCase","trim","replace","pushToKeys","code","forEach","time","pressedKey","delete","set","Date","now","removeFromKeys","clear","useHotkey","options","func","cmdCtrlKey","editDepth","keyCodes","modalState","keydown","event","e","detail","undefined","hasCmd","window","navigator","userAgent","includes","pressedWithoutModifier","keys","filter","Set","has","ctrlKey","maxEditDepth","Object","isOpen","length","keyup","document","addEventListener","removeEventListener"],"mappings":"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"}
{"version":3,"sources":["../../../src/forms/Form/mergeServerFormState.ts"],"sourcesContent":["import type { FormState } from 'payload'\n\nimport { dequal } from 'dequal/lite' // lite: no need for Map and Set support\n\nimport { mergeErrorPaths } from './mergeErrorPaths.js'\n\nconst serverPropsToAccept = ['passesCondition', 'valid', 'errorMessage']\n\n/**\n * Merges certain properties from the server state into the client state. These do not include values,\n * as we do not want to update them on the client like that, which would cause flickering.\n *\n * We want to use this to update the error state, and other properties that are not user input, as the error state\n * is the thing we want to keep in sync with the server (where it's calculated) on the client.\n */\nexport const mergeServerFormState = (\n  existingState: FormState,\n  incomingState: FormState,\n): { changed: boolean; newState: FormState } => {\n  let changed = false\n\n  const newState = {}\n\n  if (existingState) {\n    Object.entries(existingState).forEach(([path, newFieldState]) => {\n      if (!incomingState[path]) return\n\n      /**\n       * Handle error paths\n       */\n\n      const errorPathsResult = mergeErrorPaths(\n        newFieldState.errorPaths,\n        incomingState[path].errorPaths as unknown as string[],\n      )\n      if (errorPathsResult.result) {\n        if (errorPathsResult.changed) {\n          changed = errorPathsResult.changed\n        }\n        newFieldState.errorPaths = errorPathsResult.result\n      }\n\n      /**\n       * Handle filterOptions\n       */\n      if (incomingState[path]?.filterOptions || newFieldState.filterOptions) {\n        if (!dequal(incomingState[path]?.filterOptions, newFieldState.filterOptions)) {\n          changed = true\n          newFieldState.filterOptions = incomingState[path].filterOptions\n        }\n      }\n\n      /**\n       * Handle the rest which is in serverPropsToAccept\n       */\n      serverPropsToAccept.forEach((prop) => {\n        if (incomingState[path]?.[prop] !== newFieldState[prop]) {\n          changed = true\n          if (!(prop in incomingState[path])) {\n            delete newFieldState[prop]\n          } else {\n            newFieldState[prop] = incomingState[path][prop]\n          }\n        }\n      })\n\n      // Conditions don't work if we don't memcopy the new state, as the object references would otherwise be the same\n      newState[path] = { ...newFieldState }\n    })\n  }\n\n  return { changed, newState }\n}\n"],"names":["dequal","mergeErrorPaths","serverPropsToAccept","mergeServerFormState","existingState","incomingState","changed","newState","Object","entries","forEach","path","newFieldState","errorPathsResult","errorPaths","result","filterOptions","prop"],"mappings":"AAEA,SAASA,MAAM,QAAQ,cAAa,CAAC,wCAAwC;AAE7E,SAASC,eAAe,QAAQ,uBAAsB;AAEtD,MAAMC,sBAAsB;IAAC;IAAmB;IAAS;CAAe;AAExE;;;;;;CAMC,GACD,OAAO,MAAMC,uBAAuB,CAClCC,eACAC;IAEA,IAAIC,UAAU;IAEd,MAAMC,WAAW,CAAC;IAElB,IAAIH,eAAe;QACjBI,OAAOC,OAAO,CAACL,eAAeM,OAAO,CAAC,CAAC,CAACC,MAAMC,cAAc;YAC1D,IAAI,CAACP,aAAa,CAACM,KAAK,EAAE;YAE1B;;OAEC,GAED,MAAME,mBAAmBZ,gBACvBW,cAAcE,UAAU,EACxBT,aAAa,CAACM,KAAK,CAACG,UAAU;YAEhC,IAAID,iBAAiBE,MAAM,EAAE;gBAC3B,IAAIF,iBAAiBP,OAAO,EAAE;oBAC5BA,UAAUO,iBAAiBP,OAAO;gBACpC;gBACAM,cAAcE,UAAU,GAAGD,iBAAiBE,MAAM;YACpD;YAEA;;OAEC,GACD,IAAIV,aAAa,CAACM,KAAK,EAAEK,iBAAiBJ,cAAcI,aAAa,EAAE;gBACrE,IAAI,CAAChB,OAAOK,aAAa,CAACM,KAAK,EAAEK,eAAeJ,cAAcI,aAAa,GAAG;oBAC5EV,UAAU;oBACVM,cAAcI,aAAa,GAAGX,aAAa,CAACM,KAAK,CAACK,aAAa;gBACjE;YACF;YAEA;;OAEC,GACDd,oBAAoBQ,OAAO,CAAC,CAACO;gBAC3B,IAAIZ,aAAa,CAACM,KAAK,EAAE,CAACM,KAAK,KAAKL,aAAa,CAACK,KAAK,EAAE;oBACvDX,UAAU;oBACV,IAAI,CAAEW,CAAAA,QAAQZ,aAAa,CAACM,KAAK,AAAD,GAAI;wBAClC,OAAOC,aAAa,CAACK,KAAK;oBAC5B,OAAO;wBACLL,aAAa,CAACK,KAAK,GAAGZ,aAAa,CAACM,KAAK,CAACM,KAAK;oBACjD;gBACF;YACF;YAEA,gHAAgH;YAChHV,QAAQ,CAACI,KAAK,GAAG;gBAAE,GAAGC,aAAa;YAAC;QACtC;IACF;IAEA,OAAO;QAAEN;QAASC;IAAS;AAC7B,EAAC"}
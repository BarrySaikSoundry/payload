{"version":3,"sources":["../../../src/forms/Form/types.ts"],"sourcesContent":["import type { Data, Field, FormField, FormState, User } from 'payload'\nimport type React from 'react'\nimport type { Dispatch } from 'react'\n\nexport type Preferences = {\n  [key: string]: unknown\n}\n\nexport type FormProps = {\n  beforeSubmit?: ((args: { formState: FormState }) => Promise<FormState>)[]\n  children?: React.ReactNode\n  className?: string\n  disableSuccessStatus?: boolean\n  /**\n   * If you would like to solely leverage server-side validation on submit,\n   * you can disable checks that the form makes before it submits\n   */\n  disableValidationOnSubmit?: boolean\n  disabled?: boolean\n  /**\n   * By default, the form will get the field schema (not data) from the current document. If you pass this in, you can override that behavior.\n   * This is very useful for sub-forms, where the form's field schema is not necessarily the field schema of the current document (e.g. for the Blocks\n   * feature of the Lexical Rich Text field)\n   */\n  fields?: Field[]\n  handleResponse?: (\n    res: Response,\n    successToast: (value: string) => void,\n    errorToast: (value: string) => void,\n  ) => void\n  initialState?: FormState\n  isInitializing?: boolean\n  log?: boolean\n  onChange?: ((args: { formState: FormState }) => Promise<FormState>)[]\n  onSubmit?: (fields: FormState, data: Data) => void\n  onSuccess?: (json: unknown) => Promise<void> | void\n  redirect?: string\n  submitted?: boolean\n  uuid?: string\n  validationOperation?: 'create' | 'update'\n  waitForAutocomplete?: boolean\n} & (\n  | {\n      action: (formData: FormData) => Promise<void>\n    }\n  | {\n      action?: string\n      method?: 'DELETE' | 'GET' | 'PATCH' | 'POST'\n    }\n)\n\nexport type SubmitOptions = {\n  action?: string\n  method?: string\n  overrides?: Record<string, unknown>\n  skipValidation?: boolean\n}\n\nexport type DispatchFields = React.Dispatch<any>\nexport type Submit = (\n  options?: SubmitOptions,\n  e?: React.FormEvent<HTMLFormElement>,\n) => Promise<void>\nexport type ValidateForm = () => Promise<boolean>\nexport type CreateFormData = (overrides?: any) => FormData\nexport type GetFields = () => FormState\nexport type GetField = (path: string) => FormField\nexport type GetData = () => Data\nexport type GetSiblingData = (path: string) => Data\nexport type GetDataByPath = <T = unknown>(path: string) => T\nexport type SetModified = (modified: boolean) => void\nexport type SetSubmitted = (submitted: boolean) => void\nexport type SetProcessing = (processing: boolean) => void\n\nexport type Reset = (data: unknown) => Promise<void>\n\nexport type REPLACE_STATE = {\n  optimize?: boolean\n  state: FormState\n  type: 'REPLACE_STATE'\n}\n\nexport type REMOVE = {\n  path: string\n  type: 'REMOVE'\n}\n\nexport type MODIFY_CONDITION = {\n  path: string\n  result: boolean\n  type: 'MODIFY_CONDITION'\n  user: User\n}\n\nexport type UPDATE = {\n  path: string\n  type: 'UPDATE'\n} & Partial<FormField>\n\nexport type REMOVE_ROW = {\n  path: string\n  rowIndex: number\n  type: 'REMOVE_ROW'\n}\n\nexport type ADD_ROW = {\n  blockType?: string\n  path: string\n  rowIndex?: number\n  subFieldState?: FormState\n  type: 'ADD_ROW'\n}\n\nexport type REPLACE_ROW = {\n  blockType?: string\n  path: string\n  rowIndex: number\n  subFieldState?: FormState\n  type: 'REPLACE_ROW'\n}\n\nexport type DUPLICATE_ROW = {\n  path: string\n  rowIndex: number\n  type: 'DUPLICATE_ROW'\n}\n\nexport type MOVE_ROW = {\n  moveFromIndex: number\n  moveToIndex: number\n  path: string\n  type: 'MOVE_ROW'\n}\n\nexport type ADD_SERVER_ERRORS = {\n  errors: {\n    field: string\n    message: string\n  }[]\n  type: 'ADD_SERVER_ERRORS'\n}\n\nexport type SET_ROW_COLLAPSED = {\n  collapsed: boolean\n  path: string\n  rowID: string\n  setDocFieldPreferences: (field: string, fieldPreferences: { [key: string]: unknown }) => void\n  type: 'SET_ROW_COLLAPSED'\n}\n\nexport type SET_ALL_ROWS_COLLAPSED = {\n  collapsed: boolean\n  path: string\n  setDocFieldPreferences: (field: string, fieldPreferences: { [key: string]: unknown }) => void\n  type: 'SET_ALL_ROWS_COLLAPSED'\n}\n\nexport type FieldAction =\n  | ADD_ROW\n  | ADD_SERVER_ERRORS\n  | DUPLICATE_ROW\n  | MODIFY_CONDITION\n  | MOVE_ROW\n  | REMOVE\n  | REMOVE_ROW\n  | REPLACE_ROW\n  | REPLACE_STATE\n  | SET_ALL_ROWS_COLLAPSED\n  | SET_ROW_COLLAPSED\n  | UPDATE\n\nexport type FormFieldsContext = [FormState, Dispatch<FieldAction>]\n\nexport type Context = {\n  addFieldRow: ({\n    data,\n    path,\n    rowIndex,\n    schemaPath,\n  }: {\n    data?: Data\n    path: string\n    /*\n     * by default the new row will be added to the end of the list\n     */\n    rowIndex?: number\n    schemaPath: string\n  }) => Promise<void>\n  buildRowErrors: () => void\n  createFormData: CreateFormData\n  disabled: boolean\n  dispatchFields: Dispatch<FieldAction>\n  /**\n   * Form context fields may be outdated and should not be relied on. Instead, prefer `useFormFields`.\n   */\n  fields: FormState\n  formRef: React.MutableRefObject<HTMLFormElement>\n  getData: GetData\n  getDataByPath: GetDataByPath\n  getField: GetField\n  getFields: GetFields\n  getSiblingData: GetSiblingData\n  initializing: boolean\n  removeFieldRow: ({ path, rowIndex }: { path: string; rowIndex: number }) => void\n  replaceFieldRow: ({\n    data,\n    path,\n    rowIndex,\n    schemaPath,\n  }: {\n    data?: Data\n    path: string\n    rowIndex: number\n    schemaPath: string\n  }) => Promise<void>\n  replaceState: (state: FormState) => void\n  reset: Reset\n  setDisabled: (disabled: boolean) => void\n  setModified: SetModified\n  setProcessing: SetProcessing\n  setSubmitted: SetSubmitted\n  submit: Submit\n  uuid?: string\n  validateForm: ValidateForm\n}\n"],"names":[],"mappings":"AA6KA,WAmDC"}
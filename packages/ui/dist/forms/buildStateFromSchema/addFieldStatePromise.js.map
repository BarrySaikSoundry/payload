{"version":3,"sources":["../../../src/forms/buildStateFromSchema/addFieldStatePromise.ts"],"sourcesContent":["import type {\n  Data,\n  DocumentPreferences,\n  Field,\n  FormField,\n  FormState,\n  PayloadRequest,\n} from 'payload'\n\nimport ObjectIdImport from 'bson-objectid'\nimport { fieldAffectsData, fieldHasSubFields, tabHasName } from 'payload/shared'\n\nimport { getFilterOptionsQuery } from './getFilterOptionsQuery.js'\nimport { iterateFields } from './iterateFields.js'\n\nconst ObjectId = (ObjectIdImport.default ||\n  ObjectIdImport) as unknown as typeof ObjectIdImport.default\n\nexport type AddFieldStatePromiseArgs = {\n  addErrorPathToParent: (path: string) => void\n  /**\n   * if all parents are localized, then the field is localized\n   */\n  anyParentLocalized?: boolean\n  data: Data\n  field: Field\n  fieldIndex: number\n  /**\n   * You can use this to filter down to only `localized` fields that require translation (type: text, textarea, etc.). Another plugin might want to look for only `point` type fields to do some GIS function. With the filter function you can go in like a surgeon.\n   */\n  filter?: (args: AddFieldStatePromiseArgs) => boolean\n  /**\n   * Force the value of fields like arrays or blocks to be the full value instead of the length @default false\n   */\n  forceFullValue?: boolean\n  fullData: Data\n  id: number | string\n  /**\n   * Whether the field schema should be included in the state\n   */\n  includeSchema?: boolean\n  /**\n   * Whether to omit parent fields in the state. @default false\n   */\n  omitParents?: boolean\n  operation: 'create' | 'update'\n  passesCondition: boolean\n  path: string\n  preferences: DocumentPreferences\n\n  /**\n   * Req is used for validation and defaultValue calculation. If you don't need validation,\n   * just create your own req and pass in the locale and the user\n   */\n  req: PayloadRequest\n  /**\n   * Whether to skip checking the field's condition. @default false\n   */\n  skipConditionChecks?: boolean\n  /**\n   * Whether to skip validating the field. @default false\n   */\n  skipValidation?: boolean\n  state: FormState\n}\n\n/**\n * Flattens the fields schema and fields data.\n * The output is the field path (e.g. array.0.name) mapped to a FormField object.\n */\nexport const addFieldStatePromise = async (args: AddFieldStatePromiseArgs): Promise<void> => {\n  const {\n    id,\n    addErrorPathToParent: addErrorPathToParentArg,\n    anyParentLocalized = false,\n    data,\n    field,\n    fieldIndex,\n    filter,\n    forceFullValue = false,\n    fullData,\n    includeSchema = false,\n    omitParents = false,\n    operation,\n    passesCondition,\n    path,\n    preferences,\n    req,\n    skipConditionChecks = false,\n    skipValidation = false,\n    state,\n  } = args\n\n  if (fieldAffectsData(field)) {\n    const validate = field.validate\n\n    const fieldState: FormField = {\n      errorPaths: [],\n      fieldSchema: includeSchema ? field : undefined,\n      initialValue: undefined,\n      passesCondition,\n      valid: true,\n      value: undefined,\n    }\n\n    let validationResult: string | true = true\n\n    if (typeof validate === 'function' && !skipValidation && passesCondition) {\n      let jsonError\n\n      if (field.type === 'json' && typeof data[field.name] === 'string') {\n        try {\n          JSON.parse(data[field.name] as string)\n        } catch (e) {\n          jsonError = e\n        }\n      }\n\n      validationResult = await validate(data?.[field.name], {\n        ...field,\n        id,\n        data: fullData,\n        operation,\n        req,\n        siblingData: data,\n        // @ts-expect-error-next-line\n        jsonError,\n        preferences,\n      })\n    }\n\n    const addErrorPathToParent = (errorPath: string) => {\n      if (typeof addErrorPathToParentArg === 'function') {\n        addErrorPathToParentArg(errorPath)\n      }\n\n      if (!fieldState.errorPaths.includes(errorPath)) {\n        fieldState.errorPaths.push(errorPath)\n        fieldState.valid = false\n      }\n    }\n\n    if (typeof validationResult === 'string') {\n      fieldState.errorMessage = validationResult\n      fieldState.valid = false\n      addErrorPathToParent(`${path}${field.name}`)\n    } else {\n      fieldState.valid = true\n    }\n\n    switch (field.type) {\n      case 'array': {\n        const arrayValue = Array.isArray(data[field.name]) ? data[field.name] : []\n\n        const { promises, rowMetadata } = arrayValue.reduce(\n          (acc, row, i) => {\n            const rowPath = `${path}${field.name}.${i}.`\n            row.id = row?.id || new ObjectId().toHexString()\n\n            if (!omitParents && (!filter || filter(args))) {\n              state[`${rowPath}id`] = {\n                fieldSchema: includeSchema\n                  ? field.fields.find((field) => 'name' in field && field.name === 'id')\n                  : undefined,\n                initialValue: row.id,\n                valid: true,\n                value: row.id,\n              }\n            }\n\n            acc.promises.push(\n              iterateFields({\n                id,\n                addErrorPathToParent,\n                anyParentLocalized: field.localized || anyParentLocalized,\n                data: row,\n                fields: field.fields,\n                filter,\n                forceFullValue,\n                fullData,\n                includeSchema,\n                omitParents,\n                operation,\n                parentPassesCondition: passesCondition,\n                path: rowPath,\n                preferences,\n                req,\n                skipConditionChecks,\n                skipValidation,\n                state,\n              }),\n            )\n\n            const collapsedRowIDs = preferences?.fields?.[`${path}${field.name}`]?.collapsed\n\n            acc.rowMetadata.push({\n              id: row.id,\n              collapsed:\n                collapsedRowIDs === undefined\n                  ? field.admin.initCollapsed\n                  : collapsedRowIDs.includes(row.id),\n            })\n\n            return acc\n          },\n          {\n            promises: [],\n            rowMetadata: [],\n          },\n        )\n\n        await Promise.all(promises)\n\n        // Add values to field state\n        if (data[field.name] === null) {\n          fieldState.value = null\n          fieldState.initialValue = null\n        } else {\n          fieldState.value = forceFullValue ? arrayValue : arrayValue.length\n          fieldState.initialValue = forceFullValue ? arrayValue : arrayValue.length\n\n          if (arrayValue.length > 0) {\n            fieldState.disableFormData = true\n          }\n        }\n\n        fieldState.rows = rowMetadata\n\n        // Add field to state\n        if (!omitParents && (!filter || filter(args))) {\n          state[`${path}${field.name}`] = fieldState\n        }\n\n        break\n      }\n\n      case 'blocks': {\n        const blocksValue = Array.isArray(data[field.name]) ? data[field.name] : []\n\n        const { promises, rowMetadata } = blocksValue.reduce(\n          (acc, row, i) => {\n            const block = field.blocks.find((blockType) => blockType.slug === row.blockType)\n            const rowPath = `${path}${field.name}.${i}.`\n\n            if (block) {\n              row.id = row?.id || new ObjectId().toHexString()\n\n              if (!omitParents && (!filter || filter(args))) {\n                state[`${rowPath}id`] = {\n                  fieldSchema: includeSchema\n                    ? block.fields.find(\n                        (blockField) => 'name' in blockField && blockField.name === 'id',\n                      )\n                    : undefined,\n                  initialValue: row.id,\n                  valid: true,\n                  value: row.id,\n                }\n\n                state[`${rowPath}blockType`] = {\n                  fieldSchema: includeSchema\n                    ? block.fields.find(\n                        (blockField) => 'name' in blockField && blockField.name === 'blockType',\n                      )\n                    : undefined,\n                  initialValue: row.blockType,\n                  valid: true,\n                  value: row.blockType,\n                }\n\n                state[`${rowPath}blockName`] = {\n                  fieldSchema: includeSchema\n                    ? block.fields.find(\n                        (blockField) => 'name' in blockField && blockField.name === 'blockName',\n                      )\n                    : undefined,\n                  initialValue: row.blockName,\n                  valid: true,\n                  value: row.blockName,\n                }\n              }\n\n              acc.promises.push(\n                iterateFields({\n                  id,\n                  addErrorPathToParent,\n                  anyParentLocalized: field.localized || anyParentLocalized,\n                  data: row,\n                  fields: block.fields,\n                  filter,\n                  forceFullValue,\n                  fullData,\n                  includeSchema,\n                  omitParents,\n                  operation,\n                  parentPassesCondition: passesCondition,\n                  path: rowPath,\n                  preferences,\n                  req,\n                  skipConditionChecks,\n                  skipValidation,\n                  state,\n                }),\n              )\n\n              const collapsedRowIDs = preferences?.fields?.[`${path}${field.name}`]?.collapsed\n\n              acc.rowMetadata.push({\n                id: row.id,\n                blockType: row.blockType,\n                collapsed:\n                  collapsedRowIDs === undefined\n                    ? field.admin.initCollapsed\n                    : collapsedRowIDs.includes(row.id),\n              })\n            }\n\n            return acc\n          },\n          {\n            promises: [],\n            rowMetadata: [],\n          },\n        )\n\n        await Promise.all(promises)\n\n        // Add values to field state\n        if (data[field.name] === null) {\n          fieldState.value = null\n          fieldState.initialValue = null\n        } else {\n          fieldState.value = forceFullValue ? blocksValue : blocksValue.length\n          fieldState.initialValue = forceFullValue ? blocksValue : blocksValue.length\n\n          if (blocksValue.length > 0) {\n            fieldState.disableFormData = true\n          }\n        }\n\n        fieldState.rows = rowMetadata\n\n        // Add field to state\n        if (!omitParents && (!filter || filter(args))) {\n          state[`${path}${field.name}`] = fieldState\n        }\n\n        break\n      }\n\n      case 'group': {\n        if (!filter || filter(args)) {\n          fieldState.disableFormData = true\n          state[`${path}${field.name}`] = fieldState\n        }\n\n        await iterateFields({\n          id,\n          addErrorPathToParent,\n          anyParentLocalized: field.localized || anyParentLocalized,\n          data: data?.[field.name] || {},\n          fields: field.fields,\n          filter,\n          forceFullValue,\n          fullData,\n          includeSchema,\n          omitParents,\n          operation,\n          parentPassesCondition: passesCondition,\n          path: `${path}${field.name}.`,\n          preferences,\n          req,\n          skipConditionChecks,\n          skipValidation,\n          state,\n        })\n\n        break\n      }\n\n      case 'relationship': {\n        if (typeof field.filterOptions === 'function') {\n          const query = await getFilterOptionsQuery(field.filterOptions, {\n            id,\n            data: fullData,\n            relationTo: field.relationTo,\n            siblingData: data,\n            user: req.user,\n          })\n\n          fieldState.filterOptions = query\n        }\n\n        if (field.hasMany) {\n          const relationshipValue = Array.isArray(data[field.name])\n            ? data[field.name].map((relationship) => {\n                if (Array.isArray(field.relationTo)) {\n                  return {\n                    relationTo: relationship.relationTo,\n                    value:\n                      relationship.value && typeof relationship.value === 'object'\n                        ? relationship.value?.id\n                        : relationship.value,\n                  }\n                }\n                if (typeof relationship === 'object' && relationship !== null) {\n                  return relationship.id\n                }\n                return relationship\n              })\n            : undefined\n\n          fieldState.value = relationshipValue\n          fieldState.initialValue = relationshipValue\n        } else if (Array.isArray(field.relationTo)) {\n          if (\n            data[field.name] &&\n            typeof data[field.name] === 'object' &&\n            'relationTo' in data[field.name] &&\n            'value' in data[field.name]\n          ) {\n            const value =\n              typeof data[field.name]?.value === 'object' &&\n              data[field.name]?.value &&\n              'id' in data[field.name].value\n                ? data[field.name].value.id\n                : data[field.name].value\n            const relationshipValue = {\n              relationTo: data[field.name]?.relationTo,\n              value,\n            }\n            fieldState.value = relationshipValue\n            fieldState.initialValue = relationshipValue\n          }\n        } else {\n          const relationshipValue =\n            data[field.name] && typeof data[field.name] === 'object' && 'id' in data[field.name]\n              ? data[field.name].id\n              : data[field.name]\n          fieldState.value = relationshipValue\n          fieldState.initialValue = relationshipValue\n        }\n\n        if (!filter || filter(args)) {\n          state[`${path}${field.name}`] = fieldState\n        }\n\n        break\n      }\n\n      case 'upload': {\n        if (typeof field.filterOptions === 'function') {\n          const query = await getFilterOptionsQuery(field.filterOptions, {\n            id,\n            data: fullData,\n            relationTo: field.relationTo,\n            siblingData: data,\n            user: req.user,\n          })\n\n          fieldState.filterOptions = query\n        }\n\n        const relationshipValue =\n          data[field.name] && typeof data[field.name] === 'object' && 'id' in data[field.name]\n            ? data[field.name].id\n            : data[field.name]\n        fieldState.value = relationshipValue\n        fieldState.initialValue = relationshipValue\n\n        if (!filter || filter(args)) {\n          state[`${path}${field.name}`] = fieldState\n        }\n\n        break\n      }\n\n      default: {\n        fieldState.value = data[field.name]\n        fieldState.initialValue = data[field.name]\n\n        // Add field to state\n        if (!filter || filter(args)) {\n          state[`${path}${field.name}`] = fieldState\n        }\n\n        break\n      }\n    }\n  } else if (fieldHasSubFields(field)) {\n    // Handle field types that do not use names (row, etc)\n\n    if (!filter || filter(args)) {\n      state[`${path}_index-${fieldIndex}`] = {\n        disableFormData: true,\n        errorPaths: [],\n        initialValue: undefined,\n        passesCondition,\n        valid: true,\n        value: undefined,\n      }\n    }\n\n    await iterateFields({\n      id,\n      // passthrough parent functionality\n      addErrorPathToParent: addErrorPathToParentArg,\n      anyParentLocalized: field.localized || anyParentLocalized,\n      data,\n      fields: field.fields,\n      filter,\n      forceFullValue,\n      fullData,\n      includeSchema,\n      omitParents,\n      operation,\n      parentPassesCondition: passesCondition,\n      path,\n      preferences,\n      req,\n      skipConditionChecks,\n      skipValidation,\n      state,\n    })\n  } else if (field.type === 'tabs') {\n    const promises = field.tabs.map((tab) => {\n      const isNamedTab = tabHasName(tab)\n\n      return iterateFields({\n        id,\n        // passthrough parent functionality\n        addErrorPathToParent: addErrorPathToParentArg,\n        anyParentLocalized: tab.localized || anyParentLocalized,\n        data: isNamedTab ? data?.[tab.name] || {} : data,\n        fields: tab.fields,\n        filter,\n        forceFullValue,\n        fullData,\n        includeSchema,\n        omitParents,\n        operation,\n        parentPassesCondition: passesCondition,\n        path: isNamedTab ? `${path}${tab.name}.` : path,\n        preferences,\n        req,\n        skipConditionChecks,\n        skipValidation,\n        state,\n      })\n    })\n\n    await Promise.all(promises)\n  } else if (field.type === 'ui') {\n    if (!filter || filter(args)) {\n      state[`${path}_index-${fieldIndex}`] = {\n        disableFormData: true,\n        errorPaths: [],\n        initialValue: undefined,\n        passesCondition,\n        valid: true,\n        value: undefined,\n      }\n    }\n  }\n}\n"],"names":["ObjectIdImport","fieldAffectsData","fieldHasSubFields","tabHasName","getFilterOptionsQuery","iterateFields","ObjectId","default","addFieldStatePromise","args","id","addErrorPathToParent","addErrorPathToParentArg","anyParentLocalized","data","field","fieldIndex","filter","forceFullValue","fullData","includeSchema","omitParents","operation","passesCondition","path","preferences","req","skipConditionChecks","skipValidation","state","validate","fieldState","errorPaths","fieldSchema","undefined","initialValue","valid","value","validationResult","jsonError","type","name","JSON","parse","e","siblingData","errorPath","includes","push","errorMessage","arrayValue","Array","isArray","promises","rowMetadata","reduce","acc","row","i","rowPath","toHexString","fields","find","localized","parentPassesCondition","collapsedRowIDs","collapsed","admin","initCollapsed","Promise","all","length","disableFormData","rows","blocksValue","block","blocks","blockType","slug","blockField","blockName","filterOptions","query","relationTo","user","hasMany","relationshipValue","map","relationship","tabs","tab","isNamedTab"],"mappings":"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"}
{"version":3,"sources":["../../../src/elements/Pagination/index.tsx"],"sourcesContent":["'use client'\nimport React from 'react'\n\nimport { ClickableArrow } from './ClickableArrow/index.js'\nimport { Page } from './Page/index.js'\nimport { Separator } from './Separator/index.js'\nimport './index.scss'\n\nconst nodeTypes = {\n  ClickableArrow,\n  Page,\n  Separator,\n}\n\nconst baseClass = 'paginator'\n\nexport type PaginationProps = {\n  hasNextPage?: boolean\n  hasPrevPage?: boolean\n  limit?: number\n  nextPage?: number\n  numberOfNeighbors?: number\n  onChange?: (page: number) => void\n  page?: number\n  prevPage?: number\n  totalPages?: number\n}\n\nexport type Node =\n  | {\n      props?: {\n        direction?: 'left' | 'right'\n        isDisabled?: boolean\n        isFirstPage?: boolean\n        isLastPage?: boolean\n        page?: number\n        updatePage: (page?: number) => void\n      }\n      type: 'ClickableArrow' | 'Page' | 'Separator'\n    }\n  | number\n\nexport const Pagination: React.FC<PaginationProps> = (props) => {\n  const {\n    hasNextPage = false,\n    hasPrevPage = false,\n    nextPage = null,\n    numberOfNeighbors = 1,\n    onChange,\n    page: currentPage,\n    prevPage = null,\n    totalPages = null,\n  } = props\n\n  if (!totalPages || totalPages <= 1) return null\n\n  const updatePage = (page) => {\n    if (typeof onChange === 'function') onChange(page)\n  }\n\n  // Create array of integers for each page\n  const pages = Array.from({ length: totalPages }, (_, index) => index + 1)\n\n  // Assign indices for start and end of the range of pages that should be shown in paginator\n  let rangeStartIndex = currentPage - 1 - numberOfNeighbors\n\n  // Sanitize rangeStartIndex in case it is less than zero for safe split\n  if (rangeStartIndex <= 0) rangeStartIndex = 0\n\n  const rangeEndIndex = currentPage - 1 + numberOfNeighbors + 1\n\n  // Slice out the range of pages that we want to render\n  const nodes: Node[] = pages.slice(rangeStartIndex, rangeEndIndex)\n\n  // Add prev separator if necessary\n  if (currentPage - numberOfNeighbors - 1 >= 2) nodes.unshift({ type: 'Separator' })\n  // Add first page if necessary\n  if (currentPage > numberOfNeighbors + 1) {\n    nodes.unshift({\n      type: 'Page',\n      props: {\n        isFirstPage: true,\n        page: 1,\n        updatePage,\n      },\n    })\n  }\n\n  // Add next separator if necessary\n  if (currentPage + numberOfNeighbors + 1 < totalPages) nodes.push({ type: 'Separator' })\n  // Add last page if necessary\n  if (rangeEndIndex < totalPages) {\n    nodes.push({\n      type: 'Page',\n      props: {\n        isLastPage: true,\n        page: totalPages,\n        updatePage,\n      },\n    })\n  }\n\n  // Add prev and next arrows based on necessity\n  nodes.unshift({\n    type: 'ClickableArrow',\n    props: {\n      direction: 'right',\n      isDisabled: !hasNextPage,\n      updatePage: () => updatePage(nextPage),\n    },\n  })\n\n  nodes.unshift({\n    type: 'ClickableArrow',\n    props: {\n      direction: 'left',\n      isDisabled: !hasPrevPage,\n      updatePage: () => updatePage(prevPage),\n    },\n  })\n\n  return (\n    <div className={baseClass}>\n      {nodes.map((node, i) => {\n        if (typeof node === 'number') {\n          return (\n            <Page isCurrent={currentPage === node} key={i} page={node} updatePage={updatePage} />\n          )\n        }\n\n        const NodeType = nodeTypes[node.type]\n\n        return <NodeType key={i} {...node.props} />\n      })}\n    </div>\n  )\n}\n"],"names":["React","ClickableArrow","Page","Separator","nodeTypes","baseClass","Pagination","props","hasNextPage","hasPrevPage","nextPage","numberOfNeighbors","onChange","page","currentPage","prevPage","totalPages","updatePage","pages","Array","from","length","_","index","rangeStartIndex","rangeEndIndex","nodes","slice","unshift","type","isFirstPage","push","isLastPage","direction","isDisabled","div","className","map","node","i","isCurrent","NodeType"],"mappings":"AAAA;;AACA,OAAOA,WAAW,QAAO;AAEzB,SAASC,cAAc,QAAQ,4BAA2B;AAC1D,SAASC,IAAI,QAAQ,kBAAiB;AACtC,SAASC,SAAS,QAAQ,uBAAsB;AAChD,OAAO,eAAc;AAErB,MAAMC,YAAY;IAChBH;IACAC;IACAC;AACF;AAEA,MAAME,YAAY;AA4BlB,OAAO,MAAMC,aAAwC,CAACC;IACpD,MAAM,EACJC,cAAc,KAAK,EACnBC,cAAc,KAAK,EACnBC,WAAW,IAAI,EACfC,oBAAoB,CAAC,EACrBC,QAAQ,EACRC,MAAMC,WAAW,EACjBC,WAAW,IAAI,EACfC,aAAa,IAAI,EAClB,GAAGT;IAEJ,IAAI,CAACS,cAAcA,cAAc,GAAG,OAAO;IAE3C,MAAMC,aAAa,CAACJ;QAClB,IAAI,OAAOD,aAAa,YAAYA,SAASC;IAC/C;IAEA,yCAAyC;IACzC,MAAMK,QAAQC,MAAMC,IAAI,CAAC;QAAEC,QAAQL;IAAW,GAAG,CAACM,GAAGC,QAAUA,QAAQ;IAEvE,2FAA2F;IAC3F,IAAIC,kBAAkBV,cAAc,IAAIH;IAExC,uEAAuE;IACvE,IAAIa,mBAAmB,GAAGA,kBAAkB;IAE5C,MAAMC,gBAAgBX,cAAc,IAAIH,oBAAoB;IAE5D,sDAAsD;IACtD,MAAMe,QAAgBR,MAAMS,KAAK,CAACH,iBAAiBC;IAEnD,kCAAkC;IAClC,IAAIX,cAAcH,oBAAoB,KAAK,GAAGe,MAAME,OAAO,CAAC;QAAEC,MAAM;IAAY;IAChF,8BAA8B;IAC9B,IAAIf,cAAcH,oBAAoB,GAAG;QACvCe,MAAME,OAAO,CAAC;YACZC,MAAM;YACNtB,OAAO;gBACLuB,aAAa;gBACbjB,MAAM;gBACNI;YACF;QACF;IACF;IAEA,kCAAkC;IAClC,IAAIH,cAAcH,oBAAoB,IAAIK,YAAYU,MAAMK,IAAI,CAAC;QAAEF,MAAM;IAAY;IACrF,6BAA6B;IAC7B,IAAIJ,gBAAgBT,YAAY;QAC9BU,MAAMK,IAAI,CAAC;YACTF,MAAM;YACNtB,OAAO;gBACLyB,YAAY;gBACZnB,MAAMG;gBACNC;YACF;QACF;IACF;IAEA,8CAA8C;IAC9CS,MAAME,OAAO,CAAC;QACZC,MAAM;QACNtB,OAAO;YACL0B,WAAW;YACXC,YAAY,CAAC1B;YACbS,YAAY,IAAMA,WAAWP;QAC/B;IACF;IAEAgB,MAAME,OAAO,CAAC;QACZC,MAAM;QACNtB,OAAO;YACL0B,WAAW;YACXC,YAAY,CAACzB;YACbQ,YAAY,IAAMA,WAAWF;QAC/B;IACF;IAEA,qBACE,KAACoB;QAAIC,WAAW/B;kBACbqB,MAAMW,GAAG,CAAC,CAACC,MAAMC;YAChB,IAAI,OAAOD,SAAS,UAAU;gBAC5B,qBACE,KAACpC;oBAAKsC,WAAW1B,gBAAgBwB;oBAAczB,MAAMyB;oBAAMrB,YAAYA;mBAA3BsB;YAEhD;YAEA,MAAME,WAAWrC,SAAS,CAACkC,KAAKT,IAAI,CAAC;YAErC,qBAAO,KAACY;gBAAkB,GAAGH,KAAK/B,KAAK;eAAjBgC;QACxB;;AAGN,EAAC"}
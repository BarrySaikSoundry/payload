{"version":3,"sources":["../../../src/elements/WhereBuilder/reduceFieldMap.tsx"],"sourcesContent":["'use client'\nimport type { ClientTranslationKeys, I18nClient } from '@payloadcms/translations'\n\nimport { getTranslation } from '@payloadcms/translations'\n\nimport type { FieldMap } from '../../utilities/buildComponentMap.js'\n\nimport { createNestedClientFieldPath } from '../../forms/Form/createNestedFieldPath.js'\nimport { combineLabel } from '../FieldSelect/index.js'\nimport fieldTypes from './field-types.js'\n\nexport type ReduceFieldMapArgs = {\n  fieldMap: FieldMap\n  i18n: I18nClient\n  labelPrefix?: string\n  pathPrefix?: string\n}\n\n/**\n * Reduces a field map to a flat array of fields with labels and values.\n * Used in the WhereBuilder component to render the fields in the dropdown.\n */\nexport const reduceFieldMap = ({ fieldMap, i18n, labelPrefix, pathPrefix }: ReduceFieldMapArgs) => {\n  return fieldMap.reduce((reduced, field) => {\n    if (field.disableListFilter) return reduced\n\n    if (field.type === 'tabs' && 'tabs' in field.fieldComponentProps) {\n      const tabs = field.fieldComponentProps.tabs\n      tabs.forEach((tab) => {\n        if (typeof tab.label !== 'boolean') {\n          const localizedTabLabel = getTranslation(tab.label, i18n)\n          const labelWithPrefix = labelPrefix\n            ? labelPrefix + ' > ' + localizedTabLabel\n            : localizedTabLabel\n\n          // Make sure we handle nested tabs\n          const tabPathPrefix = tab.name\n            ? pathPrefix\n              ? pathPrefix + '.' + tab.name\n              : tab.name\n            : pathPrefix\n\n          if (typeof localizedTabLabel === 'string') {\n            reduced.push(\n              ...reduceFieldMap({\n                fieldMap: tab.fieldMap,\n                i18n,\n                labelPrefix: labelWithPrefix,\n                pathPrefix: tabPathPrefix,\n              }),\n            )\n          }\n        }\n      })\n      return reduced\n    }\n\n    // Rows cant have labels, so we need to handle them differently\n    if (field.type === 'row' && 'fieldMap' in field.fieldComponentProps) {\n      reduced.push(\n        ...reduceFieldMap({\n          fieldMap: field.fieldComponentProps.fieldMap,\n          i18n,\n          labelPrefix,\n          pathPrefix,\n        }),\n      )\n      return reduced\n    }\n\n    if (field.type === 'collapsible' && 'fieldMap' in field.fieldComponentProps) {\n      const localizedTabLabel = getTranslation(field.fieldComponentProps.label, i18n)\n      const labelWithPrefix = labelPrefix\n        ? labelPrefix + ' > ' + localizedTabLabel\n        : localizedTabLabel\n\n      reduced.push(\n        ...reduceFieldMap({\n          fieldMap: field.fieldComponentProps.fieldMap,\n          i18n,\n          labelPrefix: labelWithPrefix,\n          pathPrefix,\n        }),\n      )\n      return reduced\n    }\n\n    if (field.type === 'group' && 'fieldMap' in field.fieldComponentProps) {\n      const translatedLabel = getTranslation(field.fieldComponentProps.label, i18n)\n\n      const labelWithPrefix = labelPrefix\n        ? translatedLabel\n          ? labelPrefix + ' > ' + translatedLabel\n          : labelPrefix\n        : translatedLabel\n\n      // Make sure we handle deeply nested groups\n      const pathWithPrefix = field.name\n        ? pathPrefix\n          ? pathPrefix + '.' + field.name\n          : field.name\n        : pathPrefix\n\n      reduced.push(\n        ...reduceFieldMap({\n          fieldMap: field.fieldComponentProps.fieldMap,\n          i18n,\n          labelPrefix: labelWithPrefix,\n          pathPrefix: pathWithPrefix,\n        }),\n      )\n      return reduced\n    }\n\n    if (typeof fieldTypes[field.type] === 'object') {\n      const operatorKeys = new Set()\n      const operators = fieldTypes[field.type].operators.reduce((acc, operator) => {\n        if (!operatorKeys.has(operator.value)) {\n          operatorKeys.add(operator.value)\n          const operatorKey = `operators:${operator.label}` as ClientTranslationKeys\n          acc.push({\n            ...operator,\n            label: i18n.t(operatorKey),\n          })\n        }\n        return acc\n      }, [])\n\n      const localizedLabel = getTranslation(field.fieldComponentProps.label, i18n)\n\n      const formattedLabel = labelPrefix\n        ? combineLabel({\n            field,\n            prefix: labelPrefix,\n          })\n        : localizedLabel\n\n      const formattedValue = pathPrefix\n        ? createNestedClientFieldPath(pathPrefix, field)\n        : field.name\n\n      const formattedField = {\n        label: formattedLabel,\n        value: formattedValue,\n        ...fieldTypes[field.type],\n        operators,\n        props: {\n          ...field,\n          ...(field?.cellComponentProps || {}),\n        },\n      }\n\n      reduced.push(formattedField)\n      return reduced\n    }\n\n    return reduced\n  }, [])\n}\n"],"names":["getTranslation","createNestedClientFieldPath","combineLabel","fieldTypes","reduceFieldMap","fieldMap","i18n","labelPrefix","pathPrefix","reduce","reduced","field","disableListFilter","type","fieldComponentProps","tabs","forEach","tab","label","localizedTabLabel","labelWithPrefix","tabPathPrefix","name","push","translatedLabel","pathWithPrefix","operatorKeys","Set","operators","acc","operator","has","value","add","operatorKey","t","localizedLabel","formattedLabel","prefix","formattedValue","formattedField","props","cellComponentProps"],"mappings":"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"}
{"version":3,"sources":["../../src/queries/buildSearchParams.ts"],"sourcesContent":["import type { Field, Operator, PathToQuery, Payload } from 'payload'\n\nimport ObjectIdImport from 'bson-objectid'\nimport mongoose from 'mongoose'\nimport { getLocalizedPaths } from 'payload'\nimport { validOperators } from 'payload/shared'\n\nimport type { MongooseAdapter } from '../index.js'\n\nimport { operatorMap } from './operatorMap.js'\nimport { sanitizeQueryValue } from './sanitizeQueryValue.js'\n\nconst ObjectId = (ObjectIdImport.default ||\n  ObjectIdImport) as unknown as typeof ObjectIdImport.default\n\ntype SearchParam = {\n  path?: string\n  rawQuery?: unknown\n  value?: unknown\n}\n\nconst subQueryOptions = {\n  lean: true,\n  limit: 50,\n}\n\n/**\n * Convert the Payload key / value / operator into a MongoDB query\n */\nexport async function buildSearchParam({\n  collectionSlug,\n  fields,\n  globalSlug,\n  incomingPath,\n  locale,\n  operator,\n  payload,\n  val,\n}: {\n  collectionSlug?: string\n  fields: Field[]\n  globalSlug?: string\n  incomingPath: string\n  locale?: string\n  operator: string\n  payload: Payload\n  val: unknown\n}): Promise<SearchParam> {\n  // Replace GraphQL nested field double underscore formatting\n  let sanitizedPath = incomingPath.replace(/__/g, '.')\n  if (sanitizedPath === 'id') sanitizedPath = '_id'\n\n  let paths: PathToQuery[] = []\n\n  let hasCustomID = false\n\n  if (sanitizedPath === '_id') {\n    const customIDFieldType = payload.collections[collectionSlug]?.customIDType\n\n    let idFieldType: 'number' | 'text' = 'text'\n\n    if (customIDFieldType) {\n      idFieldType = customIDFieldType\n      hasCustomID = true\n    }\n\n    paths.push({\n      collectionSlug,\n      complete: true,\n      field: {\n        name: 'id',\n        type: idFieldType,\n      } as Field,\n      path: '_id',\n    })\n  } else {\n    paths = await getLocalizedPaths({\n      collectionSlug,\n      fields,\n      globalSlug,\n      incomingPath: sanitizedPath,\n      locale,\n      payload,\n    })\n  }\n\n  const [{ field, path }] = paths\n\n  if (path) {\n    const {\n      operator: formattedOperator,\n      rawQuery,\n      val: formattedValue,\n    } = sanitizeQueryValue({\n      field,\n      hasCustomID,\n      operator,\n      path,\n      val,\n    })\n\n    if (rawQuery) return { value: rawQuery }\n\n    // If there are multiple collections to search through,\n    // Recursively build up a list of query constraints\n    if (paths.length > 1) {\n      // Remove top collection and reverse array\n      // to work backwards from top\n      const pathsToQuery = paths.slice(1).reverse()\n\n      const initialRelationshipQuery = {\n        value: {},\n      } as SearchParam\n\n      const relationshipQuery = await pathsToQuery.reduce(\n        async (priorQuery, { collectionSlug: slug, path: subPath }, i) => {\n          const priorQueryResult = await priorQuery\n\n          const SubModel = (payload.db as MongooseAdapter).collections[slug]\n\n          // On the \"deepest\" collection,\n          // Search on the value passed through the query\n          if (i === 0) {\n            const subQuery = await SubModel.buildQuery({\n              locale,\n              payload,\n              where: {\n                [subPath]: {\n                  [formattedOperator]: val,\n                },\n              },\n            })\n\n            const result = await SubModel.find(subQuery, subQueryOptions)\n\n            const $in: unknown[] = []\n\n            result.forEach((doc) => {\n              const stringID = doc._id.toString()\n              $in.push(stringID)\n\n              if (mongoose.Types.ObjectId.isValid(stringID)) {\n                $in.push(doc._id)\n              }\n            })\n\n            if (pathsToQuery.length === 1) {\n              return {\n                path,\n                value: { $in },\n              }\n            }\n\n            const nextSubPath = pathsToQuery[i + 1].path\n\n            return {\n              value: { [nextSubPath]: { $in } },\n            }\n          }\n\n          const subQuery = priorQueryResult.value\n          const result = await SubModel.find(subQuery, subQueryOptions)\n\n          const $in = result.map((doc) => doc._id.toString())\n\n          // If it is the last recursion\n          // then pass through the search param\n          if (i + 1 === pathsToQuery.length) {\n            return {\n              path,\n              value: { $in },\n            }\n          }\n\n          return {\n            value: {\n              _id: { $in },\n            },\n          }\n        },\n        Promise.resolve(initialRelationshipQuery),\n      )\n\n      return relationshipQuery\n    }\n\n    if (formattedOperator && validOperators.includes(formattedOperator as Operator)) {\n      const operatorKey = operatorMap[formattedOperator]\n\n      if (field.type === 'relationship' || field.type === 'upload') {\n        let hasNumberIDRelation\n        let multiIDCondition = '$or'\n        if (operatorKey === '$ne') multiIDCondition = '$and'\n\n        const result = {\n          value: {\n            [multiIDCondition]: [{ [path]: { [operatorKey]: formattedValue } }],\n          },\n        }\n\n        if (typeof formattedValue === 'string') {\n          if (mongoose.Types.ObjectId.isValid(formattedValue)) {\n            result.value[multiIDCondition].push({\n              [path]: { [operatorKey]: ObjectId(formattedValue) },\n            })\n          } else {\n            ;(Array.isArray(field.relationTo) ? field.relationTo : [field.relationTo]).forEach(\n              (relationTo) => {\n                const isRelatedToCustomNumberID =\n                  payload.collections[relationTo]?.customIDType === 'number'\n\n                if (isRelatedToCustomNumberID) {\n                  hasNumberIDRelation = true\n                }\n              },\n            )\n\n            if (hasNumberIDRelation)\n              result.value[multiIDCondition].push({\n                [path]: { [operatorKey]: parseFloat(formattedValue) },\n              })\n          }\n        }\n\n        if (result.value[multiIDCondition].length > 1) {\n          return result\n        }\n      }\n\n      if (formattedOperator === 'like' && typeof formattedValue === 'string') {\n        const words = formattedValue.split(' ')\n\n        const result = {\n          value: {\n            $and: words.map((word) => ({\n              [path]: {\n                $options: 'i',\n                $regex: word.replace(/[\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'),\n              },\n            })),\n          },\n        }\n\n        return result\n      }\n\n      // Some operators like 'near' need to define a full query\n      // so if there is no operator key, just return the value\n      if (!operatorKey) {\n        return {\n          path,\n          value: formattedValue,\n        }\n      }\n\n      return {\n        path,\n        value: { [operatorKey]: formattedValue },\n      }\n    }\n  }\n  return undefined\n}\n"],"names":["ObjectIdImport","mongoose","getLocalizedPaths","validOperators","operatorMap","sanitizeQueryValue","ObjectId","default","subQueryOptions","lean","limit","buildSearchParam","collectionSlug","fields","globalSlug","incomingPath","locale","operator","payload","val","sanitizedPath","replace","paths","hasCustomID","customIDFieldType","collections","customIDType","idFieldType","push","complete","field","name","type","path","formattedOperator","rawQuery","formattedValue","value","length","pathsToQuery","slice","reverse","initialRelationshipQuery","relationshipQuery","reduce","priorQuery","slug","subPath","i","priorQueryResult","SubModel","db","subQuery","buildQuery","where","result","find","$in","forEach","doc","stringID","_id","toString","Types","isValid","nextSubPath","map","Promise","resolve","includes","operatorKey","hasNumberIDRelation","multiIDCondition","Array","isArray","relationTo","isRelatedToCustomNumberID","parseFloat","words","split","$and","word","$options","$regex","undefined"],"mappings":"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"}
{"version":3,"sources":["../../src/utilities/configToJSONSchema.ts"],"sourcesContent":["import type { JSONSchema4, JSONSchema4TypeName } from 'json-schema'\n\nimport pluralize from 'pluralize'\nconst { singular } = pluralize\n\nimport type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { Field, FieldAffectingData, Option } from '../fields/config/types.js'\nimport type { SanitizedGlobalConfig } from '../globals/config/types.js'\n\nimport { MissingEditorProp } from '../errors/MissingEditorProp.js'\nimport { fieldAffectsData, tabHasName } from '../fields/config/types.js'\nimport { deepCopyObject } from './deepCopyObject.js'\nimport { toWords } from './formatLabels.js'\nimport { getCollectionIDFieldTypes } from './getCollectionIDFieldTypes.js'\n\nconst fieldIsRequired = (field: Field) => {\n  const isConditional = Boolean(field?.admin && field?.admin?.condition)\n  if (isConditional) return false\n\n  const isMarkedRequired = 'required' in field && field.required === true\n  if (fieldAffectsData(field) && isMarkedRequired) return true\n\n  // if any subfields are required, this field is required\n  if ('fields' in field && field.type !== 'array') {\n    return field.fields.some((subField) => fieldIsRequired(subField))\n  }\n\n  // if any tab subfields have required fields, this field is required\n  if (field.type === 'tabs') {\n    return field.tabs.some((tab) => {\n      if ('name' in tab) {\n        return tab.fields.some((subField) => fieldIsRequired(subField))\n      }\n      return false\n    })\n  }\n\n  return false\n}\n\nfunction buildOptionEnums(options: Option[]): string[] {\n  return options.map((option) => {\n    if (typeof option === 'object' && 'value' in option) {\n      return option.value\n    }\n\n    return option\n  })\n}\n\nfunction generateEntitySchemas(\n  entities: (SanitizedCollectionConfig | SanitizedGlobalConfig)[],\n): JSONSchema4 {\n  const properties = [...entities].reduce((acc, { slug }) => {\n    acc[slug] = {\n      $ref: `#/definitions/${slug}`,\n    }\n\n    return acc\n  }, {})\n\n  return {\n    type: 'object',\n    additionalProperties: false,\n    properties,\n    required: Object.keys(properties),\n  }\n}\n\nfunction generateLocaleEntitySchemas(localization: SanitizedConfig['localization']): JSONSchema4 {\n  if (localization && 'locales' in localization && localization?.locales) {\n    const localesFromConfig = localization?.locales\n\n    const locales = [...localesFromConfig].map((locale) => {\n      return locale.code\n    }, [])\n\n    return {\n      type: 'string',\n      enum: locales,\n    }\n  }\n\n  return {\n    type: 'null',\n  }\n}\n\nfunction generateAuthEntitySchemas(entities: SanitizedCollectionConfig[]): JSONSchema4 {\n  const properties: JSONSchema4[] = [...entities]\n    .filter(({ auth }) => Boolean(auth))\n    .map(({ slug }) => {\n      return {\n        allOf: [\n          { $ref: `#/definitions/${slug}` },\n          {\n            type: 'object',\n            additionalProperties: false,\n            properties: {\n              collection: { type: 'string', enum: [slug] },\n            },\n            required: ['collection'],\n          },\n        ],\n      }\n    }, {})\n\n  return {\n    oneOf: properties,\n  }\n}\n\n/**\n * Returns a JSON Schema Type with 'null' added if the field is not required.\n */\nexport function withNullableJSONSchemaType(\n  fieldType: JSONSchema4TypeName,\n  isRequired: boolean,\n): JSONSchema4TypeName | JSONSchema4TypeName[] {\n  const fieldTypes = [fieldType]\n  if (isRequired) return fieldType\n  fieldTypes.push('null')\n  return fieldTypes\n}\n\nexport function fieldsToJSONSchema(\n  /**\n   * Used for relationship fields, to determine whether to use a string or number type for the ID.\n   * While there is a default ID field type set by the db adapter, they can differ on a collection-level\n   * if they have custom ID fields.\n   */\n  collectionIDFieldTypes: { [key: string]: 'number' | 'string' },\n  fields: Field[],\n  /**\n   * Allows you to define new top-level interfaces that can be re-used in the output schema.\n   */\n  interfaceNameDefinitions: Map<string, JSONSchema4>,\n  config?: SanitizedConfig,\n): {\n  properties: {\n    [k: string]: JSONSchema4\n  }\n  required: string[]\n} {\n  const requiredFieldNames = new Set<string>()\n\n  return {\n    properties: Object.fromEntries(\n      fields.reduce((fieldSchemas, field) => {\n        const isRequired = fieldAffectsData(field) && fieldIsRequired(field)\n        if (isRequired) requiredFieldNames.add(field.name)\n\n        let fieldSchema: JSONSchema4\n\n        switch (field.type) {\n          case 'text':\n            if (field.hasMany === true) {\n              fieldSchema = {\n                type: withNullableJSONSchemaType('array', isRequired),\n                items: { type: 'string' },\n              }\n            } else {\n              fieldSchema = { type: withNullableJSONSchemaType('string', isRequired) }\n            }\n            break\n          case 'textarea':\n          case 'code':\n          case 'email':\n          case 'date': {\n            fieldSchema = { type: withNullableJSONSchemaType('string', isRequired) }\n            break\n          }\n\n          case 'number': {\n            if (field.hasMany === true) {\n              fieldSchema = {\n                type: withNullableJSONSchemaType('array', isRequired),\n                items: { type: 'number' },\n              }\n            } else {\n              fieldSchema = { type: withNullableJSONSchemaType('number', isRequired) }\n            }\n            break\n          }\n\n          case 'checkbox': {\n            fieldSchema = { type: withNullableJSONSchemaType('boolean', isRequired) }\n            break\n          }\n\n          case 'json': {\n            fieldSchema = field.jsonSchema?.schema || {\n              type: ['object', 'array', 'string', 'number', 'boolean', 'null'],\n            }\n            break\n          }\n\n          case 'richText': {\n            if (!field?.editor) {\n              throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n            }\n            if (typeof field.editor === 'function') {\n              throw new Error('Attempted to access unsanitized rich text editor.')\n            }\n            if (field.editor.outputSchema) {\n              fieldSchema = field.editor.outputSchema({\n                collectionIDFieldTypes,\n                config,\n                field,\n                interfaceNameDefinitions,\n                isRequired,\n              })\n            } else {\n              // Maintain backwards compatibility with existing rich text editors\n              fieldSchema = {\n                type: withNullableJSONSchemaType('array', isRequired),\n                items: {\n                  type: 'object',\n                },\n              }\n            }\n\n            break\n          }\n\n          case 'radio': {\n            fieldSchema = {\n              type: withNullableJSONSchemaType('string', isRequired),\n              enum: buildOptionEnums(field.options),\n            }\n\n            break\n          }\n\n          case 'select': {\n            const optionEnums = buildOptionEnums(field.options)\n\n            if (field.hasMany) {\n              fieldSchema = {\n                type: withNullableJSONSchemaType('array', isRequired),\n                items: {\n                  type: 'string',\n                  enum: optionEnums,\n                },\n              }\n            } else {\n              fieldSchema = {\n                type: withNullableJSONSchemaType('string', isRequired),\n                enum: optionEnums,\n              }\n            }\n\n            break\n          }\n\n          case 'point': {\n            fieldSchema = {\n              type: withNullableJSONSchemaType('array', isRequired),\n              items: [\n                {\n                  type: 'number',\n                },\n                {\n                  type: 'number',\n                },\n              ],\n              maxItems: 2,\n              minItems: 2,\n            }\n            break\n          }\n\n          case 'relationship': {\n            if (Array.isArray(field.relationTo)) {\n              if (field.hasMany) {\n                fieldSchema = {\n                  type: withNullableJSONSchemaType('array', isRequired),\n                  items: {\n                    oneOf: field.relationTo.map((relation) => {\n                      return {\n                        type: 'object',\n                        additionalProperties: false,\n                        properties: {\n                          relationTo: {\n                            const: relation,\n                          },\n                          value: {\n                            oneOf: [\n                              {\n                                type: collectionIDFieldTypes[relation],\n                              },\n                              {\n                                $ref: `#/definitions/${relation}`,\n                              },\n                            ],\n                          },\n                        },\n                        required: ['value', 'relationTo'],\n                      }\n                    }),\n                  },\n                }\n              } else {\n                fieldSchema = {\n                  oneOf: field.relationTo.map((relation) => {\n                    return {\n                      type: withNullableJSONSchemaType('object', isRequired),\n                      additionalProperties: false,\n                      properties: {\n                        relationTo: {\n                          const: relation,\n                        },\n                        value: {\n                          oneOf: [\n                            {\n                              type: collectionIDFieldTypes[relation],\n                            },\n                            {\n                              $ref: `#/definitions/${relation}`,\n                            },\n                          ],\n                        },\n                      },\n                      required: ['value', 'relationTo'],\n                    }\n                  }),\n                }\n              }\n            } else if (field.hasMany) {\n              fieldSchema = {\n                type: withNullableJSONSchemaType('array', isRequired),\n                items: {\n                  oneOf: [\n                    {\n                      type: collectionIDFieldTypes[field.relationTo],\n                    },\n                    {\n                      $ref: `#/definitions/${field.relationTo}`,\n                    },\n                  ],\n                },\n              }\n            } else {\n              fieldSchema = {\n                oneOf: [\n                  {\n                    type: withNullableJSONSchemaType(\n                      collectionIDFieldTypes[field.relationTo],\n                      isRequired,\n                    ),\n                  },\n                  {\n                    $ref: `#/definitions/${field.relationTo}`,\n                  },\n                ],\n              }\n            }\n\n            break\n          }\n\n          case 'upload': {\n            fieldSchema = {\n              oneOf: [\n                {\n                  type: collectionIDFieldTypes[field.relationTo],\n                },\n                {\n                  $ref: `#/definitions/${field.relationTo}`,\n                },\n              ],\n            }\n            if (!isRequired) fieldSchema.oneOf.push({ type: 'null' })\n            break\n          }\n\n          case 'blocks': {\n            fieldSchema = {\n              type: withNullableJSONSchemaType('array', isRequired),\n              items: {\n                oneOf: field.blocks.map((block) => {\n                  const blockFieldSchemas = fieldsToJSONSchema(\n                    collectionIDFieldTypes,\n                    block.fields,\n                    interfaceNameDefinitions,\n                    config,\n                  )\n\n                  const blockSchema: JSONSchema4 = {\n                    type: 'object',\n                    additionalProperties: false,\n                    properties: {\n                      ...blockFieldSchemas.properties,\n                      blockType: {\n                        const: block.slug,\n                      },\n                    },\n                    required: ['blockType', ...blockFieldSchemas.required],\n                  }\n\n                  if (block.interfaceName) {\n                    interfaceNameDefinitions.set(block.interfaceName, blockSchema)\n\n                    return {\n                      $ref: `#/definitions/${block.interfaceName}`,\n                    }\n                  }\n\n                  return blockSchema\n                }),\n              },\n            }\n            break\n          }\n\n          case 'array': {\n            fieldSchema = {\n              type: withNullableJSONSchemaType('array', isRequired),\n              items: {\n                type: 'object',\n                additionalProperties: false,\n                ...fieldsToJSONSchema(\n                  collectionIDFieldTypes,\n                  field.fields,\n                  interfaceNameDefinitions,\n                  config,\n                ),\n              },\n            }\n\n            if (field.interfaceName) {\n              interfaceNameDefinitions.set(field.interfaceName, fieldSchema)\n\n              fieldSchema = {\n                $ref: `#/definitions/${field.interfaceName}`,\n              }\n            }\n            break\n          }\n\n          case 'row':\n          case 'collapsible': {\n            const childSchema = fieldsToJSONSchema(\n              collectionIDFieldTypes,\n              field.fields,\n              interfaceNameDefinitions,\n              config,\n            )\n            Object.entries(childSchema.properties).forEach(([propName, propSchema]) => {\n              fieldSchemas.set(propName, propSchema)\n            })\n            childSchema.required.forEach((propName) => {\n              requiredFieldNames.add(propName)\n            })\n            break\n          }\n\n          case 'tabs': {\n            field.tabs.forEach((tab) => {\n              const childSchema = fieldsToJSONSchema(\n                collectionIDFieldTypes,\n                tab.fields,\n                interfaceNameDefinitions,\n                config,\n              )\n              if (tabHasName(tab)) {\n                // could have interface\n                fieldSchemas.set(tab.name, {\n                  type: 'object',\n                  additionalProperties: false,\n                  ...childSchema,\n                })\n\n                // If the named tab has any required fields then we mark this as required otherwise it should be optional\n                const hasRequiredFields = tab.fields.some((subField) => fieldIsRequired(subField))\n\n                if (hasRequiredFields) {\n                  requiredFieldNames.add(tab.name)\n                }\n              } else {\n                Object.entries(childSchema.properties).forEach(([propName, propSchema]) => {\n                  fieldSchemas.set(propName, propSchema)\n                })\n                childSchema.required.forEach((propName) => {\n                  requiredFieldNames.add(propName)\n                })\n              }\n            })\n            break\n          }\n\n          case 'group': {\n            fieldSchema = {\n              type: 'object',\n              additionalProperties: false,\n              ...fieldsToJSONSchema(\n                collectionIDFieldTypes,\n                field.fields,\n                interfaceNameDefinitions,\n                config,\n              ),\n            }\n\n            if (field.interfaceName) {\n              interfaceNameDefinitions.set(field.interfaceName, fieldSchema)\n\n              fieldSchema = {\n                $ref: `#/definitions/${field.interfaceName}`,\n              }\n            }\n            break\n          }\n\n          default: {\n            break\n          }\n        }\n\n        if ('typescriptSchema' in field && field?.typescriptSchema?.length) {\n          for (const schema of field.typescriptSchema) {\n            fieldSchema = schema({ jsonSchema: fieldSchema })\n          }\n        }\n\n        if (fieldSchema && fieldAffectsData(field)) {\n          fieldSchemas.set(field.name, fieldSchema)\n        }\n\n        return fieldSchemas\n      }, new Map<string, JSONSchema4>()),\n    ),\n    required: Array.from(requiredFieldNames),\n  }\n}\n\n// This function is part of the public API and is exported through payload/utilities\nexport function entityToJSONSchema(\n  config: SanitizedConfig,\n  incomingEntity: SanitizedCollectionConfig | SanitizedGlobalConfig,\n  interfaceNameDefinitions: Map<string, JSONSchema4>,\n  defaultIDType: 'number' | 'text',\n): JSONSchema4 {\n  const entity: SanitizedCollectionConfig | SanitizedGlobalConfig = deepCopyObject(incomingEntity)\n  const title = entity.typescript?.interface\n    ? entity.typescript.interface\n    : singular(toWords(entity.slug, true))\n\n  const idField: FieldAffectingData = { name: 'id', type: defaultIDType as 'text', required: true }\n  const customIdField = entity.fields.find(\n    (field) => fieldAffectsData(field) && field.name === 'id',\n  ) as FieldAffectingData\n\n  if (customIdField && customIdField.type !== 'group' && customIdField.type !== 'tab') {\n    customIdField.required = true\n  } else {\n    entity.fields.unshift(idField)\n  }\n\n  // mark timestamp fields required\n  if ('timestamps' in entity && entity.timestamps !== false) {\n    entity.fields = entity.fields.map((field) => {\n      if (fieldAffectsData(field) && (field.name === 'createdAt' || field.name === 'updatedAt')) {\n        return {\n          ...field,\n          required: true,\n        }\n      }\n      return field\n    })\n  }\n\n  if ('auth' in entity && entity.auth && !entity.auth?.disableLocalStrategy) {\n    entity.fields.push({\n      name: 'password',\n      type: 'text',\n    })\n  }\n\n  //  Used for relationship fields, to determine whether to use a string or number type for the ID.\n  const collectionIDFieldTypes = getCollectionIDFieldTypes({ config, defaultIDType })\n\n  return {\n    type: 'object',\n    additionalProperties: false,\n    title,\n    ...fieldsToJSONSchema(collectionIDFieldTypes, entity.fields, interfaceNameDefinitions, config),\n  }\n}\n\nfunction generateOperationJSONSchema(\n  config: SanitizedCollectionConfig,\n  operation: 'forgotPassword' | 'login' | 'registerFirstUser',\n): JSONSchema4 {\n  const usernameLogin = config.auth?.loginWithUsername\n  const fieldType: JSONSchema4 = {\n    type: 'string',\n  }\n\n  let properties: JSONSchema4['properties'] = {}\n  switch (operation) {\n    case 'login': {\n      properties = {\n        password: fieldType,\n        [usernameLogin ? 'username' : 'email']: fieldType,\n      }\n      break\n    }\n    case 'forgotPassword': {\n      properties = {\n        [usernameLogin ? 'username' : 'email']: fieldType,\n      }\n      break\n    }\n    case 'registerFirstUser': {\n      properties = {\n        email: fieldType,\n        password: fieldType,\n      }\n      if (usernameLogin) properties.username = fieldType\n      break\n    }\n  }\n\n  return {\n    additionalProperties: false,\n    properties,\n    required: Object.keys(properties),\n  }\n}\n\nexport function authCollectionToOperationsJSONSchema(\n  config: SanitizedCollectionConfig,\n): JSONSchema4 {\n  const properties = {\n    forgotPassword: {\n      ...generateOperationJSONSchema(config, 'forgotPassword'),\n    },\n    login: {\n      ...generateOperationJSONSchema(config, 'login'),\n    },\n    registerFirstUser: {\n      ...generateOperationJSONSchema(config, 'registerFirstUser'),\n    },\n  }\n\n  return {\n    type: 'object',\n    additionalProperties: false,\n    properties,\n    required: Object.keys(properties),\n    title: `${singular(toWords(`${config.slug}`, true))}AuthOperations`,\n  }\n}\n\nfunction generateAuthOperationSchemas(collections: SanitizedCollectionConfig[]): JSONSchema4 {\n  const properties = collections.reduce((acc, collection) => {\n    if (collection.auth) {\n      acc[collection.slug] = {\n        $ref: `#/definitions/auth/${collection.slug}`,\n      }\n    }\n    return acc\n  }, {})\n\n  return {\n    type: 'object',\n    additionalProperties: false,\n    properties,\n    required: Object.keys(properties),\n  }\n}\n\n/**\n * This is used for generating the TypeScript types (payload-types.ts) with the payload generate:types command.\n */\nexport function configToJSONSchema(\n  config: SanitizedConfig,\n  defaultIDType?: 'number' | 'text',\n): JSONSchema4 {\n  // a mutable Map to store custom top-level `interfaceName` types. Fields with an `interfaceName` property will be moved to the top-level definitions here\n  const interfaceNameDefinitions: Map<string, JSONSchema4> = new Map()\n\n  // Collections and Globals have to be moved to the top-level definitions as well. Reason: The top-level type will be the `Config` type - we don't want all collection and global\n  // types to be inlined inside the `Config` type\n  const entityDefinitions: { [k: string]: JSONSchema4 } = [\n    ...config.globals,\n    ...config.collections,\n  ].reduce((acc, entity) => {\n    acc[entity.slug] = entityToJSONSchema(config, entity, interfaceNameDefinitions, defaultIDType)\n    return acc\n  }, {})\n\n  const authOperationDefinitions = [...config.collections]\n    .filter(({ auth }) => Boolean(auth))\n    .reduce(\n      (acc, authCollection) => {\n        acc.auth[authCollection.slug] = authCollectionToOperationsJSONSchema(authCollection)\n        return acc\n      },\n      { auth: {} },\n    )\n\n  let jsonSchema: JSONSchema4 = {\n    additionalProperties: false,\n    definitions: {\n      ...entityDefinitions,\n      ...Object.fromEntries(interfaceNameDefinitions),\n      ...authOperationDefinitions,\n    },\n    // These properties here will be very simple, as all the complexity is in the definitions. These are just the properties for the top-level `Config` type\n    type: 'object',\n    properties: {\n      auth: generateAuthOperationSchemas(config.collections),\n      collections: generateEntitySchemas(config.collections || []),\n      globals: generateEntitySchemas(config.globals || []),\n      locale: generateLocaleEntitySchemas(config.localization),\n      user: generateAuthEntitySchemas(config.collections),\n    },\n    required: ['user', 'locale', 'collections', 'globals', 'auth'],\n    title: 'Config',\n  }\n\n  if (config?.typescript?.schema?.length) {\n    for (const schema of config.typescript.schema) {\n      jsonSchema = schema({ jsonSchema })\n    }\n  }\n\n  return jsonSchema\n}\n"],"names":["pluralize","singular","MissingEditorProp","fieldAffectsData","tabHasName","deepCopyObject","toWords","getCollectionIDFieldTypes","fieldIsRequired","field","isConditional","Boolean","admin","condition","isMarkedRequired","required","type","fields","some","subField","tabs","tab","buildOptionEnums","options","map","option","value","generateEntitySchemas","entities","properties","reduce","acc","slug","$ref","additionalProperties","Object","keys","generateLocaleEntitySchemas","localization","locales","localesFromConfig","locale","code","enum","generateAuthEntitySchemas","filter","auth","allOf","collection","oneOf","withNullableJSONSchemaType","fieldType","isRequired","fieldTypes","push","fieldsToJSONSchema","collectionIDFieldTypes","interfaceNameDefinitions","config","requiredFieldNames","Set","fromEntries","fieldSchemas","add","name","fieldSchema","hasMany","items","jsonSchema","schema","editor","Error","outputSchema","optionEnums","maxItems","minItems","Array","isArray","relationTo","relation","const","blocks","block","blockFieldSchemas","blockSchema","blockType","interfaceName","set","childSchema","entries","forEach","propName","propSchema","hasRequiredFields","typescriptSchema","length","Map","from","entityToJSONSchema","incomingEntity","defaultIDType","entity","title","typescript","interface","idField","customIdField","find","unshift","timestamps","disableLocalStrategy","generateOperationJSONSchema","operation","usernameLogin","loginWithUsername","password","email","username","authCollectionToOperationsJSONSchema","forgotPassword","login","registerFirstUser","generateAuthOperationSchemas","collections","configToJSONSchema","entityDefinitions","globals","authOperationDefinitions","authCollection","definitions","user"],"mappings":"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"}
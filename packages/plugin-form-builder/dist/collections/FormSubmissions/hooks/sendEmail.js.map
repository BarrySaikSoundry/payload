{"version":3,"sources":["../../../../src/collections/FormSubmissions/hooks/sendEmail.ts"],"sourcesContent":["import type { Email, FormBuilderPluginConfig, FormattedEmail } from '../../../types.js'\n\nimport { serializeLexical } from '../../../utilities/lexical/serializeLexical.js'\nimport { replaceDoubleCurlys } from '../../../utilities/replaceDoubleCurlys.js'\nimport { serializeSlate } from '../../../utilities/slate/serializeSlate.js'\n\nexport const sendEmail = async (\n  beforeChangeData: any,\n  formConfig: FormBuilderPluginConfig,\n): Promise<any> => {\n  const { data, operation, req } = beforeChangeData\n\n  if (operation === 'create') {\n    const {\n      data: { id: formSubmissionID },\n      req: { locale, payload },\n    } = beforeChangeData\n\n    const { form: formID, submissionData } = data || {}\n\n    const { beforeEmail, formOverrides } = formConfig || {}\n\n    try {\n      const form = await payload.findByID({\n        id: formID,\n        collection: formOverrides?.slug || 'forms',\n        locale,\n        req,\n      })\n\n      const { emails } = form\n\n      if (emails && emails.length) {\n        const formattedEmails: FormattedEmail[] = await Promise.all(\n          emails.map(async (email: Email): Promise<FormattedEmail | null> => {\n            const {\n              bcc: emailBCC,\n              cc: emailCC,\n              emailFrom,\n              emailTo,\n              message,\n              replyTo: emailReplyTo,\n              subject,\n            } = email\n\n            const to = replaceDoubleCurlys(emailTo, submissionData)\n            const cc = emailCC ? replaceDoubleCurlys(emailCC, submissionData) : ''\n            const bcc = emailBCC ? replaceDoubleCurlys(emailBCC, submissionData) : ''\n            const from = replaceDoubleCurlys(emailFrom, submissionData)\n            const replyTo = replaceDoubleCurlys(emailReplyTo || emailFrom, submissionData)\n\n            const isLexical = message && !Array.isArray(message) && 'root' in message\n\n            const serializedMessage = isLexical\n              ? await serializeLexical(message, submissionData)\n              : serializeSlate(message, submissionData)\n\n            return {\n              bcc,\n              cc,\n              from,\n              html: `<div>${serializedMessage}</div>`,\n              replyTo,\n              subject: replaceDoubleCurlys(subject, submissionData),\n              to,\n            }\n          }),\n        )\n\n        let emailsToSend = formattedEmails\n\n        if (typeof beforeEmail === 'function') {\n          emailsToSend = await beforeEmail(formattedEmails)\n        }\n\n        // const log = emailsToSend.map(({ html, ...rest }) => ({ ...rest }))\n\n        await Promise.all(\n          emailsToSend.map(async (email) => {\n            const { to } = email\n            try {\n              const emailPromise = await payload.sendEmail(email)\n              return emailPromise\n            } catch (err: unknown) {\n              payload.logger.error({\n                err: `Error while sending email to address: ${to}. Email not sent: ${JSON.stringify(\n                  err,\n                )}`,\n              })\n            }\n          }),\n        )\n      } else {\n        payload.logger.info({ msg: 'No emails to send.' })\n      }\n    } catch (err: unknown) {\n      const msg = `Error while sending one or more emails in form submission id: ${formSubmissionID}.`\n      payload.logger.error({ err: msg })\n    }\n  }\n\n  return data\n}\n"],"names":["serializeLexical","replaceDoubleCurlys","serializeSlate","sendEmail","beforeChangeData","formConfig","data","operation","req","id","formSubmissionID","locale","payload","form","formID","submissionData","beforeEmail","formOverrides","findByID","collection","slug","emails","length","formattedEmails","Promise","all","map","email","bcc","emailBCC","cc","emailCC","emailFrom","emailTo","message","replyTo","emailReplyTo","subject","to","from","isLexical","Array","isArray","serializedMessage","html","emailsToSend","emailPromise","err","logger","error","JSON","stringify","info","msg"],"mappings":"AAEA,SAASA,gBAAgB,QAAQ,iDAAgD;AACjF,SAASC,mBAAmB,QAAQ,4CAA2C;AAC/E,SAASC,cAAc,QAAQ,6CAA4C;AAE3E,OAAO,MAAMC,YAAY,OACvBC,kBACAC;IAEA,MAAM,EAAEC,IAAI,EAAEC,SAAS,EAAEC,GAAG,EAAE,GAAGJ;IAEjC,IAAIG,cAAc,UAAU;QAC1B,MAAM,EACJD,MAAM,EAAEG,IAAIC,gBAAgB,EAAE,EAC9BF,KAAK,EAAEG,MAAM,EAAEC,OAAO,EAAE,EACzB,GAAGR;QAEJ,MAAM,EAAES,MAAMC,MAAM,EAAEC,cAAc,EAAE,GAAGT,QAAQ,CAAC;QAElD,MAAM,EAAEU,WAAW,EAAEC,aAAa,EAAE,GAAGZ,cAAc,CAAC;QAEtD,IAAI;YACF,MAAMQ,OAAO,MAAMD,QAAQM,QAAQ,CAAC;gBAClCT,IAAIK;gBACJK,YAAYF,eAAeG,QAAQ;gBACnCT;gBACAH;YACF;YAEA,MAAM,EAAEa,MAAM,EAAE,GAAGR;YAEnB,IAAIQ,UAAUA,OAAOC,MAAM,EAAE;gBAC3B,MAAMC,kBAAoC,MAAMC,QAAQC,GAAG,CACzDJ,OAAOK,GAAG,CAAC,OAAOC;oBAChB,MAAM,EACJC,KAAKC,QAAQ,EACbC,IAAIC,OAAO,EACXC,SAAS,EACTC,OAAO,EACPC,OAAO,EACPC,SAASC,YAAY,EACrBC,OAAO,EACR,GAAGV;oBAEJ,MAAMW,KAAKrC,oBAAoBgC,SAASlB;oBACxC,MAAMe,KAAKC,UAAU9B,oBAAoB8B,SAAShB,kBAAkB;oBACpE,MAAMa,MAAMC,WAAW5B,oBAAoB4B,UAAUd,kBAAkB;oBACvE,MAAMwB,OAAOtC,oBAAoB+B,WAAWjB;oBAC5C,MAAMoB,UAAUlC,oBAAoBmC,gBAAgBJ,WAAWjB;oBAE/D,MAAMyB,YAAYN,WAAW,CAACO,MAAMC,OAAO,CAACR,YAAY,UAAUA;oBAElE,MAAMS,oBAAoBH,YACtB,MAAMxC,iBAAiBkC,SAASnB,kBAChCb,eAAegC,SAASnB;oBAE5B,OAAO;wBACLa;wBACAE;wBACAS;wBACAK,MAAM,CAAC,KAAK,EAAED,kBAAkB,MAAM,CAAC;wBACvCR;wBACAE,SAASpC,oBAAoBoC,SAAStB;wBACtCuB;oBACF;gBACF;gBAGF,IAAIO,eAAetB;gBAEnB,IAAI,OAAOP,gBAAgB,YAAY;oBACrC6B,eAAe,MAAM7B,YAAYO;gBACnC;gBAEA,qEAAqE;gBAErE,MAAMC,QAAQC,GAAG,CACfoB,aAAanB,GAAG,CAAC,OAAOC;oBACtB,MAAM,EAAEW,EAAE,EAAE,GAAGX;oBACf,IAAI;wBACF,MAAMmB,eAAe,MAAMlC,QAAQT,SAAS,CAACwB;wBAC7C,OAAOmB;oBACT,EAAE,OAAOC,KAAc;wBACrBnC,QAAQoC,MAAM,CAACC,KAAK,CAAC;4BACnBF,KAAK,CAAC,sCAAsC,EAAET,GAAG,kBAAkB,EAAEY,KAAKC,SAAS,CACjFJ,KACA,CAAC;wBACL;oBACF;gBACF;YAEJ,OAAO;gBACLnC,QAAQoC,MAAM,CAACI,IAAI,CAAC;oBAAEC,KAAK;gBAAqB;YAClD;QACF,EAAE,OAAON,KAAc;YACrB,MAAMM,MAAM,CAAC,8DAA8D,EAAE3C,iBAAiB,CAAC,CAAC;YAChGE,QAAQoC,MAAM,CAACC,KAAK,CAAC;gBAAEF,KAAKM;YAAI;QAClC;IACF;IAEA,OAAO/C;AACT,EAAC"}
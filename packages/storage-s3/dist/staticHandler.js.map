{"version":3,"sources":["../src/staticHandler.ts"],"sourcesContent":["import type * as AWS from '@aws-sdk/client-s3'\nimport type { StaticHandler } from '@payloadcms/plugin-cloud-storage/types'\nimport type { CollectionConfig } from 'payload'\n\nimport { getFilePrefix } from '@payloadcms/plugin-cloud-storage/utilities'\nimport path from 'path'\n\ninterface Args {\n  bucket: string\n  collection: CollectionConfig\n  getStorageClient: () => AWS.S3\n}\n\n// Convert a stream into a promise that resolves with a Buffer\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst streamToBuffer = async (readableStream: any) => {\n  const chunks = []\n  for await (const chunk of readableStream) {\n    chunks.push(typeof chunk === 'string' ? Buffer.from(chunk) : chunk)\n  }\n  return Buffer.concat(chunks)\n}\n\nexport const getHandler = ({ bucket, collection, getStorageClient }: Args): StaticHandler => {\n  return async (req, { params: { filename } }) => {\n    try {\n      const prefix = await getFilePrefix({ collection, filename, req })\n\n      const object = await getStorageClient().getObject({\n        Bucket: bucket,\n        Key: path.posix.join(prefix, filename),\n      })\n\n      if (!object.Body) {\n        return new Response(null, { status: 404, statusText: 'Not Found' })\n      }\n\n      const bodyBuffer = await streamToBuffer(object.Body)\n\n      return new Response(bodyBuffer, {\n        headers: new Headers({\n          'Accept-Ranges': String(object.AcceptRanges),\n          'Content-Length': String(object.ContentLength),\n          'Content-Type': String(object.ContentType),\n          ETag: String(object.ETag),\n        }),\n        status: 200,\n      })\n    } catch (err) {\n      req.payload.logger.error(err)\n      return new Response('Internal Server Error', { status: 500 })\n    }\n  }\n}\n"],"names":["getFilePrefix","path","streamToBuffer","readableStream","chunks","chunk","push","Buffer","from","concat","getHandler","bucket","collection","getStorageClient","req","params","filename","prefix","object","getObject","Bucket","Key","posix","join","Body","Response","status","statusText","bodyBuffer","headers","Headers","String","AcceptRanges","ContentLength","ContentType","ETag","err","payload","logger","error"],"mappings":"AAIA,SAASA,aAAa,QAAQ,6CAA4C;AAC1E,OAAOC,UAAU,OAAM;AAQvB,8DAA8D;AAC9D,8DAA8D;AAC9D,MAAMC,iBAAiB,OAAOC;IAC5B,MAAMC,SAAS,EAAE;IACjB,WAAW,MAAMC,SAASF,eAAgB;QACxCC,OAAOE,IAAI,CAAC,OAAOD,UAAU,WAAWE,OAAOC,IAAI,CAACH,SAASA;IAC/D;IACA,OAAOE,OAAOE,MAAM,CAACL;AACvB;AAEA,OAAO,MAAMM,aAAa,CAAC,EAAEC,MAAM,EAAEC,UAAU,EAAEC,gBAAgB,EAAQ;IACvE,OAAO,OAAOC,KAAK,EAAEC,QAAQ,EAAEC,QAAQ,EAAE,EAAE;QACzC,IAAI;YACF,MAAMC,SAAS,MAAMjB,cAAc;gBAAEY;gBAAYI;gBAAUF;YAAI;YAE/D,MAAMI,SAAS,MAAML,mBAAmBM,SAAS,CAAC;gBAChDC,QAAQT;gBACRU,KAAKpB,KAAKqB,KAAK,CAACC,IAAI,CAACN,QAAQD;YAC/B;YAEA,IAAI,CAACE,OAAOM,IAAI,EAAE;gBAChB,OAAO,IAAIC,SAAS,MAAM;oBAAEC,QAAQ;oBAAKC,YAAY;gBAAY;YACnE;YAEA,MAAMC,aAAa,MAAM1B,eAAegB,OAAOM,IAAI;YAEnD,OAAO,IAAIC,SAASG,YAAY;gBAC9BC,SAAS,IAAIC,QAAQ;oBACnB,iBAAiBC,OAAOb,OAAOc,YAAY;oBAC3C,kBAAkBD,OAAOb,OAAOe,aAAa;oBAC7C,gBAAgBF,OAAOb,OAAOgB,WAAW;oBACzCC,MAAMJ,OAAOb,OAAOiB,IAAI;gBAC1B;gBACAT,QAAQ;YACV;QACF,EAAE,OAAOU,KAAK;YACZtB,IAAIuB,OAAO,CAACC,MAAM,CAACC,KAAK,CAACH;YACzB,OAAO,IAAIX,SAAS,yBAAyB;gBAAEC,QAAQ;YAAI;QAC7D;IACF;AACF,EAAC"}
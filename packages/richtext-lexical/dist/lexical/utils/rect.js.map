{"version":3,"sources":["../../../src/lexical/utils/rect.ts"],"sourcesContent":["import { type Point, isPoint } from './point.js'\n\ninterface ContainsPointReturn {\n  reason: {\n    isOnBottomSide: boolean\n    isOnLeftSide: boolean\n    isOnRightSide: boolean\n    isOnTopSide: boolean\n  }\n  result: boolean\n}\n\nexport class Rect {\n  private readonly _bottom: number\n\n  private readonly _left: number\n\n  private readonly _right: number\n\n  private readonly _top: number\n\n  constructor(left: number, top: number, right: number, bottom: number) {\n    const [physicTop, physicBottom] = top <= bottom ? [top, bottom] : [bottom, top]\n\n    const [physicLeft, physicRight] = left <= right ? [left, right] : [right, left]\n\n    this._top = physicTop\n    this._right = physicRight\n    this._left = physicLeft\n    this._bottom = physicBottom\n  }\n\n  static fromDOM(dom: HTMLElement): Rect {\n    const { height, left, top, width } = dom.getBoundingClientRect()\n    return Rect.fromLWTH(left, width, top, height)\n  }\n\n  static fromDOMRect(domRect: DOMRect): Rect {\n    const { height, left, top, width } = domRect\n    return Rect.fromLWTH(left, width, top, height)\n  }\n\n  static fromLTRB(left: number, top: number, right: number, bottom: number): Rect {\n    return new Rect(left, top, right, bottom)\n  }\n\n  static fromLWTH(left: number, width: number, top: number, height: number): Rect {\n    return new Rect(left, top, left + width, top + height)\n  }\n\n  static fromPoints(startPoint: Point, endPoint: Point): Rect {\n    const { x: left, y: top } = startPoint\n    const { x: right, y: bottom } = endPoint\n    return Rect.fromLTRB(left, top, right, bottom)\n  }\n\n  public contains({ x, y }: Point): ContainsPointReturn\n\n  public contains({ bottom, left, right, top }: Rect): boolean\n\n  public contains(target: Point | Rect): ContainsPointReturn | boolean {\n    if (isPoint(target)) {\n      const { x, y } = target\n\n      const isOnTopSide = y < this._top\n      const isOnBottomSide = y > this._bottom\n      const isOnLeftSide = x < this._left\n      const isOnRightSide = x > this._right\n\n      const result = !isOnTopSide && !isOnBottomSide && !isOnLeftSide && !isOnRightSide\n\n      return {\n        reason: {\n          isOnBottomSide,\n          isOnLeftSide,\n          isOnRightSide,\n          isOnTopSide,\n        },\n        result,\n      }\n    }\n    const { bottom, left, right, top } = target\n\n    return (\n      top >= this._top &&\n      top <= this._bottom &&\n      bottom >= this._top &&\n      bottom <= this._bottom &&\n      left >= this._left &&\n      left <= this._right &&\n      right >= this._left &&\n      right <= this._right\n    )\n  }\n\n  public distanceFromPoint(point: Point): {\n    distance: number\n    isOnBottomSide: boolean\n    isOnLeftSide: boolean\n    isOnRightSide: boolean\n    isOnTopSide: boolean\n  } {\n    const containsResult = this.contains(point)\n    if (containsResult.result) {\n      return {\n        distance: 0,\n        isOnBottomSide: containsResult.reason.isOnBottomSide,\n        isOnLeftSide: containsResult.reason.isOnLeftSide,\n        isOnRightSide: containsResult.reason.isOnRightSide,\n        isOnTopSide: containsResult.reason.isOnTopSide,\n      }\n    }\n\n    let dx = 0 // Horizontal distance to the closest edge\n    let dy = 0 // Vertical distance to the closest edge\n\n    // If the point is to the left of the rectangle\n    if (point.x < this._left) {\n      dx = this._left - point.x\n    }\n    // If the point is to the right of the rectangle\n    else if (point.x > this._right) {\n      dx = point.x - this._right\n    }\n\n    // If the point is above the rectangle\n    if (point.y < this._top) {\n      dy = this._top - point.y\n    }\n    // If the point is below the rectangle\n    else if (point.y > this._bottom) {\n      dy = point.y - this._bottom\n    }\n\n    // Use the Pythagorean theorem to calculate the distance\n    return {\n      distance: Math.sqrt(dx * dx + dy * dy),\n      isOnBottomSide: point.y > this._bottom,\n      isOnLeftSide: point.x < this._left,\n      isOnRightSide: point.x > this._right,\n      isOnTopSide: point.y < this._top,\n    }\n  }\n\n  public equals({ bottom, left, right, top }: Rect): boolean {\n    return (\n      top === this._top && bottom === this._bottom && left === this._left && right === this._right\n    )\n  }\n\n  public generateNewRect({\n    bottom = this.bottom,\n    left = this.left,\n    right = this.right,\n    top = this.top,\n  }): Rect {\n    return new Rect(left, top, right, bottom)\n  }\n\n  public intersectsWith(rect: Rect): boolean {\n    const { height: h1, left: x1, top: y1, width: w1 } = rect\n    const { height: h2, left: x2, top: y2, width: w2 } = this\n    const maxX = x1 + w1 >= x2 + w2 ? x1 + w1 : x2 + w2\n    const maxY = y1 + h1 >= y2 + h2 ? y1 + h1 : y2 + h2\n    const minX = x1 <= x2 ? x1 : x2\n    const minY = y1 <= y2 ? y1 : y2\n    return maxX - minX <= w1 + w2 && maxY - minY <= h1 + h2\n  }\n\n  get bottom(): number {\n    return this._bottom\n  }\n\n  get height(): number {\n    return Math.abs(this._bottom - this._top)\n  }\n\n  get left(): number {\n    return this._left\n  }\n\n  get right(): number {\n    return this._right\n  }\n\n  get top(): number {\n    return this._top\n  }\n\n  get width(): number {\n    return Math.abs(this._left - this._right)\n  }\n}\n"],"names":["isPoint","Rect","_bottom","_left","_right","_top","constructor","left","top","right","bottom","physicTop","physicBottom","physicLeft","physicRight","fromDOM","dom","height","width","getBoundingClientRect","fromLWTH","fromDOMRect","domRect","fromLTRB","fromPoints","startPoint","endPoint","x","y","contains","target","isOnTopSide","isOnBottomSide","isOnLeftSide","isOnRightSide","result","reason","distanceFromPoint","point","containsResult","distance","dx","dy","Math","sqrt","equals","generateNewRect","intersectsWith","rect","h1","x1","y1","w1","h2","x2","y2","w2","maxX","maxY","minX","minY","abs"],"mappings":"AAAA,SAAqBA,OAAO,QAAQ,aAAY;AAYhD,OAAO,MAAMC;IACMC,QAAe;IAEfC,MAAa;IAEbC,OAAc;IAEdC,KAAY;IAE7BC,YAAYC,IAAY,EAAEC,GAAW,EAAEC,KAAa,EAAEC,MAAc,CAAE;QACpE,MAAM,CAACC,WAAWC,aAAa,GAAGJ,OAAOE,SAAS;YAACF;YAAKE;SAAO,GAAG;YAACA;YAAQF;SAAI;QAE/E,MAAM,CAACK,YAAYC,YAAY,GAAGP,QAAQE,QAAQ;YAACF;YAAME;SAAM,GAAG;YAACA;YAAOF;SAAK;QAE/E,IAAI,CAACF,IAAI,GAAGM;QACZ,IAAI,CAACP,MAAM,GAAGU;QACd,IAAI,CAACX,KAAK,GAAGU;QACb,IAAI,CAACX,OAAO,GAAGU;IACjB;IAEA,OAAOG,QAAQC,GAAgB,EAAQ;QACrC,MAAM,EAAEC,MAAM,EAAEV,IAAI,EAAEC,GAAG,EAAEU,KAAK,EAAE,GAAGF,IAAIG,qBAAqB;QAC9D,OAAOlB,KAAKmB,QAAQ,CAACb,MAAMW,OAAOV,KAAKS;IACzC;IAEA,OAAOI,YAAYC,OAAgB,EAAQ;QACzC,MAAM,EAAEL,MAAM,EAAEV,IAAI,EAAEC,GAAG,EAAEU,KAAK,EAAE,GAAGI;QACrC,OAAOrB,KAAKmB,QAAQ,CAACb,MAAMW,OAAOV,KAAKS;IACzC;IAEA,OAAOM,SAAShB,IAAY,EAAEC,GAAW,EAAEC,KAAa,EAAEC,MAAc,EAAQ;QAC9E,OAAO,IAAIT,KAAKM,MAAMC,KAAKC,OAAOC;IACpC;IAEA,OAAOU,SAASb,IAAY,EAAEW,KAAa,EAAEV,GAAW,EAAES,MAAc,EAAQ;QAC9E,OAAO,IAAIhB,KAAKM,MAAMC,KAAKD,OAAOW,OAAOV,MAAMS;IACjD;IAEA,OAAOO,WAAWC,UAAiB,EAAEC,QAAe,EAAQ;QAC1D,MAAM,EAAEC,GAAGpB,IAAI,EAAEqB,GAAGpB,GAAG,EAAE,GAAGiB;QAC5B,MAAM,EAAEE,GAAGlB,KAAK,EAAEmB,GAAGlB,MAAM,EAAE,GAAGgB;QAChC,OAAOzB,KAAKsB,QAAQ,CAAChB,MAAMC,KAAKC,OAAOC;IACzC;IAMOmB,SAASC,MAAoB,EAAiC;QACnE,IAAI9B,QAAQ8B,SAAS;YACnB,MAAM,EAAEH,CAAC,EAAEC,CAAC,EAAE,GAAGE;YAEjB,MAAMC,cAAcH,IAAI,IAAI,CAACvB,IAAI;YACjC,MAAM2B,iBAAiBJ,IAAI,IAAI,CAAC1B,OAAO;YACvC,MAAM+B,eAAeN,IAAI,IAAI,CAACxB,KAAK;YACnC,MAAM+B,gBAAgBP,IAAI,IAAI,CAACvB,MAAM;YAErC,MAAM+B,SAAS,CAACJ,eAAe,CAACC,kBAAkB,CAACC,gBAAgB,CAACC;YAEpE,OAAO;gBACLE,QAAQ;oBACNJ;oBACAC;oBACAC;oBACAH;gBACF;gBACAI;YACF;QACF;QACA,MAAM,EAAEzB,MAAM,EAAEH,IAAI,EAAEE,KAAK,EAAED,GAAG,EAAE,GAAGsB;QAErC,OACEtB,OAAO,IAAI,CAACH,IAAI,IAChBG,OAAO,IAAI,CAACN,OAAO,IACnBQ,UAAU,IAAI,CAACL,IAAI,IACnBK,UAAU,IAAI,CAACR,OAAO,IACtBK,QAAQ,IAAI,CAACJ,KAAK,IAClBI,QAAQ,IAAI,CAACH,MAAM,IACnBK,SAAS,IAAI,CAACN,KAAK,IACnBM,SAAS,IAAI,CAACL,MAAM;IAExB;IAEOiC,kBAAkBC,KAAY,EAMnC;QACA,MAAMC,iBAAiB,IAAI,CAACV,QAAQ,CAACS;QACrC,IAAIC,eAAeJ,MAAM,EAAE;YACzB,OAAO;gBACLK,UAAU;gBACVR,gBAAgBO,eAAeH,MAAM,CAACJ,cAAc;gBACpDC,cAAcM,eAAeH,MAAM,CAACH,YAAY;gBAChDC,eAAeK,eAAeH,MAAM,CAACF,aAAa;gBAClDH,aAAaQ,eAAeH,MAAM,CAACL,WAAW;YAChD;QACF;QAEA,IAAIU,KAAK,EAAE,0CAA0C;;QACrD,IAAIC,KAAK,EAAE,wCAAwC;;QAEnD,+CAA+C;QAC/C,IAAIJ,MAAMX,CAAC,GAAG,IAAI,CAACxB,KAAK,EAAE;YACxBsC,KAAK,IAAI,CAACtC,KAAK,GAAGmC,MAAMX,CAAC;QAC3B,OAEK,IAAIW,MAAMX,CAAC,GAAG,IAAI,CAACvB,MAAM,EAAE;YAC9BqC,KAAKH,MAAMX,CAAC,GAAG,IAAI,CAACvB,MAAM;QAC5B;QAEA,sCAAsC;QACtC,IAAIkC,MAAMV,CAAC,GAAG,IAAI,CAACvB,IAAI,EAAE;YACvBqC,KAAK,IAAI,CAACrC,IAAI,GAAGiC,MAAMV,CAAC;QAC1B,OAEK,IAAIU,MAAMV,CAAC,GAAG,IAAI,CAAC1B,OAAO,EAAE;YAC/BwC,KAAKJ,MAAMV,CAAC,GAAG,IAAI,CAAC1B,OAAO;QAC7B;QAEA,wDAAwD;QACxD,OAAO;YACLsC,UAAUG,KAAKC,IAAI,CAACH,KAAKA,KAAKC,KAAKA;YACnCV,gBAAgBM,MAAMV,CAAC,GAAG,IAAI,CAAC1B,OAAO;YACtC+B,cAAcK,MAAMX,CAAC,GAAG,IAAI,CAACxB,KAAK;YAClC+B,eAAeI,MAAMX,CAAC,GAAG,IAAI,CAACvB,MAAM;YACpC2B,aAAaO,MAAMV,CAAC,GAAG,IAAI,CAACvB,IAAI;QAClC;IACF;IAEOwC,OAAO,EAAEnC,MAAM,EAAEH,IAAI,EAAEE,KAAK,EAAED,GAAG,EAAQ,EAAW;QACzD,OACEA,QAAQ,IAAI,CAACH,IAAI,IAAIK,WAAW,IAAI,CAACR,OAAO,IAAIK,SAAS,IAAI,CAACJ,KAAK,IAAIM,UAAU,IAAI,CAACL,MAAM;IAEhG;IAEO0C,gBAAgB,EACrBpC,SAAS,IAAI,CAACA,MAAM,EACpBH,OAAO,IAAI,CAACA,IAAI,EAChBE,QAAQ,IAAI,CAACA,KAAK,EAClBD,MAAM,IAAI,CAACA,GAAG,EACf,EAAQ;QACP,OAAO,IAAIP,KAAKM,MAAMC,KAAKC,OAAOC;IACpC;IAEOqC,eAAeC,IAAU,EAAW;QACzC,MAAM,EAAE/B,QAAQgC,EAAE,EAAE1C,MAAM2C,EAAE,EAAE1C,KAAK2C,EAAE,EAAEjC,OAAOkC,EAAE,EAAE,GAAGJ;QACrD,MAAM,EAAE/B,QAAQoC,EAAE,EAAE9C,MAAM+C,EAAE,EAAE9C,KAAK+C,EAAE,EAAErC,OAAOsC,EAAE,EAAE,GAAG,IAAI;QACzD,MAAMC,OAAOP,KAAKE,MAAME,KAAKE,KAAKN,KAAKE,KAAKE,KAAKE;QACjD,MAAME,OAAOP,KAAKF,MAAMM,KAAKF,KAAKF,KAAKF,KAAKM,KAAKF;QACjD,MAAMM,OAAOT,MAAMI,KAAKJ,KAAKI;QAC7B,MAAMM,OAAOT,MAAMI,KAAKJ,KAAKI;QAC7B,OAAOE,OAAOE,QAAQP,KAAKI,MAAME,OAAOE,QAAQX,KAAKI;IACvD;IAEA,IAAI3C,SAAiB;QACnB,OAAO,IAAI,CAACR,OAAO;IACrB;IAEA,IAAIe,SAAiB;QACnB,OAAO0B,KAAKkB,GAAG,CAAC,IAAI,CAAC3D,OAAO,GAAG,IAAI,CAACG,IAAI;IAC1C;IAEA,IAAIE,OAAe;QACjB,OAAO,IAAI,CAACJ,KAAK;IACnB;IAEA,IAAIM,QAAgB;QAClB,OAAO,IAAI,CAACL,MAAM;IACpB;IAEA,IAAII,MAAc;QAChB,OAAO,IAAI,CAACH,IAAI;IAClB;IAEA,IAAIa,QAAgB;QAClB,OAAOyB,KAAKkB,GAAG,CAAC,IAAI,CAAC1D,KAAK,GAAG,IAAI,CAACC,MAAM;IAC1C;AACF"}
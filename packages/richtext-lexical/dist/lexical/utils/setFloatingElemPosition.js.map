{"version":3,"sources":["../../../src/lexical/utils/setFloatingElemPosition.ts"],"sourcesContent":["const VERTICAL_GAP = 10\nconst HORIZONTAL_OFFSET = 5\n\n// TODO: needs refactoring\n// This is supposed to position the floatingElem based on the parent (anchorElem) and the target (targetRect) which is usually the selected text.\n// So basically, it positions the floatingElem either below or above the target (targetRect) and aligns it to the left or center of the target (targetRect).\n// This is used for positioning the floating toolbar (anchor: richtext editor) and its caret (anchor: floating toolbar)\nexport function setFloatingElemPosition(args: {\n  alwaysDisplayOnTop?: boolean\n  anchorElem: HTMLElement\n  anchorFlippedOffset?: number // Offset which was added to the anchor (for caret, floating toolbar) if it was flipped\n  floatingElem: HTMLElement\n  horizontalOffset?: number\n  horizontalPosition?: 'center' | 'left'\n  specialHandlingForCaret?: boolean\n  targetRect: ClientRect | null\n  verticalGap?: number\n}): number {\n  const {\n    alwaysDisplayOnTop = false,\n    anchorElem,\n    anchorFlippedOffset = 0, // Offset which was added to the anchor (for caret, floating toolbar) if it was flipped\n    floatingElem,\n    horizontalOffset = HORIZONTAL_OFFSET,\n    horizontalPosition = 'left',\n    specialHandlingForCaret = false,\n    targetRect,\n    verticalGap = VERTICAL_GAP,\n  } = args\n  // Returns the top offset if the target was flipped\n  const scrollerElem = anchorElem.parentElement\n\n  if (targetRect === null || scrollerElem == null) {\n    floatingElem.style.opacity = '0'\n    floatingElem.style.transform = 'translate(-10000px, -10000px)'\n    return\n  }\n\n  const floatingElemRect = floatingElem.getBoundingClientRect()\n  const anchorElementRect = anchorElem.getBoundingClientRect()\n  const editorScrollerRect = scrollerElem.getBoundingClientRect()\n\n  let top = targetRect.top - floatingElemRect.height - verticalGap\n  let left = targetRect.left - horizontalOffset\n\n  if (horizontalPosition === 'center') {\n    // Calculate left to position floatingElem to the horizontal middle of targetRect\n    left = targetRect.left + targetRect.width / 2 - floatingElemRect.width / 2\n  }\n\n  let addedToTop = 0\n  if (!alwaysDisplayOnTop && top < editorScrollerRect.top && !specialHandlingForCaret) {\n    addedToTop = floatingElemRect.height + targetRect.height + verticalGap * 2\n\n    top += addedToTop\n  }\n\n  if (horizontalPosition === 'center') {\n    if (left + floatingElemRect.width > editorScrollerRect.right) {\n      left = editorScrollerRect.right - floatingElemRect.width - horizontalOffset\n    } else if (left < editorScrollerRect.left) {\n      left = editorScrollerRect.left + horizontalOffset\n    }\n  } else {\n    if (left + floatingElemRect.width > editorScrollerRect.right) {\n      left = editorScrollerRect.right - floatingElemRect.width - horizontalOffset\n    }\n  }\n\n  left -= anchorElementRect.left\n\n  floatingElem.style.opacity = '1'\n\n  if (specialHandlingForCaret && anchorFlippedOffset !== 0) {\n    // Floating select toolbar was flipped (positioned below text rather than above). Thus, the caret now needs to be positioned\n    // on the other side and rotated.\n    top -= anchorElementRect.bottom - anchorFlippedOffset + floatingElemRect.height - 3\n    // top += anchorFlippedOffset - anchorElementRect.height - floatingElemRect.height + 2\n    floatingElem.style.transform = `translate(${left}px, ${top}px) rotate(180deg)`\n  } else {\n    top -= anchorElementRect.top\n\n    floatingElem.style.transform = `translate(${left}px, ${top}px)`\n  }\n\n  return addedToTop\n}\n"],"names":["VERTICAL_GAP","HORIZONTAL_OFFSET","setFloatingElemPosition","args","alwaysDisplayOnTop","anchorElem","anchorFlippedOffset","floatingElem","horizontalOffset","horizontalPosition","specialHandlingForCaret","targetRect","verticalGap","scrollerElem","parentElement","style","opacity","transform","floatingElemRect","getBoundingClientRect","anchorElementRect","editorScrollerRect","top","height","left","width","addedToTop","right","bottom"],"mappings":"AAAA,MAAMA,eAAe;AACrB,MAAMC,oBAAoB;AAE1B,0BAA0B;AAC1B,iJAAiJ;AACjJ,4JAA4J;AAC5J,uHAAuH;AACvH,OAAO,SAASC,wBAAwBC,IAUvC;IACC,MAAM,EACJC,qBAAqB,KAAK,EAC1BC,UAAU,EACVC,sBAAsB,CAAC,EACvBC,YAAY,EACZC,mBAAmBP,iBAAiB,EACpCQ,qBAAqB,MAAM,EAC3BC,0BAA0B,KAAK,EAC/BC,UAAU,EACVC,cAAcZ,YAAY,EAC3B,GAAGG;IACJ,mDAAmD;IACnD,MAAMU,eAAeR,WAAWS,aAAa;IAE7C,IAAIH,eAAe,QAAQE,gBAAgB,MAAM;QAC/CN,aAAaQ,KAAK,CAACC,OAAO,GAAG;QAC7BT,aAAaQ,KAAK,CAACE,SAAS,GAAG;QAC/B;IACF;IAEA,MAAMC,mBAAmBX,aAAaY,qBAAqB;IAC3D,MAAMC,oBAAoBf,WAAWc,qBAAqB;IAC1D,MAAME,qBAAqBR,aAAaM,qBAAqB;IAE7D,IAAIG,MAAMX,WAAWW,GAAG,GAAGJ,iBAAiBK,MAAM,GAAGX;IACrD,IAAIY,OAAOb,WAAWa,IAAI,GAAGhB;IAE7B,IAAIC,uBAAuB,UAAU;QACnC,iFAAiF;QACjFe,OAAOb,WAAWa,IAAI,GAAGb,WAAWc,KAAK,GAAG,IAAIP,iBAAiBO,KAAK,GAAG;IAC3E;IAEA,IAAIC,aAAa;IACjB,IAAI,CAACtB,sBAAsBkB,MAAMD,mBAAmBC,GAAG,IAAI,CAACZ,yBAAyB;QACnFgB,aAAaR,iBAAiBK,MAAM,GAAGZ,WAAWY,MAAM,GAAGX,cAAc;QAEzEU,OAAOI;IACT;IAEA,IAAIjB,uBAAuB,UAAU;QACnC,IAAIe,OAAON,iBAAiBO,KAAK,GAAGJ,mBAAmBM,KAAK,EAAE;YAC5DH,OAAOH,mBAAmBM,KAAK,GAAGT,iBAAiBO,KAAK,GAAGjB;QAC7D,OAAO,IAAIgB,OAAOH,mBAAmBG,IAAI,EAAE;YACzCA,OAAOH,mBAAmBG,IAAI,GAAGhB;QACnC;IACF,OAAO;QACL,IAAIgB,OAAON,iBAAiBO,KAAK,GAAGJ,mBAAmBM,KAAK,EAAE;YAC5DH,OAAOH,mBAAmBM,KAAK,GAAGT,iBAAiBO,KAAK,GAAGjB;QAC7D;IACF;IAEAgB,QAAQJ,kBAAkBI,IAAI;IAE9BjB,aAAaQ,KAAK,CAACC,OAAO,GAAG;IAE7B,IAAIN,2BAA2BJ,wBAAwB,GAAG;QACxD,4HAA4H;QAC5H,iCAAiC;QACjCgB,OAAOF,kBAAkBQ,MAAM,GAAGtB,sBAAsBY,iBAAiBK,MAAM,GAAG;QAClF,sFAAsF;QACtFhB,aAAaQ,KAAK,CAACE,SAAS,GAAG,CAAC,UAAU,EAAEO,KAAK,IAAI,EAAEF,IAAI,kBAAkB,CAAC;IAChF,OAAO;QACLA,OAAOF,kBAAkBE,GAAG;QAE5Bf,aAAaQ,KAAK,CAACE,SAAS,GAAG,CAAC,UAAU,EAAEO,KAAK,IAAI,EAAEF,IAAI,GAAG,CAAC;IACjE;IAEA,OAAOI;AACT"}
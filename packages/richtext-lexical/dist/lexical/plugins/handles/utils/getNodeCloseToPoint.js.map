{"version":3,"sources":["../../../../../src/lexical/plugins/handles/utils/getNodeCloseToPoint.ts"],"sourcesContent":["import type { LexicalEditor, LexicalNode } from 'lexical'\n\nimport { $getNodeByKey } from 'lexical'\n\nimport { Point } from '../../../utils/point.js'\nimport { Rect } from '../../../utils/rect.js'\nimport { getBoundingClientRectWithoutTransform } from '../DraggableBlockPlugin/getBoundingRectWithoutTransform.js'\nimport { getCollapsedMargins } from '../utils/getCollapsedMargins.js'\nimport { getTopLevelNodeKeys } from '../utils/getTopLevelNodeKeys.js'\n\n// Directions\nconst Downward = 1\nconst Upward = -1\nconst Indeterminate = 0\n\ntype Props = {\n  anchorElem: HTMLElement\n  cache_threshold?: number\n  editor: LexicalEditor\n  /** fuzzy makes the search not exact. If no exact match found, find the closes node instead of returning null */\n  fuzzy?: boolean\n  horizontalOffset?: number\n  point: Point\n  /**\n   * By default, empty paragraphs are not returned. Set this to true to return empty paragraphs. @default false\n   */\n  returnEmptyParagraphs?: boolean\n  /**\n   * The index to start searching from. It can be a considerable performance optimization to start searching from the index of the\n   * previously found node, as the node is likely to be close to the next node.\n   */\n  startIndex?: number\n  useEdgeAsDefault?: boolean\n  verbose?: boolean\n}\n\ntype Output = {\n  blockElem: HTMLElement | null\n  blockNode: LexicalNode | null\n  foundAtIndex: number\n  isFoundNodeEmptyParagraph: boolean\n}\n\nconst cache = {\n  props: null as Props | null,\n  result: null as Output | null,\n}\n\nfunction isPointClose(previous: Point, current: Point, threshold: number = 20): boolean {\n  const dx = previous.x - current.x\n  const dy = previous.y - current.y\n  return dx * dx + dy * dy <= threshold * threshold\n}\n\nexport function getNodeCloseToPoint(props: Props): Output {\n  const {\n    anchorElem,\n    cache_threshold = 20,\n    editor,\n    fuzzy = false,\n    horizontalOffset = 0,\n    point: { x, y },\n    startIndex = 0,\n    useEdgeAsDefault = false,\n    verbose = false,\n  } = props\n\n  // Use cache\n  if (\n    cache_threshold > 0 &&\n    cache.props &&\n    cache.result &&\n    cache.props.fuzzy === props.fuzzy &&\n    cache.props.horizontalOffset === props.horizontalOffset &&\n    cache.props.useEdgeAsDefault === props.useEdgeAsDefault &&\n    isPointClose(cache.props.point, props.point, cache_threshold)\n  ) {\n    return cache.result\n  }\n\n  const anchorElementRect = anchorElem.getBoundingClientRect()\n  const topLevelNodeKeys = getTopLevelNodeKeys(editor)\n\n  const closestBlockElem: {\n    blockElem: HTMLElement | null\n    blockNode: LexicalNode | null\n    distance: number\n    foundAtIndex: number\n    isFoundNodeEmptyParagraph: boolean\n  } = {\n    blockElem: null,\n    blockNode: null,\n    distance: Infinity,\n    foundAtIndex: -1,\n    isFoundNodeEmptyParagraph: false,\n  }\n\n  // Return null if matching block element is the first or last node\n  editor.getEditorState().read(() => {\n    if (useEdgeAsDefault) {\n      const [firstNode, lastNode] = [\n        editor.getElementByKey(topLevelNodeKeys[0]),\n        editor.getElementByKey(topLevelNodeKeys[topLevelNodeKeys.length - 1]),\n      ]\n\n      const [firstNodeRect, lastNodeRect] = [\n        getBoundingClientRectWithoutTransform(firstNode),\n        getBoundingClientRectWithoutTransform(lastNode),\n      ]\n\n      if (firstNodeRect && lastNodeRect) {\n        if (y < firstNodeRect.top) {\n          closestBlockElem.blockElem = firstNode\n          closestBlockElem.distance = firstNodeRect.top - y\n          closestBlockElem.blockNode = $getNodeByKey(topLevelNodeKeys[0])\n          closestBlockElem.foundAtIndex = 0\n        } else if (y > lastNodeRect.bottom) {\n          closestBlockElem.distance = y - lastNodeRect.bottom\n          closestBlockElem.blockNode = $getNodeByKey(topLevelNodeKeys[topLevelNodeKeys.length - 1])\n          closestBlockElem.blockElem = lastNode\n          closestBlockElem.foundAtIndex = topLevelNodeKeys.length - 1\n        }\n\n        if (closestBlockElem?.blockElem) {\n          return {\n            blockElem: null,\n            isFoundNodeEmptyParagraph: false,\n          } as Output\n        }\n      }\n    }\n\n    // Find matching block element\n    let index = startIndex\n    let direction = Indeterminate\n\n    while (index >= 0 && index < topLevelNodeKeys.length) {\n      const key = topLevelNodeKeys[index]\n      const elem = editor.getElementByKey(key)\n      if (elem === null) {\n        break\n      }\n      const point = new Point(x + horizontalOffset, y)\n      //const domRect = Rect.fromDOM(elem)\n      // Do not consider transform of blocks when calculating distance\n      const domRect = Rect.fromDOMRect(getBoundingClientRectWithoutTransform(elem))\n\n      const { marginBottom, marginTop } = getCollapsedMargins(elem)\n\n      const rect = domRect.generateNewRect({\n        bottom: domRect.bottom + marginBottom,\n        left: anchorElementRect.left,\n        right: anchorElementRect.right,\n        top: domRect.top - marginTop,\n      })\n\n      const { distance, isOnBottomSide, isOnTopSide } = rect.distanceFromPoint(point)\n\n      if (distance === 0) {\n        closestBlockElem.blockElem = elem\n        closestBlockElem.blockNode = $getNodeByKey(key)\n        closestBlockElem.foundAtIndex = index\n        closestBlockElem.distance = distance\n\n        // Check if blockNode is an empty text node\n        if (\n          closestBlockElem.blockNode &&\n          closestBlockElem.blockNode.getType() === 'paragraph' &&\n          closestBlockElem.blockNode.getTextContent() === ''\n        ) {\n          if (!fuzzy && !props.returnEmptyParagraphs) {\n            closestBlockElem.blockElem = null\n            closestBlockElem.blockNode = null\n          }\n\n          closestBlockElem.isFoundNodeEmptyParagraph = true\n        }\n        break\n      } else if (fuzzy) {\n        if (distance < closestBlockElem.distance) {\n          closestBlockElem.blockElem = elem\n          closestBlockElem.blockNode = $getNodeByKey(key)\n          closestBlockElem.distance = distance\n          closestBlockElem.foundAtIndex = index\n        }\n      }\n\n      if (direction === Indeterminate) {\n        if (isOnTopSide) {\n          direction = Upward\n        } else if (isOnBottomSide) {\n          direction = Downward\n        } else {\n          // stop search block element\n          direction = Infinity\n        }\n      }\n\n      index += direction\n    }\n  })\n\n  // Store in cache before returning\n  cache.props = props\n  cache.result = {\n    blockElem: closestBlockElem.blockElem,\n    blockNode: closestBlockElem.blockNode,\n    foundAtIndex: closestBlockElem.foundAtIndex,\n    isFoundNodeEmptyParagraph: closestBlockElem.isFoundNodeEmptyParagraph,\n  }\n\n  return {\n    blockElem: closestBlockElem.blockElem,\n    blockNode: closestBlockElem.blockNode,\n    foundAtIndex: closestBlockElem.foundAtIndex,\n    isFoundNodeEmptyParagraph: closestBlockElem.isFoundNodeEmptyParagraph,\n  }\n}\n"],"names":["$getNodeByKey","Point","Rect","getBoundingClientRectWithoutTransform","getCollapsedMargins","getTopLevelNodeKeys","Downward","Upward","Indeterminate","cache","props","result","isPointClose","previous","current","threshold","dx","x","dy","y","getNodeCloseToPoint","anchorElem","cache_threshold","editor","fuzzy","horizontalOffset","point","startIndex","useEdgeAsDefault","verbose","anchorElementRect","getBoundingClientRect","topLevelNodeKeys","closestBlockElem","blockElem","blockNode","distance","Infinity","foundAtIndex","isFoundNodeEmptyParagraph","getEditorState","read","firstNode","lastNode","getElementByKey","length","firstNodeRect","lastNodeRect","top","bottom","index","direction","key","elem","domRect","fromDOMRect","marginBottom","marginTop","rect","generateNewRect","left","right","isOnBottomSide","isOnTopSide","distanceFromPoint","getType","getTextContent","returnEmptyParagraphs"],"mappings":"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"}
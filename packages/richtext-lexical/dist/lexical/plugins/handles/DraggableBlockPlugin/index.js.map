{"version":3,"sources":["../../../../../src/lexical/plugins/handles/DraggableBlockPlugin/index.tsx"],"sourcesContent":["'use client'\nimport type { LexicalEditor } from 'lexical'\nimport type { DragEvent as ReactDragEvent } from 'react'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { eventFiles } from '@lexical/rich-text'\nimport { $getNearestNodeFromDOMNode, $getNodeByKey } from 'lexical'\nimport * as React from 'react'\nimport { useEffect, useRef, useState } from 'react'\nimport { createPortal } from 'react-dom'\n\nimport { useEditorConfigContext } from '../../../config/client/EditorConfigProvider.js'\nimport { isHTMLElement } from '../../../utils/guard.js'\nimport { Point } from '../../../utils/point.js'\nimport { calculateDistanceFromScrollerElem } from '../utils/calculateDistanceFromScrollerElem.js'\nimport { getNodeCloseToPoint } from '../utils/getNodeCloseToPoint.js'\nimport { getTopLevelNodeKeys } from '../utils/getTopLevelNodeKeys.js'\nimport { isOnHandleElement } from '../utils/isOnHandleElement.js'\nimport { setHandlePosition } from '../utils/setHandlePosition.js'\nimport { getBoundingClientRectWithoutTransform } from './getBoundingRectWithoutTransform.js'\nimport './index.scss'\nimport { setTargetLine } from './setTargetLine.js'\n\nconst DRAGGABLE_BLOCK_MENU_CLASSNAME = 'draggable-block-menu'\nconst DRAG_DATA_FORMAT = 'application/x-lexical-drag-block'\n\nlet prevIndex = Infinity\n\nfunction getCurrentIndex(keysLength: number): number {\n  if (keysLength === 0) {\n    return Infinity\n  }\n  if (prevIndex >= 0 && prevIndex < keysLength) {\n    return prevIndex\n  }\n\n  return Math.floor(keysLength / 2)\n}\n\nfunction setDragImage(dataTransfer: DataTransfer, draggableBlockElem: HTMLElement) {\n  const { transform } = draggableBlockElem.style\n\n  // Remove dragImage borders\n  dataTransfer.setDragImage(draggableBlockElem, 0, 0)\n\n  setTimeout(() => {\n    draggableBlockElem.style.transform = transform\n  })\n}\n\nfunction hideTargetLine(\n  targetLineElem: HTMLElement | null,\n  lastTargetBlockElem: HTMLElement | null,\n) {\n  if (targetLineElem) {\n    targetLineElem.style.opacity = '0'\n  }\n  if (lastTargetBlockElem) {\n    lastTargetBlockElem.style.opacity = ''\n    // Delete marginBottom and marginTop values we set\n    lastTargetBlockElem.style.marginBottom = ''\n    lastTargetBlockElem.style.marginTop = ''\n    //lastTargetBlock.style.border = 'none'\n  }\n}\n\nfunction useDraggableBlockMenu(\n  editor: LexicalEditor,\n  anchorElem: HTMLElement,\n  isEditable: boolean,\n): React.ReactElement {\n  const scrollerElem = anchorElem.parentElement\n\n  const menuRef = useRef<HTMLDivElement>(null)\n  const targetLineRef = useRef<HTMLDivElement>(null)\n  const debugHighlightRef = useRef<HTMLDivElement>(null)\n  const isDraggingBlockRef = useRef<boolean>(false)\n  const [draggableBlockElem, setDraggableBlockElem] = useState<HTMLElement | null>(null)\n  const [lastTargetBlock, setLastTargetBlock] = useState<{\n    boundingBox?: DOMRect\n    elem: HTMLElement | null\n    isBelow: boolean\n  }>(null)\n\n  const { editorConfig } = useEditorConfigContext()\n\n  const blockHandleHorizontalOffset = editorConfig?.admin?.hideGutter ? -44 : -8\n\n  useEffect(() => {\n    /**\n     * Handles positioning of the drag handle\n     */\n    function onDocumentMouseMove(event: MouseEvent) {\n      const target = event.target\n      if (!isHTMLElement(target)) {\n        return\n      }\n\n      const distanceFromScrollerElem = calculateDistanceFromScrollerElem(\n        scrollerElem,\n        event.pageX,\n        event.pageY,\n        target,\n      )\n      if (distanceFromScrollerElem === -1) {\n        setDraggableBlockElem(null)\n        return\n      }\n\n      if (isOnHandleElement(target, DRAGGABLE_BLOCK_MENU_CLASSNAME)) {\n        return\n      }\n\n      const topLevelNodeKeys = getTopLevelNodeKeys(editor)\n\n      const {\n        blockElem: _draggableBlockElem,\n        foundAtIndex,\n        isFoundNodeEmptyParagraph,\n      } = getNodeCloseToPoint({\n        anchorElem,\n        cache_threshold: 0,\n        editor,\n        horizontalOffset: -distanceFromScrollerElem,\n        point: new Point(event.x, event.y),\n        startIndex: getCurrentIndex(topLevelNodeKeys.length),\n        useEdgeAsDefault: false,\n        verbose: false,\n      })\n\n      prevIndex = foundAtIndex\n\n      //if (DEBUG && _draggableBlockElem) {\n      //targetBlockElem.style.border = '3px solid red'\n      // highlightElemOriginalPosition(debugHighlightRef, _draggableBlockElem, anchorElem)\n      //}\n\n      if (!_draggableBlockElem && !isFoundNodeEmptyParagraph) {\n        return\n      }\n\n      if (draggableBlockElem !== _draggableBlockElem) {\n        setDraggableBlockElem(_draggableBlockElem)\n      }\n    }\n\n    // Since the draggableBlockElem is outside the actual editor, we need to listen to the document\n    // to be able to detect when the mouse is outside the editor and respect a buffer around\n    // the scrollerElem to avoid the draggableBlockElem disappearing too early.\n    document?.addEventListener('mousemove', onDocumentMouseMove)\n\n    return () => {\n      document?.removeEventListener('mousemove', onDocumentMouseMove)\n    }\n  }, [scrollerElem, anchorElem, editor, draggableBlockElem])\n\n  useEffect(() => {\n    if (menuRef.current) {\n      setHandlePosition(\n        draggableBlockElem,\n        menuRef.current,\n        anchorElem,\n        blockHandleHorizontalOffset,\n      )\n    }\n  }, [anchorElem, draggableBlockElem, blockHandleHorizontalOffset])\n\n  useEffect(() => {\n    function onDragover(event: DragEvent): boolean {\n      if (!isDraggingBlockRef.current) {\n        return false\n      }\n      const [isFileTransfer] = eventFiles(event)\n      if (isFileTransfer) {\n        return false\n      }\n\n      const { pageY, target } = event\n      if (!isHTMLElement(target)) {\n        return false\n      }\n\n      const distanceFromScrollerElem = calculateDistanceFromScrollerElem(\n        scrollerElem,\n        event.pageX,\n        event.pageY,\n        target,\n        100,\n        50,\n      )\n\n      const topLevelNodeKeys = getTopLevelNodeKeys(editor)\n\n      const {\n        blockElem: targetBlockElem,\n        foundAtIndex,\n        isFoundNodeEmptyParagraph,\n      } = getNodeCloseToPoint({\n        anchorElem,\n        editor,\n        fuzzy: true,\n        horizontalOffset: -distanceFromScrollerElem,\n        point: new Point(event.x, event.y),\n        startIndex: getCurrentIndex(topLevelNodeKeys.length),\n        useEdgeAsDefault: true,\n        verbose: true,\n      })\n\n      prevIndex = foundAtIndex\n\n      const targetLineElem = targetLineRef.current\n      // targetBlockElem === null shouldn't happen\n      if (targetBlockElem === null || targetLineElem === null) {\n        return false\n      }\n\n      if (draggableBlockElem !== targetBlockElem) {\n        const { isBelow, willStayInSamePosition } = setTargetLine(\n          editorConfig?.admin?.hideGutter ? '0px' : '3rem',\n          blockHandleHorizontalOffset +\n            (editorConfig?.admin?.hideGutter\n              ? menuRef?.current?.getBoundingClientRect()?.width ?? 0\n              : -menuRef?.current?.getBoundingClientRect()?.width ?? 0),\n          targetLineElem,\n          targetBlockElem,\n          lastTargetBlock,\n          pageY,\n          anchorElem,\n          event,\n          debugHighlightRef,\n          isFoundNodeEmptyParagraph,\n        )\n\n        // Prevent default event to be able to trigger onDrop events\n        // Calling preventDefault() adds the green plus icon to the cursor,\n        // indicating that the drop is allowed.\n        event.preventDefault()\n\n        if (!willStayInSamePosition) {\n          setLastTargetBlock({\n            boundingBox: targetBlockElem.getBoundingClientRect(),\n            elem: targetBlockElem,\n            isBelow,\n          })\n        }\n      } else {\n        hideTargetLine(targetLineElem, lastTargetBlock?.elem)\n        setLastTargetBlock({\n          boundingBox: targetBlockElem.getBoundingClientRect(),\n          elem: targetBlockElem,\n          isBelow: false,\n        })\n      }\n\n      return true\n    }\n\n    function onDrop(event: DragEvent): boolean {\n      if (!isDraggingBlockRef.current) {\n        return false\n      }\n      const [isFileTransfer] = eventFiles(event)\n      if (isFileTransfer) {\n        return false\n      }\n      const { dataTransfer, pageY, target } = event\n      const dragData = dataTransfer?.getData(DRAG_DATA_FORMAT) || ''\n\n      editor.update(() => {\n        const draggedNode = $getNodeByKey(dragData)\n        if (!draggedNode) {\n          return false\n        }\n        if (!isHTMLElement(target)) {\n          return false\n        }\n        const distanceFromScrollerElem = calculateDistanceFromScrollerElem(\n          scrollerElem,\n          event.pageX,\n          event.pageY,\n          target,\n          100,\n          50,\n        )\n\n        const { blockElem: targetBlockElem, isFoundNodeEmptyParagraph } = getNodeCloseToPoint({\n          anchorElem,\n          editor,\n          fuzzy: true,\n          horizontalOffset: -distanceFromScrollerElem,\n          point: new Point(event.x, event.y),\n          useEdgeAsDefault: true,\n        })\n\n        if (!targetBlockElem) {\n          return false\n        }\n        const targetNode = $getNearestNodeFromDOMNode(targetBlockElem)\n        if (!targetNode) {\n          return false\n        }\n        if (targetNode === draggedNode) {\n          return true\n        }\n\n        const { height: targetBlockElemHeight, top: targetBlockElemTop } =\n          getBoundingClientRectWithoutTransform(targetBlockElem)\n\n        const mouseY = pageY\n        const isBelow = mouseY >= targetBlockElemTop + targetBlockElemHeight / 2 + window.scrollY\n\n        if (!isFoundNodeEmptyParagraph) {\n          if (isBelow) {\n            // below targetBlockElem\n            targetNode.insertAfter(draggedNode)\n          } else {\n            // above targetBlockElem\n            targetNode.insertBefore(draggedNode)\n          }\n        } else {\n          //\n          targetNode.insertBefore(draggedNode)\n          targetNode.remove()\n        }\n\n        /*\n        if (pageY >= targetBlockElemTop + targetBlockElemHeight / 2) {\n          targetNode.insertAfter(draggedNode)\n        } else {\n          targetNode.insertBefore(draggedNode)\n        }*/\n        if (draggableBlockElem !== null) {\n          setDraggableBlockElem(null)\n        }\n\n        // find all previous elements with lexical-block-highlighter class and remove them\n        const allPrevHighlighters = document.querySelectorAll('.lexical-block-highlighter')\n        allPrevHighlighters.forEach((highlighter) => {\n          highlighter.remove()\n        })\n\n        const newInsertedElem = editor.getElementByKey(draggedNode.getKey())\n        setTimeout(() => {\n          // add new temp html element to newInsertedElem with the same height and width and the class block-selected\n          // to highlight the new inserted element\n          const newInsertedElemRect = newInsertedElem.getBoundingClientRect()\n\n          const highlightElem = document.createElement('div')\n          highlightElem.className = 'lexical-block-highlighter'\n\n          // if html data-theme is dark, set the highlighter color to white\n          if (document.documentElement.getAttribute('data-theme') === 'dark') {\n            highlightElem.style.backgroundColor = 'white'\n          } else {\n            highlightElem.style.backgroundColor = 'black'\n          }\n\n          highlightElem.style.transition = 'opacity 0.1s ease-in-out'\n          highlightElem.style.zIndex = '1'\n          highlightElem.style.pointerEvents = 'none'\n          highlightElem.style.boxSizing = 'border-box'\n          highlightElem.style.borderRadius = '4px'\n          highlightElem.style.position = 'absolute'\n          document.body.appendChild(highlightElem)\n\n          highlightElem.style.opacity = '0.1'\n\n          highlightElem.style.height = `${newInsertedElemRect.height + 8}px`\n          highlightElem.style.width = `${newInsertedElemRect.width + 8}px`\n          highlightElem.style.top = `${newInsertedElemRect.top + window.scrollY - 4}px`\n          highlightElem.style.left = `${newInsertedElemRect.left - 4}px`\n\n          setTimeout(() => {\n            highlightElem.style.opacity = '0'\n            setTimeout(() => {\n              highlightElem.remove()\n            }, 1000)\n          }, 3000)\n        }, 120)\n      })\n\n      return true\n    }\n\n    // register onDragover event listeners:\n    document.addEventListener('dragover', onDragover)\n    // register onDrop event listeners:\n    document.addEventListener('drop', onDrop)\n\n    return () => {\n      document.removeEventListener('dragover', onDragover)\n      document.removeEventListener('drop', onDrop)\n    }\n  }, [\n    scrollerElem,\n    blockHandleHorizontalOffset,\n    anchorElem,\n    editor,\n    lastTargetBlock,\n    draggableBlockElem,\n    editorConfig?.admin?.hideGutter,\n  ])\n\n  function onDragStart(event: ReactDragEvent<HTMLDivElement>): void {\n    const dataTransfer = event.dataTransfer\n    if (!dataTransfer || !draggableBlockElem) {\n      return\n    }\n    setDragImage(dataTransfer, draggableBlockElem)\n    let nodeKey = ''\n    editor.update(() => {\n      const node = $getNearestNodeFromDOMNode(draggableBlockElem)\n      if (node) {\n        nodeKey = node.getKey()\n      }\n    })\n    isDraggingBlockRef.current = true\n    dataTransfer.setData(DRAG_DATA_FORMAT, nodeKey)\n  }\n\n  function onDragEnd(): void {\n    isDraggingBlockRef.current = false\n    hideTargetLine(targetLineRef.current, lastTargetBlock?.elem)\n  }\n\n  return createPortal(\n    <React.Fragment>\n      <div\n        className=\"icon draggable-block-menu\"\n        draggable\n        onDragEnd={onDragEnd}\n        onDragStart={onDragStart}\n        ref={menuRef}\n      >\n        <div className={isEditable ? 'icon' : ''} />\n      </div>\n      <div className=\"draggable-block-target-line\" ref={targetLineRef} />\n      <div className=\"debug-highlight\" ref={debugHighlightRef} />\n    </React.Fragment>,\n    anchorElem,\n  )\n}\n\nexport function DraggableBlockPlugin({\n  anchorElem = document.body,\n}: {\n  anchorElem?: HTMLElement\n}): React.ReactElement {\n  const [editor] = useLexicalComposerContext()\n  return useDraggableBlockMenu(editor, anchorElem, editor._editable)\n}\n"],"names":["useLexicalComposerContext","eventFiles","$getNearestNodeFromDOMNode","$getNodeByKey","React","useEffect","useRef","useState","createPortal","useEditorConfigContext","isHTMLElement","Point","calculateDistanceFromScrollerElem","getNodeCloseToPoint","getTopLevelNodeKeys","isOnHandleElement","setHandlePosition","getBoundingClientRectWithoutTransform","setTargetLine","DRAGGABLE_BLOCK_MENU_CLASSNAME","DRAG_DATA_FORMAT","prevIndex","Infinity","getCurrentIndex","keysLength","Math","floor","setDragImage","dataTransfer","draggableBlockElem","transform","style","setTimeout","hideTargetLine","targetLineElem","lastTargetBlockElem","opacity","marginBottom","marginTop","useDraggableBlockMenu","editor","anchorElem","isEditable","scrollerElem","parentElement","menuRef","targetLineRef","debugHighlightRef","isDraggingBlockRef","setDraggableBlockElem","lastTargetBlock","setLastTargetBlock","editorConfig","blockHandleHorizontalOffset","admin","hideGutter","onDocumentMouseMove","event","target","distanceFromScrollerElem","pageX","pageY","topLevelNodeKeys","blockElem","_draggableBlockElem","foundAtIndex","isFoundNodeEmptyParagraph","cache_threshold","horizontalOffset","point","x","y","startIndex","length","useEdgeAsDefault","verbose","document","addEventListener","removeEventListener","current","onDragover","isFileTransfer","targetBlockElem","fuzzy","isBelow","willStayInSamePosition","getBoundingClientRect","width","preventDefault","boundingBox","elem","onDrop","dragData","getData","update","draggedNode","targetNode","height","targetBlockElemHeight","top","targetBlockElemTop","mouseY","window","scrollY","insertAfter","insertBefore","remove","allPrevHighlighters","querySelectorAll","forEach","highlighter","newInsertedElem","getElementByKey","getKey","newInsertedElemRect","highlightElem","createElement","className","documentElement","getAttribute","backgroundColor","transition","zIndex","pointerEvents","boxSizing","borderRadius","position","body","appendChild","left","onDragStart","nodeKey","node","setData","onDragEnd","Fragment","div","draggable","ref","DraggableBlockPlugin","_editable"],"mappings":"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"}
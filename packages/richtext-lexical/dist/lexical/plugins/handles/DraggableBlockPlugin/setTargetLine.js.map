{"version":3,"sources":["../../../../../src/lexical/plugins/handles/DraggableBlockPlugin/setTargetLine.ts"],"sourcesContent":["import { getCollapsedMargins } from '../utils/getCollapsedMargins.js'\nimport { getBoundingClientRectWithoutTransform } from './getBoundingRectWithoutTransform.js'\nimport { highlightElemOriginalPosition } from './highlightElemOriginalPosition.js'\nconst TARGET_LINE_HALF_HEIGHT = 25\nconst TEXT_BOX_HORIZONTAL_PADDING = -24\nconst DEBUG = false\n\nlet animationTimer = 0\n\nexport function setTargetLine(\n  offsetWidth: string,\n  offsetLeft: number,\n  targetLineElem: HTMLElement,\n  targetBlockElem: HTMLElement,\n  lastTargetBlock: {\n    boundingBox?: DOMRect\n    elem: HTMLElement | null\n    isBelow: boolean\n  },\n  mouseY: number,\n  anchorElem: HTMLElement,\n  event: DragEvent,\n  debugHighlightRef: React.RefObject<HTMLDivElement | null>,\n  isFoundNodeEmptyParagraph: boolean = false,\n) {\n  const { height: targetBlockElemHeight, top: targetBlockElemTop } =\n    targetBlockElem.getBoundingClientRect() // used to be getBoundingClientRectWithoutTransform. Not sure what's better, but the normal getBoundingClientRect seems to work fine\n  const { top: anchorTop, width: anchorWidth } = anchorElem.getBoundingClientRect()\n\n  const { marginBottom, marginTop } = getCollapsedMargins(targetBlockElem)\n  let lineTop = targetBlockElemTop\n\n  const isBelow = mouseY >= targetBlockElemTop + targetBlockElemHeight / 2 + window.scrollY\n\n  let willStayInSamePosition = false\n\n  /**\n   * Do not run any transform or changes if the actual new line position would be the same (even if it's now inserted BEFORE rather than AFTER - position would still be the same)\n   * This prevents unnecessary flickering.\n   *\n   * We still need to let it run even if the position (IGNORING the transform) would not change, as the transform animation is not finished yet. This is what animationTimer does. Otherwise, the positioning will be inaccurate\n   */\n  if (lastTargetBlock?.elem) {\n    if (targetBlockElem !== lastTargetBlock?.elem) {\n      if (\n        isBelow &&\n        lastTargetBlock?.elem &&\n        lastTargetBlock?.elem === targetBlockElem.nextElementSibling\n      ) {\n        animationTimer++\n\n        if (animationTimer < 200) {\n          willStayInSamePosition = true\n        }\n      } else if (\n        !isBelow &&\n        lastTargetBlock?.elem &&\n        lastTargetBlock?.elem === targetBlockElem.previousElementSibling\n      ) {\n        animationTimer++\n        if (animationTimer < 200) {\n          willStayInSamePosition = true\n        }\n      }\n    } else {\n      animationTimer++\n\n      const lastBoundingBoxPosition = lastTargetBlock?.boundingBox?.y\n      const currentBoundingBoxPosition = targetBlockElem.getBoundingClientRect().y\n\n      if (\n        (isBelow === lastTargetBlock?.isBelow &&\n          lastBoundingBoxPosition === currentBoundingBoxPosition) ||\n        animationTimer < 200\n      ) {\n        willStayInSamePosition = false\n      }\n    }\n  }\n  if (willStayInSamePosition) {\n    return {\n      isBelow,\n      willStayInSamePosition,\n    }\n  }\n\n  /**\n   * Paragraphs need no isBelow/above handling,\n   */\n  if (!isFoundNodeEmptyParagraph) {\n    //if (!isFoundNodeEmptyParagraph) {\n    if (isBelow) {\n      // below targetBlockElem\n      lineTop += targetBlockElemHeight + marginBottom / 2\n    } else {\n      // above targetBlockElem\n      lineTop -= marginTop / 2\n    }\n  } else {\n    lineTop += targetBlockElemHeight / 2\n  }\n\n  let targetElemTranslate2 = 0\n\n  if (!isFoundNodeEmptyParagraph) {\n    if (isBelow) {\n      targetElemTranslate2 = -TARGET_LINE_HALF_HEIGHT\n    } else {\n      targetElemTranslate2 = TARGET_LINE_HALF_HEIGHT\n    }\n  }\n\n  const top = lineTop - anchorTop + targetElemTranslate2\n\n  const left = TEXT_BOX_HORIZONTAL_PADDING - offsetLeft\n\n  targetLineElem.style.width = `calc(${anchorWidth}px - ${offsetWidth})`\n  targetLineElem.style.opacity = '.4'\n\n  /**\n   * Move around element below or above the line (= the target / targetBlockElem). Creates \"space\" for the targetLineElem\n   *\n   * Not needed for empty paragraphs, as an empty paragraph is enough space for the targetLineElem anyways.\n   */\n  //targetBlockElem.style.opacity = '0.4'\n  const buffer = 12 // creates more spacing/padding so target line is not directly next to the targetBlockElem\n  if (!isFoundNodeEmptyParagraph) {\n    if (isBelow) {\n      targetBlockElem.style.marginBottom = TARGET_LINE_HALF_HEIGHT * 2 + buffer + 'px'\n      targetLineElem.style.transform = `translate(${left}px, calc(${top}px - ${'0px'}))`\n    } else {\n      targetBlockElem.style.marginTop = TARGET_LINE_HALF_HEIGHT * 2 + buffer + 'px'\n      targetLineElem.style.transform = `translate(${left}px, calc(${top - TARGET_LINE_HALF_HEIGHT * 2}px - ${'0px'}))`\n    }\n  } else {\n    targetLineElem.style.transform = `translate(${left}px, ${top - TARGET_LINE_HALF_HEIGHT}px)`\n  }\n\n  if (DEBUG) {\n    //targetBlockElem.style.border = '3px solid red'\n    highlightElemOriginalPosition(debugHighlightRef, targetBlockElem, anchorElem)\n  }\n\n  /**\n   * Properly reset previous targetBlockElem styles\n   */\n  lastTargetBlock.elem.style.opacity = ''\n\n  if (lastTargetBlock?.elem === targetBlockElem) {\n    if (isBelow) {\n      lastTargetBlock.elem.style.marginTop = ''\n    } else {\n      lastTargetBlock.elem.style.marginBottom = ''\n    }\n  } else {\n    lastTargetBlock.elem.style.marginBottom = ''\n    lastTargetBlock.elem.style.marginTop = ''\n  }\n  animationTimer = 0\n  return {\n    isBelow,\n    willStayInSamePosition,\n  }\n}\n"],"names":["getCollapsedMargins","highlightElemOriginalPosition","TARGET_LINE_HALF_HEIGHT","TEXT_BOX_HORIZONTAL_PADDING","DEBUG","animationTimer","setTargetLine","offsetWidth","offsetLeft","targetLineElem","targetBlockElem","lastTargetBlock","mouseY","anchorElem","event","debugHighlightRef","isFoundNodeEmptyParagraph","height","targetBlockElemHeight","top","targetBlockElemTop","getBoundingClientRect","anchorTop","width","anchorWidth","marginBottom","marginTop","lineTop","isBelow","window","scrollY","willStayInSamePosition","elem","nextElementSibling","previousElementSibling","lastBoundingBoxPosition","boundingBox","y","currentBoundingBoxPosition","targetElemTranslate2","left","style","opacity","buffer","transform"],"mappings":"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"}
{"version":3,"sources":["../../../../../src/lexical/plugins/SlashMenu/LexicalTypeaheadMenuPlugin/index.tsx"],"sourcesContent":["'use client'\nimport type {\n  LexicalCommand,\n  LexicalEditor,\n  ParagraphNode,\n  RangeSelection,\n  TextNode,\n} from 'lexical'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { mergeRegister } from '@lexical/utils'\nimport {\n  $getSelection,\n  $isRangeSelection,\n  $isTextNode,\n  COMMAND_PRIORITY_LOW,\n  createCommand,\n} from 'lexical'\nimport { type JSX, useCallback, useEffect, useState } from 'react'\nimport * as React from 'react'\n\nimport type { MenuTextMatch, TriggerFn } from '../useMenuTriggerMatch.js'\nimport type { MenuRenderFn, MenuResolution } from './LexicalMenu.js'\nimport type { SlashMenuGroup, SlashMenuGroupInternal, SlashMenuItem } from './types.js'\n\nimport { LexicalMenu, useMenuAnchorRef } from './LexicalMenu.js'\n\nexport const PUNCTUATION = '\\\\.,\\\\+\\\\*\\\\?\\\\$\\\\@\\\\|#{}\\\\(\\\\)\\\\^\\\\-\\\\[\\\\]\\\\\\\\/!%\\'\"~=<>_:;'\n\nfunction getTextUpToAnchor(selection: RangeSelection): null | string {\n  const anchor = selection.anchor\n  if (anchor.type !== 'text') {\n    return null\n  }\n  const anchorNode = anchor.getNode()\n  if (!anchorNode.isSimpleText()) {\n    return null\n  }\n  const anchorOffset = anchor.offset\n  return anchorNode.getTextContent().slice(0, anchorOffset)\n}\n\nfunction tryToPositionRange(leadOffset: number, range: Range, editorWindow: Window): boolean {\n  const domSelection = editorWindow.getSelection()\n  if (domSelection === null || !domSelection.isCollapsed) {\n    return false\n  }\n  const anchorNode = domSelection.anchorNode\n  const startOffset = leadOffset\n  const endOffset = domSelection.anchorOffset\n\n  if (anchorNode == null || endOffset == null) {\n    return false\n  }\n\n  try {\n    range.setStart(anchorNode, startOffset)\n    // if endOffset is 0, positioning the range for when you click the plus button to open the slash menu will fial\n    range.setEnd(anchorNode, endOffset > 1 ? endOffset : 1)\n  } catch (error) {\n    return false\n  }\n\n  return true\n}\n\nfunction getQueryTextForSearch(editor: LexicalEditor): null | string {\n  let text = null\n  editor.getEditorState().read(() => {\n    const selection = $getSelection()\n    if (!$isRangeSelection(selection)) {\n      return\n    }\n    text = getTextUpToAnchor(selection)\n  })\n  return text\n}\n\nfunction isSelectionOnEntityBoundary(editor: LexicalEditor, offset: number): boolean {\n  if (offset !== 0) {\n    return false\n  }\n  return editor.getEditorState().read(() => {\n    const selection = $getSelection()\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor\n      const anchorNode = anchor.getNode()\n      const prevSibling = anchorNode.getPreviousSibling()\n      return $isTextNode(prevSibling) && prevSibling.isTextEntity()\n    }\n    return false\n  })\n}\n\nfunction startTransition(callback: () => void) {\n  if (React.startTransition) {\n    React.startTransition(callback)\n  } else {\n    callback()\n  }\n}\n\n// Got from https://stackoverflow.com/a/42543908/2013580\nexport function getScrollParent(\n  element: HTMLElement,\n  includeHidden: boolean,\n): HTMLBodyElement | HTMLElement {\n  let style = getComputedStyle(element)\n  const excludeStaticParent = style.position === 'absolute'\n  const overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/\n  if (style.position === 'fixed') {\n    return document.body\n  }\n  for (let parent: HTMLElement | null = element; (parent = parent.parentElement); ) {\n    style = getComputedStyle(parent)\n    if (excludeStaticParent && style.position === 'static') {\n      continue\n    }\n    if (overflowRegex.test(style.overflow + style.overflowY + style.overflowX)) {\n      return parent\n    }\n  }\n  return document.body\n}\n\nexport { useDynamicPositioning } from './LexicalMenu.js'\n\nexport type TypeaheadMenuPluginProps = {\n  anchorClassName?: string\n  anchorElem: HTMLElement\n  groups: Array<SlashMenuGroupInternal>\n  menuRenderFn: MenuRenderFn\n  onClose?: () => void\n  onOpen?: (resolution: MenuResolution) => void\n  onQueryChange: (matchingString: null | string) => void\n  onSelectItem: (\n    item: SlashMenuItem,\n    textNodeContainingQuery: TextNode | null,\n    closeMenu: () => void,\n    matchingString: string,\n  ) => void\n  triggerFn: TriggerFn\n}\n\nexport const ENABLE_SLASH_MENU_COMMAND: LexicalCommand<{\n  node: ParagraphNode\n}> = createCommand('ENABLE_SLASH_MENU_COMMAND')\n\nexport function LexicalTypeaheadMenuPlugin({\n  anchorClassName,\n  anchorElem,\n  groups,\n  menuRenderFn,\n  onClose,\n  onOpen,\n  onQueryChange,\n  onSelectItem,\n  triggerFn,\n}: TypeaheadMenuPluginProps): JSX.Element | null {\n  const [editor] = useLexicalComposerContext()\n  const [resolution, setResolution] = useState<MenuResolution | null>(null)\n  const anchorElementRef = useMenuAnchorRef(anchorElem, resolution, setResolution, anchorClassName)\n\n  const closeTypeahead = useCallback(() => {\n    setResolution(null)\n    if (onClose != null && resolution !== null) {\n      onClose()\n    }\n  }, [onClose, resolution])\n\n  const openTypeahead = useCallback(\n    (res: MenuResolution) => {\n      setResolution(res)\n      if (onOpen != null && resolution === null) {\n        onOpen(res)\n      }\n    },\n    [onOpen, resolution],\n  )\n\n  // This is mainly used for the AddBlockHandlePlugin, so that the slash menu can be opened from there\n  useEffect(() => {\n    return mergeRegister(\n      editor.registerCommand(\n        ENABLE_SLASH_MENU_COMMAND,\n        ({ node }) => {\n          editor.getEditorState().read(() => {\n            const match: MenuTextMatch = {\n              leadOffset: 0,\n              matchingString: '',\n              replaceableString: '',\n            }\n            if (match !== null && !isSelectionOnEntityBoundary(editor, match.leadOffset)) {\n              if (node !== null) {\n                const editorWindow = editor._window ?? window\n                const range = editorWindow.document.createRange()\n\n                const isRangePositioned = tryToPositionRange(match.leadOffset, range, editorWindow)\n                if (isRangePositioned !== null) {\n                  startTransition(() =>\n                    openTypeahead({\n                      getRect: () => {\n                        return range.getBoundingClientRect()\n                      },\n                      match,\n                    }),\n                  )\n                }\n\n                return\n              }\n            }\n          })\n\n          return true\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n    )\n  }, [editor, openTypeahead])\n\n  useEffect(() => {\n    const updateListener = () => {\n      editor.getEditorState().read(() => {\n        const editorWindow = editor._window ?? window\n        const range = editorWindow.document.createRange()\n        const selection = $getSelection()\n        const text = getQueryTextForSearch(editor)\n\n        if (\n          !$isRangeSelection(selection) ||\n          !selection.isCollapsed() ||\n          text === null ||\n          range === null\n        ) {\n          closeTypeahead()\n          return\n        }\n\n        const match = triggerFn({ editor, query: text })\n        onQueryChange(match ? match.matchingString : null)\n\n        if (match !== null && !isSelectionOnEntityBoundary(editor, match.leadOffset)) {\n          const isRangePositioned = tryToPositionRange(match.leadOffset, range, editorWindow)\n          if (isRangePositioned !== null) {\n            startTransition(() =>\n              openTypeahead({\n                getRect: () => {\n                  return range.getBoundingClientRect()\n                },\n                match,\n              }),\n            )\n            return\n          }\n        }\n        closeTypeahead()\n      })\n    }\n\n    const removeUpdateListener = editor.registerUpdateListener(updateListener)\n\n    return () => {\n      removeUpdateListener()\n    }\n  }, [editor, triggerFn, onQueryChange, resolution, closeTypeahead, openTypeahead])\n\n  return resolution === null || editor === null ? null : (\n    <LexicalMenu\n      anchorElementRef={anchorElementRef}\n      close={closeTypeahead}\n      editor={editor}\n      groups={groups}\n      menuRenderFn={menuRenderFn}\n      onSelectItem={onSelectItem}\n      resolution={resolution}\n      shouldSplitNodeWithQuery\n    />\n  )\n}\n\nexport type { MenuRenderFn, MenuResolution, MenuTextMatch, TriggerFn }\n"],"names":["useLexicalComposerContext","mergeRegister","$getSelection","$isRangeSelection","$isTextNode","COMMAND_PRIORITY_LOW","createCommand","useCallback","useEffect","useState","React","LexicalMenu","useMenuAnchorRef","PUNCTUATION","getTextUpToAnchor","selection","anchor","type","anchorNode","getNode","isSimpleText","anchorOffset","offset","getTextContent","slice","tryToPositionRange","leadOffset","range","editorWindow","domSelection","getSelection","isCollapsed","startOffset","endOffset","setStart","setEnd","error","getQueryTextForSearch","editor","text","getEditorState","read","isSelectionOnEntityBoundary","prevSibling","getPreviousSibling","isTextEntity","startTransition","callback","getScrollParent","element","includeHidden","style","getComputedStyle","excludeStaticParent","position","overflowRegex","document","body","parent","parentElement","test","overflow","overflowY","overflowX","useDynamicPositioning","ENABLE_SLASH_MENU_COMMAND","LexicalTypeaheadMenuPlugin","anchorClassName","anchorElem","groups","menuRenderFn","onClose","onOpen","onQueryChange","onSelectItem","triggerFn","resolution","setResolution","anchorElementRef","closeTypeahead","openTypeahead","res","registerCommand","node","match","matchingString","replaceableString","_window","window","createRange","isRangePositioned","getRect","getBoundingClientRect","updateListener","query","removeUpdateListener","registerUpdateListener","close","shouldSplitNodeWithQuery"],"mappings":"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"}
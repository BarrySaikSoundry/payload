{"version":3,"sources":["../../../../../src/lexical/plugins/SlashMenu/LexicalTypeaheadMenuPlugin/LexicalMenu.tsx"],"sourcesContent":["'use client'\nimport type { LexicalCommand, LexicalEditor, TextNode } from 'lexical'\nimport type { JSX, MutableRefObject, ReactPortal } from 'react'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { mergeRegister } from '@lexical/utils'\nimport {\n  $getSelection,\n  $isRangeSelection,\n  COMMAND_PRIORITY_LOW,\n  KEY_ARROW_DOWN_COMMAND,\n  KEY_ARROW_UP_COMMAND,\n  KEY_ENTER_COMMAND,\n  KEY_ESCAPE_COMMAND,\n  KEY_TAB_COMMAND,\n  createCommand,\n} from 'lexical'\nimport { useCallback, useEffect, useLayoutEffect, useMemo, useRef, useState } from 'react'\n\nimport type { MenuTextMatch } from '../useMenuTriggerMatch.js'\nimport type { SlashMenuGroupInternal, SlashMenuItem, SlashMenuItemInternal } from './types.js'\n\nexport type MenuResolution = {\n  getRect: () => DOMRect\n  match?: MenuTextMatch\n}\n\nconst baseClass = 'slash-menu-popup'\n\nexport type MenuRenderFn = (\n  anchorElementRef: MutableRefObject<HTMLElement | null>,\n  itemProps: {\n    groups: Array<SlashMenuGroupInternal>\n    selectItemAndCleanUp: (selectedItem: SlashMenuItem) => void\n    selectedItemKey: null | string\n    setSelectedItemKey: (itemKey: string) => void\n  },\n  matchingString: null | string,\n) => JSX.Element | ReactPortal | null\n\nconst scrollIntoViewIfNeeded = (target: HTMLElement) => {\n  const typeaheadContainerNode = document.getElementById('slash-menu')\n  if (!typeaheadContainerNode) return\n\n  const typeaheadRect = typeaheadContainerNode.getBoundingClientRect()\n\n  if (typeaheadRect.top + typeaheadRect.height > window.innerHeight) {\n    typeaheadContainerNode.scrollIntoView({\n      block: 'center',\n    })\n  }\n\n  if (typeaheadRect.top < 0) {\n    typeaheadContainerNode.scrollIntoView({\n      block: 'center',\n    })\n  }\n\n  target.scrollIntoView({ block: 'nearest' })\n}\n\n/**\n * Walk backwards along user input and forward through entity title to try\n * and replace more of the user's text with entity.\n */\nfunction getFullMatchOffset(documentText: string, entryText: string, offset: number) {\n  let triggerOffset = offset\n  for (let i = triggerOffset; i <= entryText.length; i++) {\n    if (documentText.substring(documentText.length - i) === entryText.substring(0, i)) {\n      triggerOffset = i\n    }\n  }\n  return triggerOffset\n}\n\n/**\n * Split Lexical TextNode and return a new TextNode only containing matched text.\n * Common use cases include: removing the node, replacing with a new node.\n */\nfunction $splitNodeContainingQuery(match: MenuTextMatch): TextNode | null {\n  const selection = $getSelection()\n  if (!$isRangeSelection(selection) || !selection.isCollapsed()) {\n    return null\n  }\n  const anchor = selection.anchor\n  if (anchor.type !== 'text') {\n    return null\n  }\n  const anchorNode = anchor.getNode()\n  if (!anchorNode.isSimpleText()) {\n    return null\n  }\n  const selectionOffset = anchor.offset\n  const textContent = anchorNode.getTextContent().slice(0, selectionOffset)\n  const characterOffset = match.replaceableString.length\n  const queryOffset = getFullMatchOffset(textContent, match.matchingString, characterOffset)\n  const startOffset = selectionOffset - queryOffset\n  if (startOffset < 0) {\n    return null\n  }\n  let newNode\n  if (startOffset === 0) {\n    ;[newNode] = anchorNode.splitText(selectionOffset)\n  } else {\n    ;[, newNode] = anchorNode.splitText(startOffset, selectionOffset)\n  }\n\n  return newNode\n}\n\n// Got from https://stackoverflow.com/a/42543908/2013580\nexport function getScrollParent(\n  element: HTMLElement,\n  includeHidden: boolean,\n): HTMLBodyElement | HTMLElement {\n  let style = getComputedStyle(element)\n  const excludeStaticParent = style.position === 'absolute'\n  const overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/\n  if (style.position === 'fixed') {\n    return document.body\n  }\n  for (let parent: HTMLElement | null = element; (parent = parent.parentElement); ) {\n    style = getComputedStyle(parent)\n    if (excludeStaticParent && style.position === 'static') {\n      continue\n    }\n    if (overflowRegex.test(style.overflow + style.overflowY + style.overflowX)) {\n      return parent\n    }\n  }\n  return document.body\n}\n\nfunction isTriggerVisibleInNearestScrollContainer(\n  targetElement: HTMLElement,\n  containerElement: HTMLElement,\n): boolean {\n  const tRect = targetElement.getBoundingClientRect()\n  const cRect = containerElement.getBoundingClientRect()\n  return tRect.top > cRect.top && tRect.top < cRect.bottom\n}\n\n// Reposition the menu on scroll, window resize, and element resize.\nexport function useDynamicPositioning(\n  resolution: MenuResolution | null,\n  targetElement: HTMLElement | null,\n  onReposition: () => void,\n  onVisibilityChange?: (isInView: boolean) => void,\n) {\n  const [editor] = useLexicalComposerContext()\n  useEffect(() => {\n    if (targetElement != null && resolution != null) {\n      const rootElement = editor.getRootElement()\n      const rootScrollParent =\n        rootElement != null ? getScrollParent(rootElement, false) : document.body\n      let ticking = false\n      let previousIsInView = isTriggerVisibleInNearestScrollContainer(\n        targetElement,\n        rootScrollParent,\n      )\n      const handleScroll = function () {\n        if (!ticking) {\n          window.requestAnimationFrame(function () {\n            onReposition()\n            ticking = false\n          })\n          ticking = true\n        }\n        const isInView = isTriggerVisibleInNearestScrollContainer(targetElement, rootScrollParent)\n        if (isInView !== previousIsInView) {\n          previousIsInView = isInView\n          if (onVisibilityChange != null) {\n            onVisibilityChange(isInView)\n          }\n        }\n      }\n      const resizeObserver = new ResizeObserver(onReposition)\n      window.addEventListener('resize', onReposition)\n      document.addEventListener('scroll', handleScroll, {\n        capture: true,\n        passive: true,\n      })\n      resizeObserver.observe(targetElement)\n      return () => {\n        resizeObserver.unobserve(targetElement)\n        window.removeEventListener('resize', onReposition)\n        document.removeEventListener('scroll', handleScroll, true)\n      }\n    }\n  }, [targetElement, editor, onVisibilityChange, onReposition, resolution])\n}\n\nexport const SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND: LexicalCommand<{\n  index: number\n  item: SlashMenuItemInternal\n}> = createCommand('SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND')\n\nexport function LexicalMenu({\n  anchorElementRef,\n  close,\n  editor,\n  // groups filtering is already handled in SlashMenu/index.tsx. Thus, groups always contains the matching items.\n  groups,\n  menuRenderFn,\n  onSelectItem,\n  resolution,\n  shouldSplitNodeWithQuery = false,\n}: {\n  anchorElementRef: MutableRefObject<HTMLElement>\n  close: () => void\n  editor: LexicalEditor\n  groups: Array<SlashMenuGroupInternal>\n  menuRenderFn: MenuRenderFn\n  onSelectItem: (\n    item: SlashMenuItem,\n    textNodeContainingQuery: TextNode | null,\n    closeMenu: () => void,\n    matchingString: string,\n  ) => void\n  resolution: MenuResolution\n  shouldSplitNodeWithQuery?: boolean\n}): JSX.Element | null {\n  const [selectedItemKey, setSelectedItemKey] = useState<null | string>(null)\n\n  const matchingString = (resolution.match && resolution.match.matchingString) || ''\n\n  const updateSelectedItem = useCallback(\n    (item: SlashMenuItem) => {\n      const rootElem = editor.getRootElement()\n      if (rootElem !== null) {\n        rootElem.setAttribute('aria-activedescendant', `${baseClass}__item-${item.key}`)\n        setSelectedItemKey(item.key)\n      }\n    },\n    [editor],\n  )\n\n  const setSelectedItemKeyToFirstMatchingItem = useCallback(() => {\n    // set selected item to the first of the matching ones\n    if (groups !== null && matchingString != null) {\n      // groups filtering is already handled in SlashMenu/index.tsx. Thus, groups always contains the matching items.\n      const allItems = groups.flatMap((group) => group.items)\n\n      if (allItems.length) {\n        const firstMatchingItem = allItems[0]\n        updateSelectedItem(firstMatchingItem)\n      }\n    }\n  }, [groups, updateSelectedItem, matchingString])\n\n  useEffect(() => {\n    setSelectedItemKeyToFirstMatchingItem()\n  }, [matchingString, setSelectedItemKeyToFirstMatchingItem])\n\n  const selectItemAndCleanUp = useCallback(\n    (selectedItem: SlashMenuItem) => {\n      editor.update(() => {\n        const textNodeContainingQuery =\n          resolution.match != null && shouldSplitNodeWithQuery\n            ? $splitNodeContainingQuery(resolution.match)\n            : null\n\n        onSelectItem(\n          selectedItem,\n          textNodeContainingQuery,\n          close,\n          resolution.match ? resolution.match.matchingString : '',\n        )\n      })\n    },\n    [editor, shouldSplitNodeWithQuery, resolution.match, onSelectItem, close],\n  )\n\n  useEffect(() => {\n    return () => {\n      const rootElem = editor.getRootElement()\n      if (rootElem !== null) {\n        rootElem.removeAttribute('aria-activedescendant')\n      }\n    }\n  }, [editor])\n\n  useLayoutEffect(() => {\n    if (groups === null) {\n      setSelectedItemKey(null)\n    } else if (selectedItemKey === null) {\n      setSelectedItemKeyToFirstMatchingItem()\n    }\n  }, [groups, selectedItemKey, updateSelectedItem, setSelectedItemKeyToFirstMatchingItem])\n\n  useEffect(() => {\n    return mergeRegister(\n      editor.registerCommand(\n        SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND,\n        ({ item }) => {\n          if (item.ref && item.ref.current != null) {\n            scrollIntoViewIfNeeded(item.ref.current)\n            return true\n          }\n\n          return false\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n    )\n  }, [editor, updateSelectedItem])\n\n  useEffect(() => {\n    return mergeRegister(\n      editor.registerCommand<KeyboardEvent>(\n        KEY_ARROW_DOWN_COMMAND,\n        (payload) => {\n          const event = payload\n          if (groups !== null && groups.length && selectedItemKey !== null) {\n            const allItems = groups.flatMap((group) => group.items)\n            const selectedIndex = allItems.findIndex((item) => item.key === selectedItemKey)\n\n            const newSelectedIndex = selectedIndex !== allItems.length - 1 ? selectedIndex + 1 : 0\n\n            const newSelectedItem = allItems[newSelectedIndex]\n\n            updateSelectedItem(newSelectedItem)\n            if (newSelectedItem.ref != null && newSelectedItem.ref.current) {\n              editor.dispatchCommand(SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND, {\n                index: newSelectedIndex,\n                item: newSelectedItem,\n              })\n            }\n            event.preventDefault()\n            event.stopImmediatePropagation()\n          }\n          return true\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n      editor.registerCommand<KeyboardEvent>(\n        KEY_ARROW_UP_COMMAND,\n        (payload) => {\n          const event = payload\n          if (groups !== null && groups.length && selectedItemKey !== null) {\n            const allItems = groups.flatMap((group) => group.items)\n            const selectedIndex = allItems.findIndex((item) => item.key === selectedItemKey)\n\n            const newSelectedIndex = selectedIndex !== 0 ? selectedIndex - 1 : allItems.length - 1\n\n            const newSelectedItem = allItems[newSelectedIndex]\n\n            updateSelectedItem(newSelectedItem)\n            if (newSelectedItem.ref != null && newSelectedItem.ref.current) {\n              scrollIntoViewIfNeeded(newSelectedItem.ref.current)\n            }\n            event.preventDefault()\n            event.stopImmediatePropagation()\n          }\n          return true\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n      editor.registerCommand<KeyboardEvent>(\n        KEY_ESCAPE_COMMAND,\n        (payload) => {\n          const event = payload\n          event.preventDefault()\n          event.stopImmediatePropagation()\n          close()\n          return true\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n      editor.registerCommand<KeyboardEvent>(\n        KEY_TAB_COMMAND,\n        (payload) => {\n          const event = payload\n\n          if (groups === null || selectedItemKey === null) {\n            return false\n          }\n          const allItems = groups.flatMap((group) => group.items)\n          const selectedItem = allItems.find((item) => item.key === selectedItemKey)\n          if (!selectedItem) {\n            return false\n          }\n\n          event.preventDefault()\n          event.stopImmediatePropagation()\n          selectItemAndCleanUp(selectedItem)\n          return true\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n      editor.registerCommand(\n        KEY_ENTER_COMMAND,\n        (event: KeyboardEvent | null) => {\n          if (groups === null || selectedItemKey === null) {\n            return false\n          }\n          const allItems = groups.flatMap((group) => group.items)\n          const selectedItem = allItems.find((item) => item.key === selectedItemKey)\n          if (!selectedItem) {\n            return false\n          }\n\n          if (event !== null) {\n            event.preventDefault()\n            event.stopImmediatePropagation()\n          }\n          selectItemAndCleanUp(selectedItem)\n          return true\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n    )\n  }, [selectItemAndCleanUp, close, editor, groups, selectedItemKey, updateSelectedItem])\n\n  const listItemProps = useMemo(\n    () => ({\n      groups,\n      selectItemAndCleanUp,\n      selectedItemKey,\n      setSelectedItemKey,\n    }),\n    [selectItemAndCleanUp, selectedItemKey, groups],\n  )\n\n  return menuRenderFn(\n    anchorElementRef,\n    listItemProps,\n    resolution.match ? resolution.match.matchingString : '',\n  )\n}\n\nexport function useMenuAnchorRef(\n  anchorElem: HTMLElement,\n  resolution: MenuResolution | null,\n  setResolution: (r: MenuResolution | null) => void,\n  className?: string,\n): MutableRefObject<HTMLElement> {\n  const [editor] = useLexicalComposerContext()\n  const anchorElementRef = useRef<HTMLElement>(document.createElement('div'))\n  const positionMenu = useCallback(() => {\n    const rootElement = editor.getRootElement()\n    const containerDiv = anchorElementRef.current\n\n    const VERTICAL_OFFSET = 32\n\n    const menuEle = containerDiv.firstChild as Element\n    if (rootElement !== null && resolution !== null) {\n      const { height, width } = resolution.getRect()\n      let { left, top } = resolution.getRect()\n\n      const rawTop = top\n      top -= anchorElem.getBoundingClientRect().top + window.scrollY\n      left -= anchorElem.getBoundingClientRect().left + window.scrollX\n      containerDiv.style.left = `${left + window.scrollX}px`\n      containerDiv.style.height = `${height}px`\n      containerDiv.style.width = `${width}px`\n      if (menuEle !== null) {\n        const menuRect = menuEle.getBoundingClientRect()\n        const menuHeight = menuRect.height\n        const menuWidth = menuRect.width\n\n        const rootElementRect = rootElement.getBoundingClientRect()\n\n        if (left + menuWidth > rootElementRect.right) {\n          containerDiv.style.left = `${rootElementRect.right - menuWidth + window.scrollX}px`\n        }\n\n        const wouldGoOffBottomOfScreen = rawTop + menuHeight + VERTICAL_OFFSET > window.innerHeight\n        //const wouldGoOffBottomOfContainer = top + menuHeight > rootElementRect.bottom\n        const wouldGoOffTopOfScreen = rawTop < 0\n\n        // Position slash menu above the cursor instead of below (default) if it would otherwise go off the bottom of the screen.\n        if (wouldGoOffBottomOfScreen && !wouldGoOffTopOfScreen) {\n          const margin = 24\n          containerDiv.style.top = `${\n            top + VERTICAL_OFFSET - menuHeight + window.scrollY - (height + margin)\n          }px`\n        } else {\n          containerDiv.style.top = `${top + window.scrollY + VERTICAL_OFFSET}px`\n        }\n      }\n\n      if (!containerDiv.isConnected) {\n        if (className != null) {\n          containerDiv.className = className\n        }\n        containerDiv.setAttribute('aria-label', 'Slash menu')\n        containerDiv.setAttribute('id', 'slash-menu')\n        containerDiv.setAttribute('role', 'listbox')\n        containerDiv.style.display = 'block'\n        containerDiv.style.position = 'absolute'\n        anchorElem.append(containerDiv)\n      }\n      anchorElementRef.current = containerDiv\n      rootElement.setAttribute('aria-controls', 'slash-menu')\n    }\n  }, [editor, resolution, className, anchorElem])\n\n  useEffect(() => {\n    const rootElement = editor.getRootElement()\n    if (resolution !== null) {\n      positionMenu()\n      return () => {\n        if (rootElement !== null) {\n          rootElement.removeAttribute('aria-controls')\n        }\n\n        const containerDiv = anchorElementRef.current\n        if (containerDiv !== null && containerDiv.isConnected) {\n          containerDiv.remove()\n        }\n      }\n    }\n  }, [editor, positionMenu, resolution])\n\n  const onVisibilityChange = useCallback(\n    (isInView: boolean) => {\n      if (resolution !== null) {\n        if (!isInView) {\n          setResolution(null)\n        }\n      }\n    },\n    [resolution, setResolution],\n  )\n\n  useDynamicPositioning(resolution, anchorElementRef.current, positionMenu, onVisibilityChange)\n\n  return anchorElementRef\n}\n"],"names":["useLexicalComposerContext","mergeRegister","$getSelection","$isRangeSelection","COMMAND_PRIORITY_LOW","KEY_ARROW_DOWN_COMMAND","KEY_ARROW_UP_COMMAND","KEY_ENTER_COMMAND","KEY_ESCAPE_COMMAND","KEY_TAB_COMMAND","createCommand","useCallback","useEffect","useLayoutEffect","useMemo","useRef","useState","baseClass","scrollIntoViewIfNeeded","target","typeaheadContainerNode","document","getElementById","typeaheadRect","getBoundingClientRect","top","height","window","innerHeight","scrollIntoView","block","getFullMatchOffset","documentText","entryText","offset","triggerOffset","i","length","substring","$splitNodeContainingQuery","match","selection","isCollapsed","anchor","type","anchorNode","getNode","isSimpleText","selectionOffset","textContent","getTextContent","slice","characterOffset","replaceableString","queryOffset","matchingString","startOffset","newNode","splitText","getScrollParent","element","includeHidden","style","getComputedStyle","excludeStaticParent","position","overflowRegex","body","parent","parentElement","test","overflow","overflowY","overflowX","isTriggerVisibleInNearestScrollContainer","targetElement","containerElement","tRect","cRect","bottom","useDynamicPositioning","resolution","onReposition","onVisibilityChange","editor","rootElement","getRootElement","rootScrollParent","ticking","previousIsInView","handleScroll","requestAnimationFrame","isInView","resizeObserver","ResizeObserver","addEventListener","capture","passive","observe","unobserve","removeEventListener","SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND","LexicalMenu","anchorElementRef","close","groups","menuRenderFn","onSelectItem","shouldSplitNodeWithQuery","selectedItemKey","setSelectedItemKey","updateSelectedItem","item","rootElem","setAttribute","key","setSelectedItemKeyToFirstMatchingItem","allItems","flatMap","group","items","firstMatchingItem","selectItemAndCleanUp","selectedItem","update","textNodeContainingQuery","removeAttribute","registerCommand","ref","current","payload","event","selectedIndex","findIndex","newSelectedIndex","newSelectedItem","dispatchCommand","index","preventDefault","stopImmediatePropagation","find","listItemProps","useMenuAnchorRef","anchorElem","setResolution","className","createElement","positionMenu","containerDiv","VERTICAL_OFFSET","menuEle","firstChild","width","getRect","left","rawTop","scrollY","scrollX","menuRect","menuHeight","menuWidth","rootElementRect","right","wouldGoOffBottomOfScreen","wouldGoOffTopOfScreen","margin","isConnected","display","append","remove"],"mappings":"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"}
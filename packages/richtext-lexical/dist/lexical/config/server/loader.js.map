{"version":3,"sources":["../../../../src/lexical/config/server/loader.ts"],"sourcesContent":["import type { SanitizedConfig } from 'payload'\n\nimport type {\n  FeatureProviderServer,\n  ResolvedServerFeatureMap,\n  ServerFeatureProviderMap,\n} from '../../../features/typesServer.js'\nimport type { ServerEditorConfig } from '../types.js'\n\ntype DependencyGraph = {\n  [key: string]: {\n    dependencies: string[]\n    dependenciesPriority: string[]\n    dependenciesSoft: string[]\n    featureProvider: FeatureProviderServer<unknown, unknown, unknown>\n  }\n}\n\nfunction createDependencyGraph(\n  featureProviders: FeatureProviderServer<unknown, unknown, unknown>[],\n): DependencyGraph {\n  const graph: DependencyGraph = {}\n  for (const fp of featureProviders) {\n    graph[fp.key] = {\n      dependencies: fp.dependencies || [],\n      dependenciesPriority: fp.dependenciesPriority || [],\n      dependenciesSoft: fp.dependenciesSoft || [],\n      featureProvider: fp,\n    }\n  }\n  return graph\n}\n\nfunction topologicallySortFeatures(\n  featureProviders: FeatureProviderServer<unknown, unknown, unknown>[],\n): FeatureProviderServer<unknown, unknown, unknown>[] {\n  const graph = createDependencyGraph(featureProviders)\n  const visited: { [key: string]: boolean } = {}\n  const stack: FeatureProviderServer<unknown, unknown, unknown>[] = []\n\n  for (const key in graph) {\n    if (!visited[key]) {\n      visit(graph, key, visited, stack)\n    }\n  }\n\n  return stack.reverse()\n}\n\nfunction visit(\n  graph: DependencyGraph,\n  key: string,\n  visited: { [key: string]: boolean },\n  stack: FeatureProviderServer<unknown, unknown, unknown>[],\n  currentPath: string[] = [],\n) {\n  if (!graph[key]) {\n    throw new Error(`Feature key ${key} is not present in the dependency graph.`)\n  }\n\n  if (currentPath.includes(key)) {\n    throw new Error(`Circular dependency detected: ${currentPath.join(' -> ')} -> ${key}`)\n  }\n\n  if (visited[key]) {\n    return\n  }\n\n  visited[key] = true\n  currentPath.push(key)\n\n  // First process the hard priority dependencies\n  for (const dep of graph[key].dependenciesPriority) {\n    if (!visited[dep]) {\n      visit(graph, dep, visited, stack, currentPath)\n    }\n  }\n\n  // Then process the normal dependencies, but make sure to not violate hard dependencies\n  for (const dep of graph[key].dependencies) {\n    if (!visited[dep] && !graph[key].dependenciesPriority.includes(dep)) {\n      visit(graph, dep, visited, stack, currentPath)\n    }\n  }\n\n  // Then process the soft dependencies. Make sure to not violate hard and normal dependencies.\n  for (const dep of graph[key].dependenciesSoft) {\n    if (\n      graph[dep] &&\n      !visited[dep] &&\n      !graph[key].dependenciesPriority.includes(dep) &&\n      !graph[key].dependencies.includes(dep)\n    ) {\n      visit(graph, dep, visited, stack, currentPath)\n    }\n  }\n\n  stack.push(graph[key].featureProvider)\n  currentPath.pop()\n}\n\nexport function sortFeaturesForOptimalLoading(\n  featureProviders: FeatureProviderServer<unknown, unknown, unknown>[],\n): FeatureProviderServer<unknown, unknown, unknown>[] {\n  return topologicallySortFeatures(featureProviders)\n}\n\nexport async function loadFeatures({\n  config,\n  isRoot,\n  unSanitizedEditorConfig,\n}: {\n  config: SanitizedConfig\n  isRoot?: boolean\n  unSanitizedEditorConfig: ServerEditorConfig\n}): Promise<ResolvedServerFeatureMap> {\n  // First remove all duplicate features. The LAST feature with a given key wins.\n  unSanitizedEditorConfig.features = unSanitizedEditorConfig.features\n    .reverse()\n    .filter((f, i, arr) => {\n      const firstIndex = arr.findIndex((f2) => f2.key === f.key)\n      return firstIndex === i\n    })\n    .reverse()\n\n  unSanitizedEditorConfig.features = sortFeaturesForOptimalLoading(unSanitizedEditorConfig.features)\n\n  const featureProviderMap: ServerFeatureProviderMap = new Map(\n    unSanitizedEditorConfig.features.map(\n      (f) => [f.key, f] as [string, FeatureProviderServer<unknown, unknown, unknown>],\n    ),\n  )\n\n  const resolvedFeatures: ResolvedServerFeatureMap = new Map()\n\n  // Make sure all dependencies declared in the respective features exist\n  let loaded = 0\n  for (const featureProvider of unSanitizedEditorConfig.features) {\n    if (!featureProvider.key) {\n      throw new Error(\n        `A Feature you've added does not have a key. Please add a key to the feature. This is used to uniquely identify the feature.`,\n      )\n    }\n    if (featureProvider.dependencies?.length) {\n      for (const dependencyKey of featureProvider.dependencies) {\n        const found = unSanitizedEditorConfig.features.find((f) => f.key === dependencyKey)\n        if (!found) {\n          throw new Error(\n            `Feature ${featureProvider.key} has a dependency ${dependencyKey} which does not exist.`,\n          )\n        }\n      }\n    }\n\n    if (featureProvider.dependenciesPriority?.length) {\n      for (const priorityDependencyKey of featureProvider.dependenciesPriority) {\n        // look in the resolved features instead of the editorConfig.features, as a dependency requires the feature to be loaded before it, contrary to a soft-dependency\n        const found = resolvedFeatures.get(priorityDependencyKey)\n        if (!found) {\n          const existsInEditorConfig = unSanitizedEditorConfig.features.find(\n            (f) => f.key === priorityDependencyKey,\n          )\n          if (!existsInEditorConfig) {\n            throw new Error(\n              `Feature ${featureProvider.key} has a priority dependency ${priorityDependencyKey} which does not exist.`,\n            )\n          } else {\n            throw new Error(\n              `Feature ${featureProvider.key} has a priority dependency ${priorityDependencyKey} which is not loaded before it.`,\n            )\n          }\n        }\n      }\n    }\n\n    const feature =\n      typeof featureProvider.feature === 'function'\n        ? await featureProvider.feature({\n            config,\n            featureProviderMap,\n            isRoot,\n            resolvedFeatures,\n            unSanitizedEditorConfig,\n          })\n        : featureProvider.feature\n    resolvedFeatures.set(featureProvider.key, {\n      ...feature,\n      dependencies: featureProvider.dependencies,\n      dependenciesPriority: featureProvider.dependenciesPriority,\n      dependenciesSoft: featureProvider.dependenciesSoft,\n      key: featureProvider.key,\n      order: loaded,\n    })\n\n    loaded++\n  }\n\n  return resolvedFeatures\n}\n"],"names":["createDependencyGraph","featureProviders","graph","fp","key","dependencies","dependenciesPriority","dependenciesSoft","featureProvider","topologicallySortFeatures","visited","stack","visit","reverse","currentPath","Error","includes","join","push","dep","pop","sortFeaturesForOptimalLoading","loadFeatures","config","isRoot","unSanitizedEditorConfig","features","filter","f","i","arr","firstIndex","findIndex","f2","featureProviderMap","Map","map","resolvedFeatures","loaded","length","dependencyKey","found","find","priorityDependencyKey","get","existsInEditorConfig","feature","set","order"],"mappings":"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"}
{"version":3,"sources":["../../../src/utilities/upgradeLexicalData/upgradeDocumentFieldsRecursively.ts"],"sourcesContent":["import type { SerializedEditorState } from 'lexical'\nimport type { Field } from 'payload'\n\nimport { createHeadlessEditor } from '@lexical/headless'\nimport { fieldAffectsData, fieldHasSubFields, fieldIsArrayType, tabHasName } from 'payload/shared'\n\nimport type { LexicalRichTextAdapter } from '../../types.js'\n\nimport { getEnabledNodes } from '../../lexical/nodes/index.js'\n\ntype NestedRichTextFieldsArgs = {\n  data: unknown\n\n  fields: Field[]\n  found: number\n}\n\nexport const upgradeDocumentFieldsRecursively = ({\n  data,\n  fields,\n  found,\n}: NestedRichTextFieldsArgs): number => {\n  for (const field of fields) {\n    if (fieldHasSubFields(field) && !fieldIsArrayType(field)) {\n      if (fieldAffectsData(field) && typeof data[field.name] === 'object') {\n        found += upgradeDocumentFieldsRecursively({\n          data: data[field.name],\n          fields: field.fields,\n          found,\n        })\n      } else {\n        found += upgradeDocumentFieldsRecursively({\n          data,\n          fields: field.fields,\n          found,\n        })\n      }\n    } else if (field.type === 'tabs') {\n      field.tabs.forEach((tab) => {\n        found += upgradeDocumentFieldsRecursively({\n          data: tabHasName(tab) ? data[tab.name] : data,\n          fields: tab.fields,\n          found,\n        })\n      })\n    } else if (Array.isArray(data[field.name])) {\n      if (field.type === 'blocks') {\n        data[field.name].forEach((row, i) => {\n          const block = field.blocks.find(({ slug }) => slug === row?.blockType)\n          if (block) {\n            found += upgradeDocumentFieldsRecursively({\n              data: data[field.name][i],\n              fields: block.fields,\n              found,\n            })\n          }\n        })\n      }\n\n      if (field.type === 'array') {\n        data[field.name].forEach((_, i) => {\n          found += upgradeDocumentFieldsRecursively({\n            data: data[field.name][i],\n            fields: field.fields,\n            found,\n          })\n        })\n      }\n    }\n\n    if (\n      field.type === 'richText' &&\n      data[field.name] &&\n      !Array.isArray(data[field.name]) &&\n      'root' in data[field.name]\n    ) {\n      // Lexical richText\n      const editor: LexicalRichTextAdapter = field.editor as LexicalRichTextAdapter\n      if (editor && typeof editor === 'object') {\n        if ('features' in editor && editor.features?.length) {\n          // Load lexical editor into lexical, then save it immediately\n          const editorState: SerializedEditorState = data[field.name]\n\n          const headlessEditor = createHeadlessEditor({\n            nodes: getEnabledNodes({\n              editorConfig: editor.editorConfig,\n            }),\n          })\n          headlessEditor.setEditorState(headlessEditor.parseEditorState(editorState))\n\n          // get editor state\n          data[field.name] = headlessEditor.getEditorState().toJSON()\n\n          found++\n        }\n      }\n    }\n  }\n\n  return found\n}\n"],"names":["createHeadlessEditor","fieldAffectsData","fieldHasSubFields","fieldIsArrayType","tabHasName","getEnabledNodes","upgradeDocumentFieldsRecursively","data","fields","found","field","name","type","tabs","forEach","tab","Array","isArray","row","i","block","blocks","find","slug","blockType","_","editor","features","length","editorState","headlessEditor","nodes","editorConfig","setEditorState","parseEditorState","getEditorState","toJSON"],"mappings":"AAGA,SAASA,oBAAoB,QAAQ,oBAAmB;AACxD,SAASC,gBAAgB,EAAEC,iBAAiB,EAAEC,gBAAgB,EAAEC,UAAU,QAAQ,iBAAgB;AAIlG,SAASC,eAAe,QAAQ,+BAA8B;AAS9D,OAAO,MAAMC,mCAAmC,CAAC,EAC/CC,IAAI,EACJC,MAAM,EACNC,KAAK,EACoB;IACzB,KAAK,MAAMC,SAASF,OAAQ;QAC1B,IAAIN,kBAAkBQ,UAAU,CAACP,iBAAiBO,QAAQ;YACxD,IAAIT,iBAAiBS,UAAU,OAAOH,IAAI,CAACG,MAAMC,IAAI,CAAC,KAAK,UAAU;gBACnEF,SAASH,iCAAiC;oBACxCC,MAAMA,IAAI,CAACG,MAAMC,IAAI,CAAC;oBACtBH,QAAQE,MAAMF,MAAM;oBACpBC;gBACF;YACF,OAAO;gBACLA,SAASH,iCAAiC;oBACxCC;oBACAC,QAAQE,MAAMF,MAAM;oBACpBC;gBACF;YACF;QACF,OAAO,IAAIC,MAAME,IAAI,KAAK,QAAQ;YAChCF,MAAMG,IAAI,CAACC,OAAO,CAAC,CAACC;gBAClBN,SAASH,iCAAiC;oBACxCC,MAAMH,WAAWW,OAAOR,IAAI,CAACQ,IAAIJ,IAAI,CAAC,GAAGJ;oBACzCC,QAAQO,IAAIP,MAAM;oBAClBC;gBACF;YACF;QACF,OAAO,IAAIO,MAAMC,OAAO,CAACV,IAAI,CAACG,MAAMC,IAAI,CAAC,GAAG;YAC1C,IAAID,MAAME,IAAI,KAAK,UAAU;gBAC3BL,IAAI,CAACG,MAAMC,IAAI,CAAC,CAACG,OAAO,CAAC,CAACI,KAAKC;oBAC7B,MAAMC,QAAQV,MAAMW,MAAM,CAACC,IAAI,CAAC,CAAC,EAAEC,IAAI,EAAE,GAAKA,SAASL,KAAKM;oBAC5D,IAAIJ,OAAO;wBACTX,SAASH,iCAAiC;4BACxCC,MAAMA,IAAI,CAACG,MAAMC,IAAI,CAAC,CAACQ,EAAE;4BACzBX,QAAQY,MAAMZ,MAAM;4BACpBC;wBACF;oBACF;gBACF;YACF;YAEA,IAAIC,MAAME,IAAI,KAAK,SAAS;gBAC1BL,IAAI,CAACG,MAAMC,IAAI,CAAC,CAACG,OAAO,CAAC,CAACW,GAAGN;oBAC3BV,SAASH,iCAAiC;wBACxCC,MAAMA,IAAI,CAACG,MAAMC,IAAI,CAAC,CAACQ,EAAE;wBACzBX,QAAQE,MAAMF,MAAM;wBACpBC;oBACF;gBACF;YACF;QACF;QAEA,IACEC,MAAME,IAAI,KAAK,cACfL,IAAI,CAACG,MAAMC,IAAI,CAAC,IAChB,CAACK,MAAMC,OAAO,CAACV,IAAI,CAACG,MAAMC,IAAI,CAAC,KAC/B,UAAUJ,IAAI,CAACG,MAAMC,IAAI,CAAC,EAC1B;YACA,mBAAmB;YACnB,MAAMe,SAAiChB,MAAMgB,MAAM;YACnD,IAAIA,UAAU,OAAOA,WAAW,UAAU;gBACxC,IAAI,cAAcA,UAAUA,OAAOC,QAAQ,EAAEC,QAAQ;oBACnD,6DAA6D;oBAC7D,MAAMC,cAAqCtB,IAAI,CAACG,MAAMC,IAAI,CAAC;oBAE3D,MAAMmB,iBAAiB9B,qBAAqB;wBAC1C+B,OAAO1B,gBAAgB;4BACrB2B,cAAcN,OAAOM,YAAY;wBACnC;oBACF;oBACAF,eAAeG,cAAc,CAACH,eAAeI,gBAAgB,CAACL;oBAE9D,mBAAmB;oBACnBtB,IAAI,CAACG,MAAMC,IAAI,CAAC,GAAGmB,eAAeK,cAAc,GAAGC,MAAM;oBAEzD3B;gBACF;YACF;QACF;IACF;IAEA,OAAOA;AACT,EAAC"}
{"version":3,"sources":["../../../src/utilities/migrateSlateToLexical/migrateDocumentFieldsRecursively.ts"],"sourcesContent":["import type { Field } from 'payload'\n\nimport { fieldAffectsData, fieldHasSubFields, fieldIsArrayType, tabHasName } from 'payload/shared'\n\nimport type {\n  SlateNodeConverter,\n  SlateNodeConverterProvider,\n} from '../../features/migrations/slateToLexical/converter/types.js'\nimport type { LexicalRichTextAdapter } from '../../types.js'\n\nimport { convertSlateToLexical } from '../../features/migrations/slateToLexical/converter/index.js'\n\ntype NestedRichTextFieldsArgs = {\n  data: unknown\n\n  fields: Field[]\n  found: number\n}\n\nexport const migrateDocumentFieldsRecursively = ({\n  data,\n  fields,\n  found,\n}: NestedRichTextFieldsArgs): number => {\n  for (const field of fields) {\n    if (fieldHasSubFields(field) && !fieldIsArrayType(field)) {\n      if (fieldAffectsData(field) && typeof data[field.name] === 'object') {\n        found += migrateDocumentFieldsRecursively({\n          data: data[field.name],\n          fields: field.fields,\n          found,\n        })\n      } else {\n        found += migrateDocumentFieldsRecursively({\n          data,\n          fields: field.fields,\n          found,\n        })\n      }\n    } else if (field.type === 'tabs') {\n      field.tabs.forEach((tab) => {\n        found += migrateDocumentFieldsRecursively({\n          data: tabHasName(tab) ? data[tab.name] : data,\n          fields: tab.fields,\n          found,\n        })\n      })\n    } else if (Array.isArray(data[field.name])) {\n      if (field.type === 'blocks') {\n        data[field.name].forEach((row, i) => {\n          const block = field.blocks.find(({ slug }) => slug === row?.blockType)\n          if (block) {\n            found += migrateDocumentFieldsRecursively({\n              data: data[field.name][i],\n              fields: block.fields,\n              found,\n            })\n          }\n        })\n      }\n\n      if (field.type === 'array') {\n        data[field.name].forEach((_, i) => {\n          found += migrateDocumentFieldsRecursively({\n            data: data[field.name][i],\n            fields: field.fields,\n            found,\n          })\n        })\n      }\n    }\n\n    if (field.type === 'richText' && Array.isArray(data[field.name])) {\n      // Slate richText\n      const editor: LexicalRichTextAdapter = field.editor as LexicalRichTextAdapter\n      if (editor && typeof editor === 'object') {\n        if ('features' in editor && editor.features?.length) {\n          // find slatetolexical feature\n          const slateToLexicalFeature = editor.editorConfig.resolvedFeatureMap.get('slateToLexical')\n          if (slateToLexicalFeature) {\n            // DO CONVERSION\n\n            const converterProviders = (\n              slateToLexicalFeature.sanitizedServerFeatureProps as {\n                converters?: SlateNodeConverterProvider[]\n              }\n            ).converters\n\n            const converters: SlateNodeConverter[] = []\n\n            for (const converter of converterProviders) {\n              converters.push(converter.converter)\n            }\n\n            data[field.name] = convertSlateToLexical({\n              converters,\n              slateData: data[field.name],\n            })\n\n            found++\n          }\n        }\n      }\n    }\n  }\n\n  return found\n}\n"],"names":["fieldAffectsData","fieldHasSubFields","fieldIsArrayType","tabHasName","convertSlateToLexical","migrateDocumentFieldsRecursively","data","fields","found","field","name","type","tabs","forEach","tab","Array","isArray","row","i","block","blocks","find","slug","blockType","_","editor","features","length","slateToLexicalFeature","editorConfig","resolvedFeatureMap","get","converterProviders","sanitizedServerFeatureProps","converters","converter","push","slateData"],"mappings":"AAEA,SAASA,gBAAgB,EAAEC,iBAAiB,EAAEC,gBAAgB,EAAEC,UAAU,QAAQ,iBAAgB;AAQlG,SAASC,qBAAqB,QAAQ,8DAA6D;AASnG,OAAO,MAAMC,mCAAmC,CAAC,EAC/CC,IAAI,EACJC,MAAM,EACNC,KAAK,EACoB;IACzB,KAAK,MAAMC,SAASF,OAAQ;QAC1B,IAAIN,kBAAkBQ,UAAU,CAACP,iBAAiBO,QAAQ;YACxD,IAAIT,iBAAiBS,UAAU,OAAOH,IAAI,CAACG,MAAMC,IAAI,CAAC,KAAK,UAAU;gBACnEF,SAASH,iCAAiC;oBACxCC,MAAMA,IAAI,CAACG,MAAMC,IAAI,CAAC;oBACtBH,QAAQE,MAAMF,MAAM;oBACpBC;gBACF;YACF,OAAO;gBACLA,SAASH,iCAAiC;oBACxCC;oBACAC,QAAQE,MAAMF,MAAM;oBACpBC;gBACF;YACF;QACF,OAAO,IAAIC,MAAME,IAAI,KAAK,QAAQ;YAChCF,MAAMG,IAAI,CAACC,OAAO,CAAC,CAACC;gBAClBN,SAASH,iCAAiC;oBACxCC,MAAMH,WAAWW,OAAOR,IAAI,CAACQ,IAAIJ,IAAI,CAAC,GAAGJ;oBACzCC,QAAQO,IAAIP,MAAM;oBAClBC;gBACF;YACF;QACF,OAAO,IAAIO,MAAMC,OAAO,CAACV,IAAI,CAACG,MAAMC,IAAI,CAAC,GAAG;YAC1C,IAAID,MAAME,IAAI,KAAK,UAAU;gBAC3BL,IAAI,CAACG,MAAMC,IAAI,CAAC,CAACG,OAAO,CAAC,CAACI,KAAKC;oBAC7B,MAAMC,QAAQV,MAAMW,MAAM,CAACC,IAAI,CAAC,CAAC,EAAEC,IAAI,EAAE,GAAKA,SAASL,KAAKM;oBAC5D,IAAIJ,OAAO;wBACTX,SAASH,iCAAiC;4BACxCC,MAAMA,IAAI,CAACG,MAAMC,IAAI,CAAC,CAACQ,EAAE;4BACzBX,QAAQY,MAAMZ,MAAM;4BACpBC;wBACF;oBACF;gBACF;YACF;YAEA,IAAIC,MAAME,IAAI,KAAK,SAAS;gBAC1BL,IAAI,CAACG,MAAMC,IAAI,CAAC,CAACG,OAAO,CAAC,CAACW,GAAGN;oBAC3BV,SAASH,iCAAiC;wBACxCC,MAAMA,IAAI,CAACG,MAAMC,IAAI,CAAC,CAACQ,EAAE;wBACzBX,QAAQE,MAAMF,MAAM;wBACpBC;oBACF;gBACF;YACF;QACF;QAEA,IAAIC,MAAME,IAAI,KAAK,cAAcI,MAAMC,OAAO,CAACV,IAAI,CAACG,MAAMC,IAAI,CAAC,GAAG;YAChE,iBAAiB;YACjB,MAAMe,SAAiChB,MAAMgB,MAAM;YACnD,IAAIA,UAAU,OAAOA,WAAW,UAAU;gBACxC,IAAI,cAAcA,UAAUA,OAAOC,QAAQ,EAAEC,QAAQ;oBACnD,8BAA8B;oBAC9B,MAAMC,wBAAwBH,OAAOI,YAAY,CAACC,kBAAkB,CAACC,GAAG,CAAC;oBACzE,IAAIH,uBAAuB;wBACzB,gBAAgB;wBAEhB,MAAMI,qBAAqB,AACzBJ,sBAAsBK,2BAA2B,CAGjDC,UAAU;wBAEZ,MAAMA,aAAmC,EAAE;wBAE3C,KAAK,MAAMC,aAAaH,mBAAoB;4BAC1CE,WAAWE,IAAI,CAACD,UAAUA,SAAS;wBACrC;wBAEA7B,IAAI,CAACG,MAAMC,IAAI,CAAC,GAAGN,sBAAsB;4BACvC8B;4BACAG,WAAW/B,IAAI,CAACG,MAAMC,IAAI,CAAC;wBAC7B;wBAEAF;oBACF;gBACF;YACF;QACF;IACF;IAEA,OAAOA;AACT,EAAC"}
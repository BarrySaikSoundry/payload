{"version":3,"sources":["../../src/utilities/recurseNodeTree.ts"],"sourcesContent":["import type { SerializedLexicalNode } from 'lexical'\n\n// Initialize both flattenedNodes and nodeIDMap\nexport const recurseNodeTree = ({\n  flattenedNodes,\n  nodeIDMap,\n  nodes,\n}: {\n  flattenedNodes?: SerializedLexicalNode[]\n  nodeIDMap?: {\n    [key: string]: SerializedLexicalNode\n  }\n  nodes: SerializedLexicalNode[]\n}): void => {\n  if (!nodes?.length) {\n    return\n  }\n\n  for (const node of nodes) {\n    if (flattenedNodes) {\n      flattenedNodes.push(node)\n    }\n    if (nodeIDMap) {\n      if (node && 'id' in node && node.id) {\n        nodeIDMap[node.id as string] = node\n      } else if (\n        'fields' in node &&\n        typeof node.fields === 'object' &&\n        node.fields &&\n        'id' in node.fields &&\n        node?.fields?.id\n      ) {\n        nodeIDMap[node.fields.id as string] = node\n      }\n    }\n\n    if ('children' in node && Array.isArray(node?.children) && node?.children?.length) {\n      recurseNodeTree({\n        flattenedNodes,\n        nodeIDMap,\n        nodes: node.children as SerializedLexicalNode[],\n      })\n    }\n  }\n}\n"],"names":["recurseNodeTree","flattenedNodes","nodeIDMap","nodes","length","node","push","id","fields","Array","isArray","children"],"mappings":"AAEA,+CAA+C;AAC/C,OAAO,MAAMA,kBAAkB,CAAC,EAC9BC,cAAc,EACdC,SAAS,EACTC,KAAK,EAON;IACC,IAAI,CAACA,OAAOC,QAAQ;QAClB;IACF;IAEA,KAAK,MAAMC,QAAQF,MAAO;QACxB,IAAIF,gBAAgB;YAClBA,eAAeK,IAAI,CAACD;QACtB;QACA,IAAIH,WAAW;YACb,IAAIG,QAAQ,QAAQA,QAAQA,KAAKE,EAAE,EAAE;gBACnCL,SAAS,CAACG,KAAKE,EAAE,CAAW,GAAGF;YACjC,OAAO,IACL,YAAYA,QACZ,OAAOA,KAAKG,MAAM,KAAK,YACvBH,KAAKG,MAAM,IACX,QAAQH,KAAKG,MAAM,IACnBH,MAAMG,QAAQD,IACd;gBACAL,SAAS,CAACG,KAAKG,MAAM,CAACD,EAAE,CAAW,GAAGF;YACxC;QACF;QAEA,IAAI,cAAcA,QAAQI,MAAMC,OAAO,CAACL,MAAMM,aAAaN,MAAMM,UAAUP,QAAQ;YACjFJ,gBAAgB;gBACdC;gBACAC;gBACAC,OAAOE,KAAKM,QAAQ;YACtB;QACF;IACF;AACF,EAAC"}
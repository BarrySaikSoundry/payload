{
  "version": 3,
  "sources": ["../../../src/features/horizontalRule/nodes/HorizontalRuleNode.tsx"],
  "sourcesContent": ["import type {\n  DOMConversionMap,\n  DOMConversionOutput,\n  DOMExportOutput,\n  EditorConfig,\n  LexicalCommand,\n  LexicalNode,\n  SerializedLexicalNode,\n  Spread,\n} from 'lexical'\n\nimport { addClassNamesToElement } from '@lexical/utils'\nimport { $applyNodeReplacement, DecoratorNode, createCommand } from 'lexical'\nimport * as React from 'react'\n\nconst HorizontalRuleComponent = React.lazy(() =>\n  import('../component/index.js').then((module) => ({\n    default: module.HorizontalRuleComponent,\n  })),\n)\n\n/**\n * Serialized representation of a horizontal rule node. Serialized = converted to JSON. This is what is stored in the database / in the lexical editor state.\n */\nexport type SerializedHorizontalRuleNode = Spread<\n  {\n    children?: never // required so that our typed editor state doesn't automatically add children\n    type: 'horizontalrule'\n  },\n  SerializedLexicalNode\n>\n\nexport const INSERT_HORIZONTAL_RULE_COMMAND: LexicalCommand<void> = createCommand(\n  'INSERT_HORIZONTAL_RULE_COMMAND',\n)\n\n/**\n * This node is a DecoratorNode. DecoratorNodes allow you to render React components in the editor.\n *\n * They need both createDom and decorate functions. createDom => outside of the html. decorate => React Component inside of the html.\n *\n * If we used DecoratorBlockNode instead, we would only need a decorate method\n */\nexport class HorizontalRuleNode extends DecoratorNode<React.ReactElement> {\n  static clone(node: HorizontalRuleNode): HorizontalRuleNode {\n    return new HorizontalRuleNode(node.__key)\n  }\n\n  static getType(): string {\n    return 'horizontalrule'\n  }\n\n  /**\n   * Defines what happens if you copy an hr element from another page and paste it into the lexical editor\n   *\n   * This also determines the behavior of lexical's internal HTML -> Lexical converter\n   */\n  static importDOM(): DOMConversionMap | null {\n    return {\n      hr: () => ({\n        conversion: $convertHorizontalRuleElement,\n        priority: 0,\n      }),\n    }\n  }\n\n  /**\n   * The data for this node is stored serialized as JSON. This is the \"load function\" of that node: it takes the saved data and converts it into a node.\n   */\n  static importJSON(serializedNode: SerializedHorizontalRuleNode): HorizontalRuleNode {\n    return $createHorizontalRuleNode()\n  }\n\n  /**\n   * Determines how the hr element is rendered in the lexical editor. This is only the \"initial\" / \"outer\" HTML element.\n   */\n  createDOM(config: EditorConfig): HTMLElement {\n    const element = document.createElement('hr')\n    addClassNamesToElement(element, config.theme.hr)\n    return element\n  }\n\n  /**\n   * Allows you to render a React component within whatever createDOM returns.\n   */\n  decorate(): React.ReactElement {\n    return <HorizontalRuleComponent nodeKey={this.__key} />\n  }\n\n  /**\n   * Opposite of importDOM, this function defines what happens when you copy an hr element from the lexical editor and paste it into another page.\n   *\n   * This also determines the behavior of lexical's internal Lexical -> HTML converter\n   */\n  exportDOM(): DOMExportOutput {\n    return { element: document.createElement('hr') }\n  }\n  /**\n   * Opposite of importJSON. This determines what data is saved in the database / in the lexical editor state.\n   */\n  exportJSON(): SerializedLexicalNode {\n    return {\n      type: 'horizontalrule',\n      version: 1,\n    }\n  }\n\n  getTextContent(): string {\n    return '\\n'\n  }\n\n  isInline(): false {\n    return false\n  }\n\n  updateDOM(): boolean {\n    return false\n  }\n}\n\nfunction $convertHorizontalRuleElement(): DOMConversionOutput {\n  return { node: $createHorizontalRuleNode() }\n}\n\nexport function $createHorizontalRuleNode(): HorizontalRuleNode {\n  return $applyNodeReplacement(new HorizontalRuleNode())\n}\n\nexport function $isHorizontalRuleNode(\n  node: LexicalNode | null | undefined,\n): node is HorizontalRuleNode {\n  return node instanceof HorizontalRuleNode\n}\n"],
  "mappings": "AAWA,OAAS,0BAAAA,MAA8B,iBACvC,OAAS,yBAAAC,EAAuB,iBAAAC,EAAe,iBAAAC,MAAqB,UACpE,UAAYC,MAAW,QAyEZ,cAAAC,MAAA,oBAvEX,IAAMC,EAAgC,OAAK,IACzC,OAAO,yBAAuB,EAAE,KAAMC,IAAY,CAChD,QAASA,EAAO,uBAClB,EAAE,CACJ,EAaaC,EAAuDL,EAClE,gCACF,EASaM,EAAN,MAAMC,UAA2BR,CAAkC,CACxE,OAAO,MAAMS,EAA8C,CACzD,OAAO,IAAID,EAAmBC,EAAK,KAAK,CAC1C,CAEA,OAAO,SAAkB,CACvB,MAAO,gBACT,CAOA,OAAO,WAAqC,CAC1C,MAAO,CACL,GAAI,KAAO,CACT,WAAYC,EACZ,SAAU,CACZ,EACF,CACF,CAKA,OAAO,WAAWC,EAAkE,CAClF,OAAOC,EAA0B,CACnC,CAKA,UAAUC,EAAmC,CAC3C,IAAMC,EAAU,SAAS,cAAc,IAAI,EAC3C,OAAAhB,EAAuBgB,EAASD,EAAO,MAAM,EAAE,EACxCC,CACT,CAKA,UAA+B,CAC7B,OAAOX,EAACC,EAAA,CAAwB,QAAS,KAAK,MAAO,CACvD,CAOA,WAA6B,CAC3B,MAAO,CAAE,QAAS,SAAS,cAAc,IAAI,CAAE,CACjD,CAIA,YAAoC,CAClC,MAAO,CACL,KAAM,iBACN,QAAS,CACX,CACF,CAEA,gBAAyB,CACvB,MAAO;AAAA,CACT,CAEA,UAAkB,CAChB,MAAO,EACT,CAEA,WAAqB,CACnB,MAAO,EACT,CACF,EAEA,SAASM,GAAqD,CAC5D,MAAO,CAAE,KAAME,EAA0B,CAAE,CAC7C,CAEO,SAASA,GAAgD,CAC9D,OAAOb,EAAsB,IAAIQ,CAAoB,CACvD,CAEO,SAASQ,EACdN,EAC4B,CAC5B,OAAOA,aAAgBF,CACzB",
  "names": ["addClassNamesToElement", "$applyNodeReplacement", "DecoratorNode", "createCommand", "React", "jsx", "HorizontalRuleComponent", "module", "INSERT_HORIZONTAL_RULE_COMMAND", "HorizontalRuleNode", "_HorizontalRuleNode", "node", "$convertHorizontalRuleElement", "serializedNode", "$createHorizontalRuleNode", "config", "element", "$isHorizontalRuleNode"]
}

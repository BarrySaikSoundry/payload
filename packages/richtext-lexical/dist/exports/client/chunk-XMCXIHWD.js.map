{
  "version": 3,
  "sources": ["../../../src/utilities/fieldsDrawer/Drawer.tsx", "../../../src/utilities/fieldsDrawer/DrawerContent.tsx", "../../../src/features/relationship/utils/EnabledRelationshipsCondition.tsx", "../../../src/features/upload/drawer/commands.ts", "../../../src/features/upload/nodes/UploadNode.tsx"],
  "sourcesContent": ["'use client'\nimport type { Data, FormState } from 'payload'\n\nimport { Drawer } from '@payloadcms/ui'\nimport React from 'react'\n\nimport { DrawerContent } from './DrawerContent.js'\n\nexport type FieldsDrawerProps = {\n  className?: string\n  data?: Data\n  drawerSlug: string\n  drawerTitle?: string\n  featureKey: string\n  handleDrawerSubmit: (fields: FormState, data: Record<string, unknown>) => void\n  schemaPathSuffix?: string\n}\n\n/**\n * This FieldsDrawer component can be used to easily create a Drawer that contains a form with fields within your feature.\n * The fields are taken directly from the schema map based on your `featureKey` and `schemaPathSuffix`. Thus, this can only\n * be used if you provide your field schema inside the `generateSchemaMap` prop of your feature.server.ts.\n */\nexport const FieldsDrawer: React.FC<FieldsDrawerProps> = ({\n  className,\n  data,\n  drawerSlug,\n  drawerTitle,\n  featureKey,\n  handleDrawerSubmit,\n  schemaPathSuffix,\n}) => {\n  // The Drawer only renders its children (and itself) if it's open. Thus, by extracting the main content\n  // to DrawerContent, this should be faster\n  return (\n    <Drawer className={className} slug={drawerSlug} title={drawerTitle ?? ''}>\n      <DrawerContent\n        data={data}\n        featureKey={featureKey}\n        handleDrawerSubmit={handleDrawerSubmit}\n        schemaPathSuffix={schemaPathSuffix}\n      />\n    </Drawer>\n  )\n}\n", "'use client'\nimport type { FormProps } from '@payloadcms/ui'\nimport type { FormState } from 'payload'\n\nimport {\n  Form,\n  FormSubmit,\n  RenderFields,\n  useConfig,\n  useDocumentInfo,\n  useFieldProps,\n  useTranslation,\n} from '@payloadcms/ui'\nimport { getFormState } from '@payloadcms/ui/shared'\nimport React, { useCallback, useEffect, useState } from 'react'\nimport { v4 as uuid } from 'uuid'\n\nimport type { FieldsDrawerProps } from './Drawer.js'\n\nimport { useEditorConfigContext } from '../../lexical/config/client/EditorConfigProvider.js'\n\nexport const DrawerContent: React.FC<Omit<FieldsDrawerProps, 'drawerSlug' | 'drawerTitle'>> = ({\n  data,\n  featureKey,\n  handleDrawerSubmit,\n  schemaPathSuffix,\n}) => {\n  const { t } = useTranslation()\n  const { id } = useDocumentInfo()\n  const { schemaPath } = useFieldProps()\n  const config = useConfig()\n  const [initialState, setInitialState] = useState<FormState | false>(false)\n  const {\n    field: { richTextComponentMap },\n  } = useEditorConfigContext()\n\n  const componentMapRenderedFieldsPath = `lexical_internal_feature.${featureKey}.fields${schemaPathSuffix ? `.${schemaPathSuffix}` : ''}`\n  const schemaFieldsPath = `${schemaPath}.lexical_internal_feature.${featureKey}${schemaPathSuffix ? `.${schemaPathSuffix}` : ''}`\n\n  const fieldMap = richTextComponentMap.get(componentMapRenderedFieldsPath) // Field Schema\n\n  useEffect(() => {\n    const awaitInitialState = async () => {\n      const state = await getFormState({\n        apiRoute: config.routes.api,\n        body: {\n          id,\n          data: data ?? {},\n          operation: 'update',\n          schemaPath: schemaFieldsPath,\n        },\n        serverURL: config.serverURL,\n      }) // Form State\n\n      setInitialState(state)\n    }\n\n    void awaitInitialState()\n  }, [config.routes.api, config.serverURL, schemaFieldsPath, id, data])\n\n  const onChange: FormProps['onChange'][0] = useCallback(\n    async ({ formState: prevFormState }) => {\n      return await getFormState({\n        apiRoute: config.routes.api,\n        body: {\n          id,\n          formState: prevFormState,\n          operation: 'update',\n          schemaPath: schemaFieldsPath,\n        },\n        serverURL: config.serverURL,\n      })\n    },\n\n    [config.routes.api, config.serverURL, schemaFieldsPath, id],\n  )\n\n  if (initialState === false) {\n    return null\n  }\n\n  return (\n    <Form\n      beforeSubmit={[onChange]}\n      disableValidationOnSubmit\n      fields={Array.isArray(fieldMap) ? fieldMap : []}\n      initialState={initialState}\n      onChange={[onChange]}\n      onSubmit={handleDrawerSubmit}\n      uuid={uuid()}\n    >\n      <RenderFields\n        fieldMap={Array.isArray(fieldMap) ? fieldMap : []}\n        forceRender\n        path=\"\" // See Blocks feature path for details as for why this is empty\n        readOnly={false}\n        schemaPath={schemaFieldsPath}\n      />\n\n      <FormSubmit>{t('fields:saveChanges')}</FormSubmit>\n    </Form>\n  )\n}\n", "import type { ClientCollectionConfig, ClientUser, VisibleEntities } from 'payload'\n\nimport { useAuth, useConfig, useEntityVisibility } from '@payloadcms/ui'\nimport * as React from 'react'\n\ntype Options = {\n  uploads: boolean\n  user: ClientUser\n  visibleEntities: VisibleEntities\n}\n\ntype FilteredCollectionsT = (\n  collections: ClientCollectionConfig[],\n  options?: Options,\n) => ClientCollectionConfig[]\n\nconst filterRichTextCollections: FilteredCollectionsT = (collections, options) => {\n  return collections.filter(({ slug, admin: { enableRichTextRelationship }, upload }) => {\n    if (!options.visibleEntities.collections.includes(slug)) {\n      return false\n    }\n\n    if (options?.uploads) {\n      return enableRichTextRelationship && Boolean(upload) === true\n    }\n\n    return upload ? false : enableRichTextRelationship\n  })\n}\n\nexport const EnabledRelationshipsCondition: React.FC<any> = (props) => {\n  const { children, uploads = false, ...rest } = props\n  const { collections } = useConfig()\n  const { user } = useAuth()\n  const { visibleEntities } = useEntityVisibility()\n\n  const [enabledCollectionSlugs] = React.useState(() =>\n    filterRichTextCollections(collections, { uploads, user, visibleEntities }).map(\n      ({ slug }) => slug,\n    ),\n  )\n\n  if (!enabledCollectionSlugs.length) {\n    return null\n  }\n\n  return React.cloneElement(children, { ...rest, enabledCollectionSlugs })\n}\n", "'use client'\nimport type { LexicalCommand } from 'lexical'\n\nimport { createCommand } from 'lexical'\n\nexport const INSERT_UPLOAD_WITH_DRAWER_COMMAND: LexicalCommand<{\n  replace: { nodeKey: string } | false\n}> = createCommand('INSERT_UPLOAD_WITH_DRAWER_COMMAND')\n", "import type { SerializedDecoratorBlockNode } from '@lexical/react/LexicalDecoratorBlockNode.js'\nimport type {\n  DOMConversionMap,\n  DOMConversionOutput,\n  DOMExportOutput,\n  ElementFormatType,\n  LexicalNode,\n  NodeKey,\n  Spread,\n} from 'lexical'\nimport type { CollectionSlug } from 'payload'\nimport type { JSX } from 'react'\n\nimport { DecoratorBlockNode } from '@lexical/react/LexicalDecoratorBlockNode.js'\nimport ObjectID from 'bson-objectid'\nimport { $applyNodeReplacement } from 'lexical'\nimport * as React from 'react'\n\nconst RawUploadComponent = React.lazy(() =>\n  import('../component/index.js').then((module) => ({ default: module.UploadComponent })),\n)\n\nexport type UploadData = {\n  fields: {\n    // unknown, custom fields:\n    [key: string]: unknown\n  }\n  id: string\n  relationTo: CollectionSlug\n  value: number | string\n}\n\nfunction isGoogleDocCheckboxImg(img: HTMLImageElement): boolean {\n  return (\n    img.parentElement != null &&\n    img.parentElement.tagName === 'LI' &&\n    img.previousSibling === null &&\n    img.getAttribute('aria-roledescription') === 'checkbox'\n  )\n}\n\nfunction $convertUploadElement(domNode: HTMLImageElement): DOMConversionOutput | null {\n  if (\n    domNode.hasAttribute('data-lexical-upload-relation-to') &&\n    domNode.hasAttribute('data-lexical-upload-id')\n  ) {\n    const id = domNode.getAttribute('data-lexical-upload-id')\n    const relationTo = domNode.getAttribute('data-lexical-upload-relation-to')\n\n    if (id != null && relationTo != null) {\n      const node = $createUploadNode({\n        data: {\n          fields: {},\n          relationTo,\n          value: id,\n        },\n      })\n      return { node }\n    }\n  }\n  const img = domNode\n  if (img.src.startsWith('file:///') || isGoogleDocCheckboxImg(img)) {\n    return null\n  }\n  // TODO: Auto-upload functionality here!\n  //}\n  return null\n}\n\nexport type SerializedUploadNode = {\n  children?: never // required so that our typed editor state doesn't automatically add children\n  type: 'upload'\n} & Spread<UploadData, SerializedDecoratorBlockNode>\n\nexport class UploadNode extends DecoratorBlockNode {\n  __data: UploadData\n\n  constructor({\n    data,\n    format,\n    key,\n  }: {\n    data: UploadData\n    format?: ElementFormatType\n    key?: NodeKey\n  }) {\n    super(format, key)\n    this.__data = data\n  }\n\n  static clone(node: UploadNode): UploadNode {\n    return new UploadNode({\n      data: node.__data,\n      format: node.__format,\n      key: node.__key,\n    })\n  }\n\n  static getType(): string {\n    return 'upload'\n  }\n\n  static importDOM(): DOMConversionMap | null {\n    return {\n      img: (node: HTMLImageElement) => ({\n        conversion: $convertUploadElement,\n        priority: 0,\n      }),\n    }\n  }\n\n  static importJSON(serializedNode: SerializedUploadNode): UploadNode {\n    if (serializedNode.version === 1 && (serializedNode?.value as unknown as { id: string })?.id) {\n      serializedNode.value = (serializedNode.value as unknown as { id: string }).id\n    }\n    if (serializedNode.version === 2 && !serializedNode?.id) {\n      serializedNode.id = new ObjectID.default().toHexString()\n      serializedNode.version = 3\n    }\n\n    const importedData: UploadData = {\n      id: serializedNode.id,\n      fields: serializedNode.fields,\n      relationTo: serializedNode.relationTo,\n      value: serializedNode.value,\n    }\n\n    const node = $createUploadNode({ data: importedData })\n    node.setFormat(serializedNode.format)\n\n    return node\n  }\n\n  static isInline(): false {\n    return false\n  }\n\n  decorate(): JSX.Element {\n    // @ts-expect-error\n    return <RawUploadComponent data={this.__data} format={this.__format} nodeKey={this.getKey()} />\n  }\n\n  exportDOM(): DOMExportOutput {\n    const element = document.createElement('img')\n    element.setAttribute('data-lexical-upload-id', String(this.__data?.value))\n    element.setAttribute('data-lexical-upload-relation-to', this.__data?.relationTo)\n\n    return { element }\n  }\n\n  exportJSON(): SerializedUploadNode {\n    return {\n      ...super.exportJSON(),\n      ...this.getData(),\n      type: 'upload',\n      version: 3,\n    }\n  }\n\n  getData(): UploadData {\n    return this.getLatest().__data\n  }\n\n  setData(data: UploadData): void {\n    const writable = this.getWritable()\n    writable.__data = data\n  }\n\n  updateDOM(): false {\n    return false\n  }\n}\n\nexport function $createUploadNode({\n  data,\n}: {\n  data: Omit<UploadData, 'id'> & Partial<Pick<UploadData, 'id'>>\n}): UploadNode {\n  if (!data?.id) {\n    data.id = new ObjectID.default().toHexString()\n  }\n  return $applyNodeReplacement(new UploadNode({ data: data as UploadData }))\n}\n\nexport function $isUploadNode(node: LexicalNode | null | undefined): node is UploadNode {\n  return node instanceof UploadNode\n}\n"],
  "mappings": "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",
  "names": ["Drawer", "Form", "FormSubmit", "RenderFields", "useConfig", "useDocumentInfo", "useFieldProps", "useTranslation", "getFormState", "useCallback", "useEffect", "useState", "uuid", "jsx", "jsxs", "DrawerContent", "data", "featureKey", "handleDrawerSubmit", "schemaPathSuffix", "t", "useTranslation", "id", "useDocumentInfo", "schemaPath", "useFieldProps", "config", "useConfig", "initialState", "setInitialState", "useState", "richTextComponentMap", "useEditorConfigContext", "componentMapRenderedFieldsPath", "schemaFieldsPath", "fieldMap", "useEffect", "state", "getFormState", "onChange", "useCallback", "prevFormState", "Form", "uuid", "RenderFields", "FormSubmit", "jsx", "FieldsDrawer", "className", "data", "drawerSlug", "drawerTitle", "featureKey", "handleDrawerSubmit", "schemaPathSuffix", "Drawer", "DrawerContent", "useAuth", "useConfig", "useEntityVisibility", "React", "filterRichTextCollections", "collections", "options", "slug", "enableRichTextRelationship", "upload", "EnabledRelationshipsCondition", "props", "children", "uploads", "rest", "user", "visibleEntities", "enabledCollectionSlugs", "createCommand", "INSERT_UPLOAD_WITH_DRAWER_COMMAND", "DecoratorBlockNode", "ObjectID", "$applyNodeReplacement", "React", "jsx", "RawUploadComponent", "module", "isGoogleDocCheckboxImg", "img", "$convertUploadElement", "domNode", "id", "relationTo", "$createUploadNode", "UploadNode", "_UploadNode", "data", "format", "key", "node", "serializedNode", "importedData", "element", "writable", "$isUploadNode"]
}

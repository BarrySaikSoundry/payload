{
  "version": 3,
  "sources": ["../../../src/features/blocks/component/index.tsx", "../../../src/features/blocks/component/BlockContent.tsx", "../../../src/features/blocks/component/FormSavePlugin.tsx", "../../../src/features/blocks/component/removeEmptyArrayValues.ts"],
  "sourcesContent": ["'use client'\n\nimport type { FormProps } from '@payloadcms/ui'\n\nimport {\n  Collapsible,\n  Form,\n  Pill,\n  SectionTitle,\n  ShimmerEffect,\n  useConfig,\n  useDocumentInfo,\n  useFieldProps,\n  useFormSubmitted,\n  useTranslation,\n} from '@payloadcms/ui'\nimport React, { useCallback, useEffect, useMemo, useState } from 'react'\n\nimport { type BlockFields } from '../nodes/BlocksNode.js'\nconst baseClass = 'lexical-block'\nimport type { ReducedBlock } from '@payloadcms/ui/utilities/buildComponentMap'\nimport type { FormState } from 'payload'\n\nimport { getTranslation } from '@payloadcms/translations'\nimport { getFormState } from '@payloadcms/ui/shared'\nimport { v4 as uuid } from 'uuid'\n\nimport type { ClientComponentProps } from '../../typesClient.js'\nimport type { BlocksFeatureClientProps } from '../feature.client.js'\n\nimport { useEditorConfigContext } from '../../../lexical/config/client/EditorConfigProvider.js'\nimport { BlockContent } from './BlockContent.js'\ntype Props = {\n  children?: React.ReactNode\n\n  formData: BlockFields\n  nodeKey?: string\n  /**\n   * This transformedFormData already comes wrapped in blockFieldWrapperName\n   */\n  transformedFormData: BlockFields\n}\n\nexport const BlockComponent: React.FC<Props> = (props) => {\n  const { formData, nodeKey } = props\n  const config = useConfig()\n  const submitted = useFormSubmitted()\n  const { id } = useDocumentInfo()\n  const { path, schemaPath } = useFieldProps()\n  const { editorConfig, field: parentLexicalRichTextField } = useEditorConfigContext()\n\n  const [initialState, setInitialState] = useState<FormState | false>(false)\n  const {\n    field: { richTextComponentMap },\n  } = useEditorConfigContext()\n\n  const componentMapRenderedFieldsPath = `lexical_internal_feature.blocks.fields.${formData?.blockType}`\n  const schemaFieldsPath = `${schemaPath}.lexical_internal_feature.blocks.${formData?.blockType}`\n\n  const reducedBlock: ReducedBlock = (\n    editorConfig?.resolvedFeatureMap?.get('blocks')\n      ?.sanitizedClientFeatureProps as ClientComponentProps<BlocksFeatureClientProps>\n  )?.reducedBlocks?.find((block) => block.slug === formData?.blockType)\n\n  const fieldMap = richTextComponentMap.get(componentMapRenderedFieldsPath)\n  // Field Schema\n  useEffect(() => {\n    const awaitInitialState = async () => {\n      const state = await getFormState({\n        apiRoute: config.routes.api,\n        body: {\n          id,\n          data: formData,\n          operation: 'update',\n          schemaPath: schemaFieldsPath,\n        },\n        serverURL: config.serverURL,\n      }) // Form State\n\n      if (state) {\n        setInitialState({\n          ...state,\n          blockName: {\n            initialValue: '',\n            passesCondition: true,\n            valid: true,\n            value: formData.blockName,\n          },\n        })\n      }\n    }\n\n    if (formData) {\n      void awaitInitialState()\n    }\n  }, [config.routes.api, config.serverURL, schemaFieldsPath, id])\n\n  const onChange: FormProps['onChange'][0] = useCallback(\n    async ({ formState: prevFormState }) => {\n      const formState = await getFormState({\n        apiRoute: config.routes.api,\n        body: {\n          id,\n          formState: prevFormState,\n          operation: 'update',\n          schemaPath: schemaFieldsPath,\n        },\n        serverURL: config.serverURL,\n      })\n\n      return {\n        ...formState,\n        blockName: {\n          initialValue: '',\n          passesCondition: true,\n          valid: true,\n          value: formData.blockName,\n        },\n      }\n    },\n\n    [config.routes.api, config.serverURL, schemaFieldsPath, id, formData.blockName],\n  )\n  const { i18n } = useTranslation()\n\n  const classNames = [`${baseClass}__row`, `${baseClass}__row--no-errors`].filter(Boolean).join(' ')\n\n  // Memoized Form JSX\n  const formContent = useMemo(() => {\n    return reducedBlock && initialState !== false ? (\n      <Form\n        beforeSubmit={[onChange]}\n        // @ts-expect-error TODO: Fix this\n        fields={fieldMap}\n        initialState={initialState}\n        onChange={[onChange]}\n        submitted={submitted}\n        uuid={uuid()}\n      >\n        <BlockContent\n          baseClass={baseClass}\n          field={parentLexicalRichTextField}\n          formData={formData}\n          formSchema={Array.isArray(fieldMap) ? fieldMap : []}\n          nodeKey={nodeKey}\n          path={`${path}.lexical_internal_feature.blocks.${formData.blockType}`}\n          reducedBlock={reducedBlock}\n          schemaPath={schemaFieldsPath}\n        />\n      </Form>\n    ) : (\n      <Collapsible\n        className={classNames}\n        collapsibleStyle=\"default\"\n        header={\n          <div className={`${baseClass}__block-header`}>\n            <div>\n              <Pill\n                className={`${baseClass}__block-pill ${baseClass}__block-pill-${formData?.blockType}`}\n                pillStyle=\"white\"\n              >\n                {typeof reducedBlock.labels.singular === 'string'\n                  ? getTranslation(reducedBlock.labels.singular, i18n)\n                  : '[Singular Label]'}\n              </Pill>\n              <SectionTitle path=\"blockName\" readOnly={parentLexicalRichTextField?.readOnly} />\n            </div>\n          </div>\n        }\n        key={0}\n      >\n        <ShimmerEffect height=\"35vh\" />\n      </Collapsible>\n    )\n  }, [\n    classNames,\n    fieldMap,\n    parentLexicalRichTextField,\n    nodeKey,\n    i18n,\n    submitted,\n    initialState,\n    reducedBlock,\n    onChange,\n    schemaFieldsPath,\n    path,\n  ]) // Adding formData to the dependencies here might break it\n  return <div className={baseClass + ' ' + baseClass + '-' + formData.blockType}>{formContent}</div>\n}\n", "import type { FormFieldBase } from '@payloadcms/ui'\nimport type { FieldMap, ReducedBlock } from '@payloadcms/ui/utilities/buildComponentMap'\nimport type { CollapsedPreferences, Data, FormState } from 'payload'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { getTranslation } from '@payloadcms/translations'\nimport {\n  Button,\n  Collapsible,\n  ErrorPill,\n  Pill,\n  RenderFields,\n  SectionTitle,\n  useDocumentInfo,\n  useFormSubmitted,\n  useTranslation,\n} from '@payloadcms/ui'\nimport { dequal } from 'dequal/lite' // lite: no need for Map and Set support\nimport { $getNodeByKey } from 'lexical'\nimport React, { useCallback } from 'react'\n\nimport type { SanitizedClientEditorConfig } from '../../../lexical/config/types.js'\nimport type { BlockFields, BlockNode } from '../nodes/BlocksNode.js'\n\nimport { FormSavePlugin } from './FormSavePlugin.js'\n\ntype Props = {\n  baseClass: string\n  field: {\n    editorConfig: SanitizedClientEditorConfig // With rendered features n stuff\n    name: string\n    richTextComponentMap: Map<string, React.ReactNode>\n  } & FormFieldBase\n  formData: BlockFields\n  formSchema: FieldMap\n  nodeKey: string\n  path: string\n  reducedBlock: ReducedBlock\n  schemaPath: string\n}\n\n/**\n * The actual content of the Block. This should be INSIDE a Form component,\n * scoped to the block. All format operations in here are thus scoped to the block's form, and\n * not the whole document.\n */\nexport const BlockContent: React.FC<Props> = (props) => {\n  const {\n    baseClass,\n    field,\n    formData,\n    formSchema,\n    nodeKey,\n    reducedBlock: { labels },\n    schemaPath,\n  } = props\n\n  const { i18n } = useTranslation()\n  const [editor] = useLexicalComposerContext()\n  // Used for saving collapsed to preferences (and gettin' it from there again)\n  // Remember, these preferences are scoped to the whole document, not just this form. This\n  // is important to consider for the data path used in setDocFieldPreferences\n  const { getDocPreferences, setDocFieldPreferences } = useDocumentInfo()\n\n  const [isCollapsed, setIsCollapsed] = React.useState<boolean>(() => {\n    let initialState = false\n\n    void getDocPreferences().then((currentDocPreferences) => {\n      const currentFieldPreferences = currentDocPreferences?.fields[field.name]\n\n      const collapsedArray = currentFieldPreferences?.collapsed\n\n      if (collapsedArray && collapsedArray.includes(formData.id)) {\n        initialState = true\n        setIsCollapsed(true)\n      }\n    })\n    return initialState\n  })\n\n  const hasSubmitted = useFormSubmitted()\n\n  const [errorCount, setErrorCount] = React.useState(0)\n\n  const fieldHasErrors = hasSubmitted && errorCount > 0\n\n  const classNames = [\n    `${baseClass}__row`,\n    fieldHasErrors ? `${baseClass}__row--has-errors` : `${baseClass}__row--no-errors`,\n  ]\n    .filter(Boolean)\n    .join(' ')\n\n  const onFormChange = useCallback(\n    ({\n      fullFieldsWithValues,\n      newFormData,\n    }: {\n      fullFieldsWithValues: FormState\n      newFormData: Data\n    }) => {\n      newFormData = {\n        ...newFormData,\n        id: formData.id,\n        blockType: formData.blockType,\n      }\n\n      // Recursively remove all undefined values from even being present in formData, as they will\n      // cause isDeepEqual to return false if, for example, formData has a key that fields.data\n      // does not have, even if it's undefined.\n      // Currently, this happens if a block has another sub-blocks field. Inside formData, that sub-blocks field has an undefined blockName property.\n      // Inside of fields.data however, that sub-blocks blockName property does not exist at all.\n      function removeUndefinedAndNullAndEmptyArraysRecursively(obj: object) {\n        for (const key in obj) {\n          const value = obj[key]\n          if (Array.isArray(value) && !value?.length) {\n            delete obj[key]\n          } else if (value && typeof value === 'object') {\n            removeUndefinedAndNullAndEmptyArraysRecursively(value)\n          } else if (value === undefined || value === null) {\n            delete obj[key]\n          }\n        }\n      }\n      removeUndefinedAndNullAndEmptyArraysRecursively(newFormData)\n\n      removeUndefinedAndNullAndEmptyArraysRecursively(formData)\n\n      // Only update if the data has actually changed. Otherwise, we may be triggering an unnecessary value change,\n      // which would trigger the \"Leave without saving\" dialog unnecessarily\n      if (!dequal(formData, newFormData)) {\n        // Running this in the next tick in the meantime fixes this issue: https://github.com/payloadcms/payload/issues/4108\n        // I don't know why. When this is called immediately, it might focus out of a nested lexical editor field if an update is made there.\n        // My hypothesis is that the nested editor might not have fully finished its update cycle yet. By updating in the next tick, we\n        // ensure that the nested editor has finished its update cycle before we update the block node.\n        setTimeout(() => {\n          editor.update(() => {\n            const node: BlockNode = $getNodeByKey(nodeKey)\n            if (node) {\n              node.setFields(newFormData as BlockFields)\n            }\n          })\n        }, 0)\n      }\n\n      // update error count\n      if (hasSubmitted) {\n        let rowErrorCount = 0\n        for (const formField of Object.values(fullFieldsWithValues)) {\n          if (formField?.valid === false) {\n            rowErrorCount++\n          }\n        }\n        setErrorCount(rowErrorCount)\n      }\n    },\n    [editor, nodeKey, hasSubmitted, formData],\n  )\n\n  const onCollapsedChange = useCallback(\n    (changedCollapsed: boolean) => {\n      void getDocPreferences().then((currentDocPreferences) => {\n        const currentFieldPreferences = currentDocPreferences?.fields[field.name]\n\n        const collapsedArray = currentFieldPreferences?.collapsed\n\n        const newCollapsed: CollapsedPreferences =\n          collapsedArray && collapsedArray?.length ? collapsedArray : []\n\n        if (changedCollapsed) {\n          if (!newCollapsed.includes(formData.id)) {\n            newCollapsed.push(formData.id)\n          }\n        } else {\n          if (newCollapsed.includes(formData.id)) {\n            newCollapsed.splice(newCollapsed.indexOf(formData.id), 1)\n          }\n        }\n\n        setDocFieldPreferences(field.name, {\n          collapsed: newCollapsed,\n          hello: 'hi',\n        })\n      })\n    },\n    [getDocPreferences, field.name, setDocFieldPreferences, formData.id],\n  )\n\n  const removeBlock = useCallback(() => {\n    editor.update(() => {\n      $getNodeByKey(nodeKey).remove()\n    })\n  }, [editor, nodeKey])\n\n  return (\n    <React.Fragment>\n      <Collapsible\n        className={classNames}\n        collapsibleStyle={fieldHasErrors ? 'error' : 'default'}\n        header={\n          <div className={`${baseClass}__block-header`}>\n            <div>\n              <Pill\n                className={`${baseClass}__block-pill ${baseClass}__block-pill-${formData?.blockType}`}\n                pillStyle=\"white\"\n              >\n                {typeof labels.singular === 'string'\n                  ? getTranslation(labels.singular, i18n)\n                  : '[Singular Label]'}\n              </Pill>\n              <SectionTitle path=\"blockName\" readOnly={field?.readOnly} />\n              {fieldHasErrors && <ErrorPill count={errorCount} i18n={i18n} withMessage />}\n            </div>\n            {editor.isEditable() && (\n              <Button\n                buttonStyle=\"icon-label\"\n                className={`${baseClass}__removeButton`}\n                disabled={field?.readOnly}\n                icon=\"x\"\n                onClick={(e) => {\n                  e.preventDefault()\n                  removeBlock()\n                }}\n                round\n                tooltip=\"Remove Block\"\n              />\n            )}\n          </div>\n        }\n        isCollapsed={isCollapsed}\n        key={0}\n        onToggle={(incomingCollapsedState) => {\n          onCollapsedChange(incomingCollapsedState)\n          setIsCollapsed(incomingCollapsedState)\n        }}\n      >\n        <RenderFields\n          className={`${baseClass}__fields`}\n          fieldMap={Array.isArray(formSchema) ? formSchema : []}\n          forceRender\n          margins=\"small\"\n          path=\"\" // Leaving path empty makes it so field values are not prefixed / scoped by the entire schemaPath. e.g. we can access \"myField\" instead of \"someLexicalField.feature.blocks.someArrayB\" // TODO: Could there be any implications leaving path different than schemaPath?\n          readOnly={false}\n          schemaPath={schemaPath} // Having the correct schemaPath here allows sub-fields (like array > addRow) to run correct form-state calls and retrieve their needed form state from the server\n        />\n      </Collapsible>\n\n      <FormSavePlugin onChange={onFormChange} />\n    </React.Fragment>\n  )\n}\n", "import type { Data, FormState } from 'payload'\nimport type React from 'react'\n\nimport { useAllFormFields } from '@payloadcms/ui'\nimport { reduceFieldsToValues } from 'payload/shared'\nimport { useEffect } from 'react'\n\nimport { removeEmptyArrayValues } from './removeEmptyArrayValues.js'\n\ntype Props = {\n  onChange?: ({\n    fullFieldsWithValues,\n    newFormData,\n  }: {\n    fullFieldsWithValues: FormState\n    newFormData: Data\n  }) => void\n}\n\nexport const FormSavePlugin: React.FC<Props> = (props) => {\n  const { onChange } = props\n\n  const [_fields] = useAllFormFields()\n\n  const fields = removeEmptyArrayValues({ fields: _fields })\n\n  // Pass in fields, and indicate if you'd like to \"unflatten\" field data.\n  // The result below will reflect the data stored in the form at the given time\n  const newFormData = reduceFieldsToValues(fields, true)\n\n  useEffect(() => {\n    if (onChange) {\n      onChange({ fullFieldsWithValues: fields, newFormData })\n    }\n  }, [newFormData, onChange, fields])\n\n  return null\n}\n", "import type { FormState } from 'payload'\n\n/**\n * By default, if an array field is empty, it will be included in the form state with a value of 0.\n * We do not need this behavior here, By setting `disableFormData` to true, we can prevent the field from being included in the form state\n * like that.\n * @param fields form state\n */\nexport function removeEmptyArrayValues({ fields }: { fields: FormState }): FormState {\n  for (const key in fields) {\n    const field = fields[key]\n    if (Array.isArray(field.rows) && 'value' in field) {\n      field.disableFormData = true\n    }\n  }\n  return fields\n}\n"],
  "mappings": "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",
  "names": ["Collapsible", "Form", "Pill", "SectionTitle", "ShimmerEffect", "useConfig", "useDocumentInfo", "useFieldProps", "useFormSubmitted", "useTranslation", "useCallback", "useEffect", "useMemo", "useState", "getTranslation", "getFormState", "uuid", "useLexicalComposerContext", "getTranslation", "Button", "Collapsible", "ErrorPill", "Pill", "RenderFields", "SectionTitle", "useDocumentInfo", "useFormSubmitted", "useTranslation", "dequal", "$getNodeByKey", "React", "useCallback", "useAllFormFields", "reduceFieldsToValues", "useEffect", "removeEmptyArrayValues", "fields", "key", "field", "FormSavePlugin", "props", "onChange", "_fields", "useAllFormFields", "fields", "removeEmptyArrayValues", "newFormData", "reduceFieldsToValues", "useEffect", "jsx", "jsxs", "BlockContent", "props", "baseClass", "field", "formData", "formSchema", "nodeKey", "labels", "schemaPath", "i18n", "useTranslation", "editor", "useLexicalComposerContext", "getDocPreferences", "setDocFieldPreferences", "useDocumentInfo", "isCollapsed", "setIsCollapsed", "React", "initialState", "currentDocPreferences", "collapsedArray", "hasSubmitted", "useFormSubmitted", "errorCount", "setErrorCount", "fieldHasErrors", "classNames", "onFormChange", "useCallback", "fullFieldsWithValues", "newFormData", "removeUndefinedAndNullAndEmptyArraysRecursively", "obj", "key", "value", "dequal", "node", "$getNodeByKey", "rowErrorCount", "formField", "onCollapsedChange", "changedCollapsed", "newCollapsed", "removeBlock", "Collapsible", "Pill", "getTranslation", "SectionTitle", "ErrorPill", "Button", "e", "incomingCollapsedState", "RenderFields", "FormSavePlugin", "jsx", "jsxs", "baseClass", "BlockComponent", "props", "formData", "nodeKey", "config", "useConfig", "submitted", "useFormSubmitted", "id", "useDocumentInfo", "path", "schemaPath", "useFieldProps", "editorConfig", "parentLexicalRichTextField", "useEditorConfigContext", "initialState", "setInitialState", "useState", "richTextComponentMap", "componentMapRenderedFieldsPath", "schemaFieldsPath", "reducedBlock", "block", "fieldMap", "useEffect", "state", "getFormState", "onChange", "useCallback", "prevFormState", "i18n", "useTranslation", "classNames", "formContent", "useMemo", "Form", "uuid", "BlockContent", "Collapsible", "Pill", "getTranslation", "SectionTitle", "ShimmerEffect"]
}

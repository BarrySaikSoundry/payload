{
  "version": 3,
  "sources": ["../../../src/features/relationship/drawer/commands.ts", "../../../src/features/relationship/nodes/RelationshipNode.tsx"],
  "sourcesContent": ["import type { LexicalCommand } from 'lexical'\n\nimport { createCommand } from 'lexical'\n\nexport const INSERT_RELATIONSHIP_WITH_DRAWER_COMMAND: LexicalCommand<{\n  replace: { nodeKey: string } | false\n}> = createCommand('INSERT_RELATIONSHIP_WITH_DRAWER_COMMAND')\n", "import type { SerializedDecoratorBlockNode } from '@lexical/react/LexicalDecoratorBlockNode.js'\nimport type {\n  DOMConversionMap,\n  DOMConversionOutput,\n  DOMExportOutput,\n  EditorConfig,\n  ElementFormatType,\n  LexicalEditor,\n  LexicalNode,\n  NodeKey,\n  Spread,\n} from 'lexical'\nimport type { CollectionSlug } from 'payload'\nimport type { JSX } from 'react'\n\nimport { DecoratorBlockNode } from '@lexical/react/LexicalDecoratorBlockNode.js'\nimport * as React from 'react'\n\nconst RelationshipComponent = React.lazy(() =>\n  import('./components/RelationshipComponent.js').then((module) => ({\n    default: module.RelationshipComponent,\n  })),\n)\n\nexport type RelationshipData = {\n  relationTo: CollectionSlug\n  value: number | string\n}\n\nexport type SerializedRelationshipNode = {\n  children?: never // required so that our typed editor state doesn't automatically add children\n  type: 'relationship'\n} & Spread<RelationshipData, SerializedDecoratorBlockNode>\n\nfunction $relationshipElementToNode(domNode: HTMLDivElement): DOMConversionOutput | null {\n  const id = domNode.getAttribute('data-lexical-relationship-id')\n  const relationTo = domNode.getAttribute('data-lexical-relationship-relationTo')\n\n  if (id != null && relationTo != null) {\n    const node = $createRelationshipNode({\n      relationTo,\n      value: id,\n    })\n    return { node }\n  }\n  return null\n}\n\nexport class RelationshipNode extends DecoratorBlockNode {\n  __data: RelationshipData\n\n  constructor({\n    data,\n    format,\n    key,\n  }: {\n    data: RelationshipData\n    format?: ElementFormatType\n    key?: NodeKey\n  }) {\n    super(format, key)\n    this.__data = data\n  }\n\n  static clone(node: RelationshipNode): RelationshipNode {\n    return new RelationshipNode({\n      data: node.__data,\n      format: node.__format,\n      key: node.__key,\n    })\n  }\n\n  static getType(): string {\n    return 'relationship'\n  }\n\n  static importDOM(): DOMConversionMap<HTMLDivElement> | null {\n    return {\n      div: (domNode: HTMLDivElement) => {\n        if (\n          !domNode.hasAttribute('data-lexical-relationship-relationTo') ||\n          !domNode.hasAttribute('data-lexical-relationship-id')\n        ) {\n          return null\n        }\n        return {\n          conversion: $relationshipElementToNode,\n          priority: 2,\n        }\n      },\n    }\n  }\n\n  static importJSON(serializedNode: SerializedRelationshipNode): RelationshipNode {\n    if (serializedNode.version === 1 && (serializedNode?.value as unknown as { id: string })?.id) {\n      serializedNode.value = (serializedNode.value as unknown as { id: string }).id\n    }\n\n    const importedData: RelationshipData = {\n      relationTo: serializedNode.relationTo,\n      value: serializedNode.value,\n    }\n    const node = $createRelationshipNode(importedData)\n    node.setFormat(serializedNode.format)\n    return node\n  }\n\n  static isInline(): false {\n    return false\n  }\n\n  decorate(editor: LexicalEditor, config: EditorConfig): JSX.Element {\n    return (\n      <RelationshipComponent\n        className={config.theme.relationship ?? 'LexicalEditorTheme__relationship'}\n        data={this.__data}\n        format={this.__format}\n        nodeKey={this.getKey()}\n      />\n    )\n  }\n  exportDOM(): DOMExportOutput {\n    const element = document.createElement('div')\n    element.setAttribute('data-lexical-relationship-id', String(this.__data?.value))\n    element.setAttribute('data-lexical-relationship-relationTo', this.__data?.relationTo)\n\n    const text = document.createTextNode(this.getTextContent())\n    element.append(text)\n    return { element }\n  }\n\n  exportJSON(): SerializedRelationshipNode {\n    return {\n      ...super.exportJSON(),\n      ...this.getData(),\n      type: 'relationship',\n      version: 2,\n    }\n  }\n\n  getData(): RelationshipData {\n    return this.getLatest().__data\n  }\n\n  getTextContent(): string {\n    return `${this.__data?.relationTo} relation to ${this.__data?.value}`\n  }\n\n  setData(data: RelationshipData): void {\n    const writable = this.getWritable()\n    writable.__data = data\n  }\n}\n\nexport function $createRelationshipNode(data: RelationshipData): RelationshipNode {\n  return new RelationshipNode({\n    data,\n  })\n}\n\nexport function $isRelationshipNode(\n  node: LexicalNode | RelationshipNode | null | undefined,\n): node is RelationshipNode {\n  return node instanceof RelationshipNode\n}\n"],
  "mappings": "AAEA,OAAS,iBAAAA,MAAqB,UAEvB,IAAMC,EAERD,EAAc,yCAAyC,ECS5D,OAAS,sBAAAE,MAA0B,8CACnC,UAAYC,MAAW,QAiGjB,cAAAC,MAAA,oBA/FN,IAAMC,EAA8B,OAAK,IACvC,OAAO,qCAAuC,EAAE,KAAMC,IAAY,CAChE,QAASA,EAAO,qBAClB,EAAE,CACJ,EAYA,SAASC,EAA2BC,EAAqD,CACvF,IAAMC,EAAKD,EAAQ,aAAa,8BAA8B,EACxDE,EAAaF,EAAQ,aAAa,sCAAsC,EAE9E,OAAIC,GAAM,MAAQC,GAAc,KAKvB,CAAE,KAJIC,EAAwB,CACnC,WAAAD,EACA,MAAOD,CACT,CAAC,CACa,EAET,IACT,CAEO,IAAMG,EAAN,MAAMC,UAAyBX,CAAmB,CACvD,OAEA,YAAY,CACV,KAAAY,EACA,OAAAC,EACA,IAAAC,CACF,EAIG,CACD,MAAMD,EAAQC,CAAG,EACjB,KAAK,OAASF,CAChB,CAEA,OAAO,MAAMG,EAA0C,CACrD,OAAO,IAAIJ,EAAiB,CAC1B,KAAMI,EAAK,OACX,OAAQA,EAAK,SACb,IAAKA,EAAK,KACZ,CAAC,CACH,CAEA,OAAO,SAAkB,CACvB,MAAO,cACT,CAEA,OAAO,WAAqD,CAC1D,MAAO,CACL,IAAMT,GAEF,CAACA,EAAQ,aAAa,sCAAsC,GAC5D,CAACA,EAAQ,aAAa,8BAA8B,EAE7C,KAEF,CACL,WAAYD,EACZ,SAAU,CACZ,CAEJ,CACF,CAEA,OAAO,WAAWW,EAA8D,CAC1EA,EAAe,UAAY,GAAMA,GAAgB,OAAqC,KACxFA,EAAe,MAASA,EAAe,MAAoC,IAG7E,IAAMC,EAAiC,CACrC,WAAYD,EAAe,WAC3B,MAAOA,EAAe,KACxB,EACMD,EAAON,EAAwBQ,CAAY,EACjD,OAAAF,EAAK,UAAUC,EAAe,MAAM,EAC7BD,CACT,CAEA,OAAO,UAAkB,CACvB,MAAO,EACT,CAEA,SAASG,EAAuBC,EAAmC,CACjE,OACEjB,EAACC,EAAA,CACC,UAAWgB,EAAO,MAAM,cAAgB,mCACxC,KAAM,KAAK,OACX,OAAQ,KAAK,SACb,QAAS,KAAK,OAAO,EACvB,CAEJ,CACA,WAA6B,CAC3B,IAAMC,EAAU,SAAS,cAAc,KAAK,EAC5CA,EAAQ,aAAa,+BAAgC,OAAO,KAAK,QAAQ,KAAK,CAAC,EAC/EA,EAAQ,aAAa,uCAAwC,KAAK,QAAQ,UAAU,EAEpF,IAAMC,EAAO,SAAS,eAAe,KAAK,eAAe,CAAC,EAC1D,OAAAD,EAAQ,OAAOC,CAAI,EACZ,CAAE,QAAAD,CAAQ,CACnB,CAEA,YAAyC,CACvC,MAAO,CACL,GAAG,MAAM,WAAW,EACpB,GAAG,KAAK,QAAQ,EAChB,KAAM,eACN,QAAS,CACX,CACF,CAEA,SAA4B,CAC1B,OAAO,KAAK,UAAU,EAAE,MAC1B,CAEA,gBAAyB,CACvB,MAAO,GAAG,KAAK,QAAQ,UAAU,gBAAgB,KAAK,QAAQ,KAAK,EACrE,CAEA,QAAQR,EAA8B,CACpC,IAAMU,EAAW,KAAK,YAAY,EAClCA,EAAS,OAASV,CACpB,CACF,EAEO,SAASH,EAAwBG,EAA0C,CAChF,OAAO,IAAIF,EAAiB,CAC1B,KAAAE,CACF,CAAC,CACH,CAEO,SAASW,EACdR,EAC0B,CAC1B,OAAOA,aAAgBL,CACzB",
  "names": ["createCommand", "INSERT_RELATIONSHIP_WITH_DRAWER_COMMAND", "DecoratorBlockNode", "React", "jsx", "RelationshipComponent", "module", "$relationshipElementToNode", "domNode", "id", "relationTo", "$createRelationshipNode", "RelationshipNode", "_RelationshipNode", "data", "format", "key", "node", "serializedNode", "importedData", "editor", "config", "element", "text", "writable", "$isRelationshipNode"]
}

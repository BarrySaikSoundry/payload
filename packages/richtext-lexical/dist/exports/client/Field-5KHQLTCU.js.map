{
  "version": 3,
  "sources": ["../../../src/field/Field.tsx", "../../../src/lexical/LexicalProvider.tsx", "../../../src/lexical/LexicalEditor.tsx", "../../../src/lexical/EditorPlugin.tsx", "../../../src/lexical/plugins/MarkdownShortcut/index.tsx", "../../../src/lexical/plugins/SlashMenu/index.tsx", "../../../src/lexical/plugins/SlashMenu/useMenuTriggerMatch.ts", "../../../src/lexical/plugins/handles/AddBlockHandlePlugin/index.tsx", "../../../src/lexical/plugins/handles/utils/calculateDistanceFromScrollerElem.ts", "../../../src/lexical/plugins/handles/utils/getNodeCloseToPoint.ts", "../../../src/lexical/plugins/handles/DraggableBlockPlugin/getBoundingRectWithoutTransform.ts", "../../../src/lexical/plugins/handles/utils/getCollapsedMargins.ts", "../../../src/lexical/plugins/handles/utils/getTopLevelNodeKeys.ts", "../../../src/lexical/plugins/handles/utils/isOnHandleElement.ts", "../../../src/lexical/plugins/handles/utils/doesLineHeightAffectElement.ts", "../../../src/lexical/plugins/handles/utils/setHandlePosition.ts", "../../../src/lexical/plugins/handles/DraggableBlockPlugin/index.tsx", "../../../src/lexical/plugins/handles/DraggableBlockPlugin/highlightElemOriginalPosition.ts", "../../../src/lexical/plugins/handles/DraggableBlockPlugin/setTargetLine.ts", "../../../src/lexical/ui/ContentEditable.tsx"],
  "sourcesContent": ["'use client'\nimport type { FormFieldBase } from '@payloadcms/ui'\nimport type { SerializedEditorState } from 'lexical'\n\nimport {\n  FieldDescription,\n  FieldError,\n  FieldLabel,\n  useField,\n  useFieldProps,\n  withCondition,\n} from '@payloadcms/ui'\nimport React, { useCallback } from 'react'\nimport { ErrorBoundary } from 'react-error-boundary'\n\nimport type { SanitizedClientEditorConfig } from '../lexical/config/types.js'\n\nimport { LexicalProvider } from '../lexical/LexicalProvider.js'\nimport './bundled.css'\nconst baseClass = 'rich-text-lexical'\n\nconst _RichText: React.FC<\n  {\n    editorConfig: SanitizedClientEditorConfig // With rendered features n stuff\n    name: string\n    richTextComponentMap: Map<string, React.ReactNode>\n    width?: string\n  } & FormFieldBase\n> = (props) => {\n  const {\n    name,\n    CustomDescription,\n    CustomError,\n    CustomLabel,\n    className,\n    descriptionProps,\n    editorConfig,\n    errorProps,\n    label,\n    labelProps,\n    path: pathFromProps,\n    readOnly,\n    required,\n    style,\n    validate, // Users can pass in client side validation if they WANT to, but it's not required anymore\n    width,\n  } = props\n\n  const memoizedValidate = useCallback(\n    (value, validationOptions) => {\n      if (typeof validate === 'function') {\n        return validate(value, { ...validationOptions, props, required })\n      }\n    },\n    // Important: do not add props to the dependencies array.\n    // This would cause an infinite loop and endless re-rendering.\n    // Removing props from the dependencies array fixed this issue: https://github.com/payloadcms/payload/issues/3709\n    [validate, required],\n  )\n  const { path: pathFromContext } = useFieldProps()\n\n  const fieldType = useField<SerializedEditorState>({\n    path: pathFromContext ?? pathFromProps ?? name,\n    validate: memoizedValidate,\n  })\n\n  const { errorMessage, initialValue, path, schemaPath, setValue, showError, value } = fieldType\n\n  const classes = [\n    baseClass,\n    'field-type',\n    className,\n    showError && 'error',\n    readOnly && `${baseClass}--read-only`,\n    editorConfig?.admin?.hideGutter !== true ? `${baseClass}--show-gutter` : null,\n  ]\n    .filter(Boolean)\n    .join(' ')\n\n  return (\n    <div\n      className={classes}\n      key={path}\n      style={{\n        ...style,\n        width,\n      }}\n    >\n      <FieldError CustomError={CustomError} path={path} {...(errorProps || {})} alignCaret=\"left\" />\n      <FieldLabel\n        CustomLabel={CustomLabel}\n        label={label}\n        required={required}\n        {...(labelProps || {})}\n      />\n      <div className={`${baseClass}__wrap`}>\n        <ErrorBoundary fallbackRender={fallbackRender} onReset={() => {}}>\n          <LexicalProvider\n            editorConfig={editorConfig}\n            fieldProps={props}\n            key={JSON.stringify({ initialValue, path })} // makes sure lexical is completely re-rendered when initialValue changes, bypassing the lexical-internal value memoization. That way, external changes to the form will update the editor. More infos in PR description (https://github.com/payloadcms/payload/pull/5010)\n            onChange={(editorState) => {\n              let serializedEditorState = editorState.toJSON()\n\n              // Transform state through save hooks\n              if (editorConfig?.features?.hooks?.save?.length) {\n                editorConfig.features.hooks.save.forEach((hook) => {\n                  serializedEditorState = hook({ incomingEditorState: serializedEditorState })\n                })\n              }\n\n              setValue(serializedEditorState)\n            }}\n            path={path}\n            readOnly={readOnly}\n            value={value}\n          />\n        </ErrorBoundary>\n        {CustomDescription !== undefined ? (\n          CustomDescription\n        ) : (\n          <FieldDescription {...(descriptionProps || {})} />\n        )}\n      </div>\n    </div>\n  )\n}\n\nfunction fallbackRender({ error }): React.ReactElement {\n  // Call resetErrorBoundary() to reset the error boundary and retry the render.\n\n  return (\n    <div className=\"errorBoundary\" role=\"alert\">\n      <p>Something went wrong:</p>\n      <pre style={{ color: 'red' }}>{error.message}</pre>\n    </div>\n  )\n}\n\nexport const RichText = withCondition(_RichText)\n", "'use client'\nimport type { InitialConfigType } from '@lexical/react/LexicalComposer.js'\nimport type { FormFieldBase } from '@payloadcms/ui'\nimport type { EditorState, LexicalEditor, SerializedEditorState } from 'lexical'\n\nimport { LexicalComposer } from '@lexical/react/LexicalComposer.js'\nimport * as React from 'react'\nimport { useMemo } from 'react'\n\nimport type { SanitizedClientEditorConfig } from './config/types.js'\n\nimport { LexicalEditor as LexicalEditorComponent } from './LexicalEditor.js'\nimport {\n  EditorConfigProvider,\n  useEditorConfigContext,\n} from './config/client/EditorConfigProvider.js'\nimport { getEnabledNodes } from './nodes/index.js'\n\nexport type LexicalProviderProps = {\n  editorConfig: SanitizedClientEditorConfig\n  fieldProps: {\n    editorConfig: SanitizedClientEditorConfig // With rendered features n stuff\n    name: string\n    richTextComponentMap: Map<string, React.ReactNode>\n  } & FormFieldBase\n  onChange: (editorState: EditorState, editor: LexicalEditor, tags: Set<string>) => void\n  path: string\n  readOnly: boolean\n  value: SerializedEditorState\n}\n\nconst NestProviders = ({ children, providers }) => {\n  if (!providers?.length) {\n    return children\n  }\n  const Component = providers[0]\n  if (providers.length > 1) {\n    return (\n      <Component>\n        <NestProviders providers={providers.slice(1)}>{children}</NestProviders>\n      </Component>\n    )\n  }\n  return <Component>{children}</Component>\n}\n\nexport const LexicalProvider: React.FC<LexicalProviderProps> = (props) => {\n  const { editorConfig, fieldProps, onChange, path, readOnly, value } = props\n\n  const parentContext = useEditorConfigContext()\n\n  const editorContainerRef = React.useRef<HTMLDivElement>(null)\n\n  const processedValue = useMemo(() => {\n    let processed = value\n    if (editorConfig?.features?.hooks?.load?.length) {\n      editorConfig.features.hooks.load.forEach((hook) => {\n        processed = hook({ incomingEditorState: processed })\n      })\n    }\n    return processed\n  }, [editorConfig, value])\n\n  // useMemo for the initialConfig that depends on readOnly and processedValue\n  const initialConfig = useMemo<InitialConfigType>(() => {\n    if (processedValue && typeof processedValue !== 'object') {\n      throw new Error(\n        'The value passed to the Lexical editor is not an object. This is not supported. Please remove the data from the field and start again. This is the value that was passed in: ' +\n          JSON.stringify(processedValue),\n      )\n    }\n\n    if (processedValue && Array.isArray(processedValue) && !('root' in processedValue)) {\n      throw new Error(\n        'You have tried to pass in data from the old, Slate editor, to the new, Lexical editor. This is not supported. There is no automatic conversion from Slate to Lexical data available yet (coming soon). Please remove the data from the field and start again.',\n      )\n    }\n\n    if (processedValue && 'jsonContent' in processedValue) {\n      throw new Error(\n        'You have tried to pass in data from payload-plugin-lexical. This is not supported. The data structure has changed in this editor, compared to the plugin, and there is no automatic conversion available yet (coming soon). Please remove the data from the field and start again.',\n      )\n    }\n\n    return {\n      editable: readOnly !== true,\n      editorState: processedValue != null ? JSON.stringify(processedValue) : undefined,\n      namespace: editorConfig.lexical.namespace,\n      nodes: [...getEnabledNodes({ editorConfig })],\n      onError: (error: Error) => {\n        throw error\n      },\n      theme: editorConfig.lexical.theme,\n    }\n  }, [editorConfig, processedValue, readOnly])\n\n  if (!initialConfig) {\n    return <p>Loading...</p>\n  }\n\n  return (\n    <LexicalComposer initialConfig={initialConfig} key={path}>\n      <EditorConfigProvider\n        editorConfig={editorConfig}\n        editorContainerRef={editorContainerRef}\n        fieldProps={fieldProps}\n        parentContext={parentContext}\n      >\n        <NestProviders providers={editorConfig.features.providers}>\n          <LexicalEditorComponent\n            editorConfig={editorConfig}\n            editorContainerRef={editorContainerRef}\n            onChange={onChange}\n          />\n        </NestProviders>\n      </EditorConfigProvider>\n    </LexicalComposer>\n  )\n}\n", "'use client'\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { LexicalErrorBoundary } from '@lexical/react/LexicalErrorBoundary.js'\nimport { HistoryPlugin } from '@lexical/react/LexicalHistoryPlugin.js'\nimport { OnChangePlugin } from '@lexical/react/LexicalOnChangePlugin.js'\nimport { RichTextPlugin } from '@lexical/react/LexicalRichTextPlugin.js'\nimport { TabIndentationPlugin } from '@lexical/react/LexicalTabIndentationPlugin.js'\nimport { useTranslation } from '@payloadcms/ui'\nimport { BLUR_COMMAND, COMMAND_PRIORITY_LOW, FOCUS_COMMAND } from 'lexical'\nimport * as React from 'react'\nimport { useEffect, useState } from 'react'\n\nimport type { LexicalProviderProps } from './LexicalProvider.js'\n\nimport { EditorPlugin } from './EditorPlugin.js'\nimport { useEditorConfigContext } from './config/client/EditorConfigProvider.js'\nimport { MarkdownShortcutPlugin } from './plugins/MarkdownShortcut/index.js'\nimport { SlashMenuPlugin } from './plugins/SlashMenu/index.js'\nimport { AddBlockHandlePlugin } from './plugins/handles/AddBlockHandlePlugin/index.js'\nimport { DraggableBlockPlugin } from './plugins/handles/DraggableBlockPlugin/index.js'\nimport { LexicalContentEditable } from './ui/ContentEditable.js'\n\nexport const LexicalEditor: React.FC<\n  {\n    editorContainerRef: React.RefObject<HTMLDivElement>\n  } & Pick<LexicalProviderProps, 'editorConfig' | 'onChange'>\n> = (props) => {\n  const { editorConfig, editorContainerRef, onChange } = props\n  const editorConfigContext = useEditorConfigContext()\n  const [editor] = useLexicalComposerContext()\n  const { t } = useTranslation<{}, string>()\n\n  const [floatingAnchorElem, setFloatingAnchorElem] = useState<HTMLDivElement | null>(null)\n  const onRef = (_floatingAnchorElem: HTMLDivElement) => {\n    if (_floatingAnchorElem !== null) {\n      setFloatingAnchorElem(_floatingAnchorElem)\n    }\n  }\n\n  useEffect(() => {\n    if (!editorConfigContext?.uuid) {\n      console.error('Lexical Editor must be used within an EditorConfigProvider')\n      return\n    }\n    if (editorConfigContext?.parentEditor?.uuid) {\n      editorConfigContext.parentEditor?.registerChild(editorConfigContext.uuid, editorConfigContext)\n    }\n\n    const handleFocus = () => {\n      editorConfigContext.focusEditor(editorConfigContext)\n    }\n\n    const handleBlur = () => {\n      editorConfigContext.blurEditor(editorConfigContext)\n    }\n\n    const unregisterFocus = editor.registerCommand<MouseEvent>(\n      FOCUS_COMMAND,\n      () => {\n        handleFocus()\n        return true\n      },\n      COMMAND_PRIORITY_LOW,\n    )\n\n    const unregisterBlur = editor.registerCommand<MouseEvent>(\n      BLUR_COMMAND,\n      () => {\n        handleBlur()\n        return true\n      },\n      COMMAND_PRIORITY_LOW,\n    )\n\n    return () => {\n      unregisterFocus()\n      unregisterBlur()\n      editorConfigContext.parentEditor?.unregisterChild?.(editorConfigContext.uuid)\n    }\n  }, [editor, editorConfigContext])\n\n  const [isSmallWidthViewport, setIsSmallWidthViewport] = useState<boolean>(false)\n\n  useEffect(() => {\n    const updateViewPortWidth = () => {\n      const isNextSmallWidthViewport = window.matchMedia('(max-width: 768px)').matches\n\n      if (isNextSmallWidthViewport !== isSmallWidthViewport) {\n        setIsSmallWidthViewport(isNextSmallWidthViewport)\n      }\n    }\n    updateViewPortWidth()\n    window.addEventListener('resize', updateViewPortWidth)\n\n    return () => {\n      window.removeEventListener('resize', updateViewPortWidth)\n    }\n  }, [isSmallWidthViewport])\n\n  return (\n    <React.Fragment>\n      {editorConfig.features.plugins.map((plugin) => {\n        if (plugin.position === 'aboveContainer') {\n          return <EditorPlugin clientProps={plugin.clientProps} key={plugin.key} plugin={plugin} />\n        }\n      })}\n      <div className=\"editor-container\" ref={editorContainerRef}>\n        {editorConfig.features.plugins.map((plugin) => {\n          if (plugin.position === 'top') {\n            return (\n              <EditorPlugin clientProps={plugin.clientProps} key={plugin.key} plugin={plugin} />\n            )\n          }\n        })}\n        <RichTextPlugin\n          ErrorBoundary={LexicalErrorBoundary}\n          contentEditable={\n            <div className=\"editor-scroller\">\n              <div className=\"editor\" ref={onRef}>\n                <LexicalContentEditable />\n              </div>\n            </div>\n          }\n          placeholder={<p className=\"editor-placeholder\">{t('lexical:general:placeholder')}</p>}\n        />\n        <OnChangePlugin\n          // Selection changes can be ignored here, reducing the\n          // frequency that the FieldComponent and Payload receive updates.\n          // Selection changes are only needed if you are saving selection state\n          ignoreSelectionChange\n          onChange={(editorState, editor, tags) => {\n            // Ignore any onChange event triggered by focus only\n            if (!tags.has('focus') || tags.size > 1) {\n              if (onChange != null) onChange(editorState, editor, tags)\n            }\n          }}\n        />\n        {floatingAnchorElem && (\n          <React.Fragment>\n            {!isSmallWidthViewport && editor.isEditable() && (\n              <React.Fragment>\n                <DraggableBlockPlugin anchorElem={floatingAnchorElem} />\n                <AddBlockHandlePlugin anchorElem={floatingAnchorElem} />\n              </React.Fragment>\n            )}\n            {editorConfig.features.plugins.map((plugin) => {\n              if (\n                plugin.position === 'floatingAnchorElem' &&\n                !(plugin.desktopOnly === true && isSmallWidthViewport)\n              ) {\n                return (\n                  <EditorPlugin\n                    anchorElem={floatingAnchorElem}\n                    clientProps={plugin.clientProps}\n                    key={plugin.key}\n                    plugin={plugin}\n                  />\n                )\n              }\n            })}\n            {editor.isEditable() && (\n              <React.Fragment>\n                <SlashMenuPlugin anchorElem={floatingAnchorElem} />\n              </React.Fragment>\n            )}\n          </React.Fragment>\n        )}\n        {editor.isEditable() && (\n          <React.Fragment>\n            <HistoryPlugin />\n            {editorConfig?.features?.markdownTransformers?.length > 0 && <MarkdownShortcutPlugin />}\n          </React.Fragment>\n        )}\n\n        <TabIndentationPlugin />\n        {editorConfig.features.plugins.map((plugin) => {\n          if (plugin.position === 'normal') {\n            return (\n              <EditorPlugin clientProps={plugin.clientProps} key={plugin.key} plugin={plugin} />\n            )\n          }\n        })}\n        {editorConfig.features.plugins.map((plugin) => {\n          if (plugin.position === 'bottom') {\n            return (\n              <EditorPlugin clientProps={plugin.clientProps} key={plugin.key} plugin={plugin} />\n            )\n          }\n        })}\n      </div>\n      {editorConfig.features.plugins.map((plugin) => {\n        if (plugin.position === 'belowContainer') {\n          return <EditorPlugin clientProps={plugin.clientProps} key={plugin.key} plugin={plugin} />\n        }\n      })}\n    </React.Fragment>\n  )\n}\n", "import React from 'react'\n\nimport type { SanitizedPlugin } from '../features/typesClient.js'\n\nexport const EditorPlugin: React.FC<{\n  anchorElem?: HTMLDivElement\n  clientProps: unknown\n  plugin: SanitizedPlugin\n}> = ({ anchorElem, clientProps, plugin }) => {\n  if (plugin.position === 'floatingAnchorElem') {\n    return (\n      plugin.Component && <plugin.Component anchorElem={anchorElem} clientProps={clientProps} />\n    )\n  }\n\n  return plugin.Component && <plugin.Component clientProps={clientProps} />\n}\n", "'use client'\n\nimport { MarkdownShortcutPlugin as LexicalMarkdownShortcutPlugin } from '@lexical/react/LexicalMarkdownShortcutPlugin.js'\nimport * as React from 'react'\n\nimport { useEditorConfigContext } from '../../config/client/EditorConfigProvider.js'\n\nexport const MarkdownShortcutPlugin: React.FC = () => {\n  const { editorConfig } = useEditorConfigContext()\n\n  return <LexicalMarkdownShortcutPlugin transformers={editorConfig.features.markdownTransformers} />\n}\n", "'use client'\nimport type { TextNode } from 'lexical'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { useTranslation } from '@payloadcms/ui'\nimport { useCallback, useMemo, useState } from 'react'\nimport * as React from 'react'\nimport * as ReactDOM from 'react-dom'\n\nimport type {\n  SlashMenuGroup,\n  SlashMenuGroupInternal,\n  SlashMenuItemInternal,\n  SlashMenuItem as SlashMenuItemType,\n} from './LexicalTypeaheadMenuPlugin/types.js'\n\nimport { useEditorConfigContext } from '../../config/client/EditorConfigProvider.js'\nimport { LexicalTypeaheadMenuPlugin } from './LexicalTypeaheadMenuPlugin/index.js'\nimport { useMenuTriggerMatch } from './useMenuTriggerMatch.js'\n\nconst baseClass = 'slash-menu-popup'\n\nfunction SlashMenuItem({\n  isSelected,\n  item,\n  onClick,\n  onMouseEnter,\n}: {\n  index: number\n  isSelected: boolean\n  item: SlashMenuItemInternal\n  onClick: () => void\n  onMouseEnter: () => void\n}) {\n  const { i18n } = useTranslation()\n\n  let className = `${baseClass}__item ${baseClass}__item-${item.key}`\n  if (isSelected) {\n    className += ` ${baseClass}__item--selected`\n  }\n\n  let title = item.key\n  if (item.label) {\n    title = typeof item.label === 'function' ? item.label({ i18n }) : item.label\n  }\n  // Crop title to max. 25 characters\n  if (title.length > 25) {\n    title = title.substring(0, 25) + '...'\n  }\n\n  return (\n    <button\n      aria-selected={isSelected}\n      className={className}\n      id={baseClass + '__item-' + item.key}\n      key={item.key}\n      onClick={onClick}\n      onMouseEnter={onMouseEnter}\n      ref={item.ref}\n      role=\"option\"\n      tabIndex={-1}\n      type=\"button\"\n    >\n      {item?.Icon && <item.Icon />}\n\n      <span className={`${baseClass}__item-text`}>{title}</span>\n    </button>\n  )\n}\n\nexport function SlashMenuPlugin({\n  anchorElem = document.body,\n}: {\n  anchorElem?: HTMLElement\n}): React.ReactElement {\n  const [editor] = useLexicalComposerContext()\n  const [queryString, setQueryString] = useState<null | string>(null)\n  const { editorConfig } = useEditorConfigContext()\n  const { i18n } = useTranslation()\n\n  const checkForTriggerMatch = useMenuTriggerMatch('/', {\n    minLength: 0,\n  })\n\n  const getDynamicItems = useCallback(() => {\n    let groupWithItems: Array<SlashMenuGroup> = []\n\n    for (const dynamicItem of editorConfig.features.slashMenu.dynamicGroups) {\n      const dynamicGroupWithItems = dynamicItem({\n        editor,\n        queryString,\n      })\n      groupWithItems = groupWithItems.concat(dynamicGroupWithItems)\n    }\n\n    return groupWithItems\n  }, [editor, queryString, editorConfig?.features])\n\n  const groups: SlashMenuGroup[] = useMemo(() => {\n    let groupsWithItems: SlashMenuGroup[] = []\n    for (const groupWithItem of editorConfig?.features.slashMenu.groups ?? []) {\n      groupsWithItems.push(groupWithItem)\n    }\n\n    if (queryString) {\n      // Filter current groups first\n      groupsWithItems = groupsWithItems.map((group) => {\n        const filteredItems = group.items.filter((item) => {\n          let itemTitle = item.key\n          if (item.label) {\n            itemTitle = typeof item.label === 'function' ? item.label({ i18n }) : item.label\n          }\n\n          if (new RegExp(queryString, 'gi').exec(itemTitle)) {\n            return true\n          }\n          if (item.keywords != null) {\n            return item.keywords.some((keyword) => new RegExp(queryString, 'gi').exec(keyword))\n          }\n          return false\n        })\n        if (filteredItems.length) {\n          return {\n            ...group,\n            items: filteredItems,\n          }\n        }\n        return null\n      })\n\n      groupsWithItems = groupsWithItems.filter((group) => group != null)\n\n      // Now add dynamic groups\n      const dynamicItemGroups = getDynamicItems()\n\n      // merge dynamic items into groups\n      for (const dynamicGroup of dynamicItemGroups) {\n        // 1. find the group with the same name or create new one\n        let group = groupsWithItems.find((group) => group.key === dynamicGroup.key)\n        if (!group) {\n          group = {\n            ...dynamicGroup,\n            items: [],\n          }\n        } else {\n          groupsWithItems = groupsWithItems.filter((group) => group.key !== dynamicGroup.key)\n        }\n\n        // 2. Add items to group items array and add to sanitized.slashMenu.groupsWithItems\n        if (group?.items?.length) {\n          group.items = group.items.concat(group.items)\n        }\n        groupsWithItems.push(group)\n      }\n    }\n\n    return groupsWithItems\n  }, [getDynamicItems, queryString, editorConfig?.features, i18n])\n\n  const onSelectItem = useCallback(\n    (\n      selectedItem: SlashMenuItemType,\n      nodeToRemove: TextNode | null,\n      closeMenu: () => void,\n      matchingString: string,\n    ) => {\n      if (nodeToRemove) {\n        editor.update(() => {\n          nodeToRemove.remove()\n        })\n      }\n      selectedItem.onSelect({ editor, queryString: matchingString })\n\n      closeMenu()\n    },\n    [editor],\n  )\n\n  return (\n    <React.Fragment>\n      <LexicalTypeaheadMenuPlugin\n        anchorElem={anchorElem}\n        groups={groups as SlashMenuGroupInternal[]}\n        menuRenderFn={(\n          anchorElementRef,\n          { selectItemAndCleanUp, selectedItemKey, setSelectedItemKey },\n        ) =>\n          anchorElementRef.current && groups.length\n            ? ReactDOM.createPortal(\n                <div className={baseClass}>\n                  {groups.map((group) => {\n                    let groupTitle = group.key\n                    if (group.label) {\n                      groupTitle =\n                        typeof group.label === 'function' ? group.label({ i18n }) : group.label\n                    }\n\n                    return (\n                      <div\n                        className={`${baseClass}__group ${baseClass}__group-${group.key}`}\n                        key={group.key}\n                      >\n                        <div className={`${baseClass}__group-title`}>{groupTitle}</div>\n                        {group.items.map((item, oi: number) => (\n                          <SlashMenuItem\n                            index={oi}\n                            isSelected={selectedItemKey === item.key}\n                            item={item as SlashMenuItemInternal}\n                            key={item.key}\n                            onClick={() => {\n                              setSelectedItemKey(item.key)\n                              selectItemAndCleanUp(item)\n                            }}\n                            onMouseEnter={() => {\n                              setSelectedItemKey(item.key)\n                            }}\n                          />\n                        ))}\n                      </div>\n                    )\n                  })}\n                </div>,\n                anchorElementRef.current,\n              )\n            : null\n        }\n        onQueryChange={setQueryString}\n        onSelectItem={onSelectItem}\n        triggerFn={checkForTriggerMatch}\n      />\n    </React.Fragment>\n  )\n}\n", "import type { LexicalEditor } from 'lexical'\n\nimport { useCallback } from 'react'\n\nimport { PUNCTUATION } from './LexicalTypeaheadMenuPlugin/index.js'\n\nexport type TriggerFn = ({\n  editor,\n  query,\n}: {\n  editor: LexicalEditor\n  /** The query string is the POTENTIAL trigger AND the text after the trigger text. */\n  query: string\n}) => MenuTextMatch | null\n\nexport type MenuTextMatch = {\n  leadOffset: number\n  matchingString: string\n  replaceableString: string\n}\n\n/**\n * Returns a function which checks if the trigger (e.g. '/') is present in the query and, if so, returns the matching string (text after the trigger)\n */\nexport function useMenuTriggerMatch(\n  /**\n   * Text which triggers the menu. Everything after this text will be used as the query.\n   */\n  trigger: string,\n  { maxLength = 75, minLength = 1 }: { maxLength?: number; minLength?: number },\n): TriggerFn {\n  return useCallback(\n    ({ query }) => {\n      const validChars = '[^' + trigger + PUNCTUATION + '\\\\s]'\n      const TypeaheadTriggerRegex = new RegExp(\n        '(^|\\\\s|\\\\()(' +\n          '[' +\n          trigger +\n          ']' +\n          '((?:' +\n          validChars +\n          '){0,' +\n          maxLength +\n          '})' +\n          ')$',\n      )\n      const match = TypeaheadTriggerRegex.exec(query)\n      if (match !== null) {\n        const maybeLeadingWhitespace = match[1]\n\n        /**\n         * matchingString is only the text AFTER the trigger text. (So everything after the /)\n         */\n        const matchingString = match[3]\n\n        if (matchingString.length >= minLength) {\n          return {\n            leadOffset: match.index + maybeLeadingWhitespace.length,\n            matchingString,\n            replaceableString: match[2], // replaceableString is the trigger text + the matching string\n          }\n        }\n      }\n      return null\n    },\n    [maxLength, minLength, trigger],\n  )\n}\n", "'use client'\nimport type { LexicalEditor, LexicalNode, ParagraphNode } from 'lexical'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { $createParagraphNode } from 'lexical'\nimport * as React from 'react'\nimport { type JSX, useCallback, useEffect, useRef, useState } from 'react'\nimport { createPortal } from 'react-dom'\n\nimport { useEditorConfigContext } from '../../../config/client/EditorConfigProvider.js'\nimport { isHTMLElement } from '../../../utils/guard.js'\nimport { Point } from '../../../utils/point.js'\nimport { ENABLE_SLASH_MENU_COMMAND } from '../../SlashMenu/LexicalTypeaheadMenuPlugin/index.js'\nimport { calculateDistanceFromScrollerElem } from '../utils/calculateDistanceFromScrollerElem.js'\nimport { getNodeCloseToPoint } from '../utils/getNodeCloseToPoint.js'\nimport { getTopLevelNodeKeys } from '../utils/getTopLevelNodeKeys.js'\nimport { isOnHandleElement } from '../utils/isOnHandleElement.js'\nimport { setHandlePosition } from '../utils/setHandlePosition.js'\nconst ADD_BLOCK_MENU_CLASSNAME = 'add-block-menu'\n\nlet prevIndex = Infinity\n\nfunction getCurrentIndex(keysLength: number): number {\n  if (keysLength === 0) {\n    return Infinity\n  }\n  if (prevIndex >= 0 && prevIndex < keysLength) {\n    return prevIndex\n  }\n\n  return Math.floor(keysLength / 2)\n}\n\nfunction useAddBlockHandle(\n  editor: LexicalEditor,\n  anchorElem: HTMLElement,\n  isEditable: boolean,\n): React.ReactElement {\n  const scrollerElem = anchorElem.parentElement\n\n  const { editorConfig } = useEditorConfigContext()\n  const blockHandleHorizontalOffset = editorConfig?.admin?.hideGutter ? -24 : 12\n\n  const menuRef = useRef<HTMLButtonElement>(null)\n  const [hoveredElement, setHoveredElement] = useState<{\n    elem: HTMLElement\n    node: LexicalNode\n  } | null>(null)\n\n  useEffect(() => {\n    function onDocumentMouseMove(event: MouseEvent) {\n      const target = event.target\n      if (!isHTMLElement(target)) {\n        return\n      }\n\n      const distanceFromScrollerElem = calculateDistanceFromScrollerElem(\n        scrollerElem,\n        event.pageX,\n        event.pageY,\n        target,\n      )\n\n      if (distanceFromScrollerElem === -1) {\n        setHoveredElement(null)\n        return\n      }\n\n      if (isOnHandleElement(target, ADD_BLOCK_MENU_CLASSNAME)) {\n        return\n      }\n      const topLevelNodeKeys = getTopLevelNodeKeys(editor)\n\n      const {\n        blockElem: _emptyBlockElem,\n        blockNode,\n        foundAtIndex,\n      } = getNodeCloseToPoint({\n        anchorElem,\n        cache_threshold: 0,\n        editor,\n        horizontalOffset: -distanceFromScrollerElem,\n        point: new Point(event.x, event.y),\n        returnEmptyParagraphs: true,\n        startIndex: getCurrentIndex(topLevelNodeKeys.length),\n        useEdgeAsDefault: false,\n      })\n\n      prevIndex = foundAtIndex\n\n      if (!_emptyBlockElem) {\n        return\n      }\n      if (hoveredElement?.node !== blockNode || hoveredElement?.elem !== _emptyBlockElem) {\n        setHoveredElement({\n          elem: _emptyBlockElem,\n          node: blockNode,\n        })\n      }\n    }\n\n    // Since the draggableBlockElem is outside the actual editor, we need to listen to the document\n    // to be able to detect when the mouse is outside the editor and respect a buffer around\n    // the scrollerElem to avoid the draggableBlockElem disappearing too early.\n    document?.addEventListener('mousemove', onDocumentMouseMove)\n\n    return () => {\n      document?.removeEventListener('mousemove', onDocumentMouseMove)\n    }\n  }, [scrollerElem, anchorElem, editor, hoveredElement])\n\n  useEffect(() => {\n    if (menuRef.current && hoveredElement?.node) {\n      setHandlePosition(\n        hoveredElement?.elem,\n        menuRef.current,\n        anchorElem,\n        blockHandleHorizontalOffset,\n      )\n    }\n  }, [anchorElem, hoveredElement, blockHandleHorizontalOffset])\n\n  const handleAddClick = useCallback(\n    (event) => {\n      let hoveredElementToUse = hoveredElement\n      if (!hoveredElementToUse?.node) {\n        return\n      }\n\n      // 1. Update hoveredElement.node to a new paragraph node if the hoveredElement.node is not a paragraph node\n      editor.update(() => {\n        // Check if blockNode is an empty text node\n        let isEmptyParagraph = true\n        if (\n          hoveredElementToUse.node.getType() !== 'paragraph' ||\n          hoveredElementToUse.node.getTextContent() !== ''\n        ) {\n          isEmptyParagraph = false\n        }\n\n        if (!isEmptyParagraph) {\n          const newParagraph = $createParagraphNode()\n          hoveredElementToUse.node.insertAfter(newParagraph)\n\n          setTimeout(() => {\n            hoveredElementToUse = {\n              elem: editor.getElementByKey(newParagraph.getKey()),\n              node: newParagraph,\n            }\n            setHoveredElement(hoveredElementToUse)\n          }, 0)\n        }\n      })\n\n      // 2. Focus on the new paragraph node\n      setTimeout(() => {\n        editor.update(() => {\n          editor.focus()\n\n          if (\n            hoveredElementToUse.node &&\n            'select' in hoveredElementToUse.node &&\n            typeof hoveredElementToUse.node.select === 'function'\n          ) {\n            hoveredElementToUse.node.select()\n          }\n        })\n      }, 1)\n\n      // Make sure this is called AFTER the focusing has been processed by the browser\n      // Otherwise, this won't work\n      setTimeout(() => {\n        editor.dispatchCommand(ENABLE_SLASH_MENU_COMMAND, {\n          node: hoveredElementToUse.node as ParagraphNode,\n        })\n      }, 2)\n\n      event.stopPropagation()\n      event.preventDefault()\n    },\n    [editor, hoveredElement],\n  )\n\n  return createPortal(\n    <React.Fragment>\n      <button\n        className=\"icon add-block-menu\"\n        onClick={(event) => {\n          handleAddClick(event)\n        }}\n        ref={menuRef}\n        type=\"button\"\n      >\n        <div className={isEditable ? 'icon' : ''} />\n      </button>\n    </React.Fragment>,\n    anchorElem,\n  )\n}\n\nexport function AddBlockHandlePlugin({\n  anchorElem = document.body,\n}: {\n  anchorElem?: HTMLElement\n}): React.ReactElement {\n  const [editor] = useLexicalComposerContext()\n  return useAddBlockHandle(editor, anchorElem, editor._editable)\n}\n", "/**\n * Calculate distance between scrollerElem and target if target is not in scrollerElem\n */\nexport const calculateDistanceFromScrollerElem = (\n  scrollerElem: HTMLElement | null,\n  pageX: number,\n  pageY: number,\n  target: HTMLElement,\n  horizontalBuffer: number = 50,\n  verticalBuffer: number = 25,\n): number => {\n  let distanceFromScrollerElem = 0\n  if (scrollerElem && !scrollerElem.contains(target)) {\n    const { bottom, left, right, top } = scrollerElem.getBoundingClientRect()\n\n    const adjustedTop = top + window.scrollY\n    const adjustedBottom = bottom + window.scrollY\n\n    if (\n      pageY < adjustedTop - verticalBuffer ||\n      pageY > adjustedBottom + verticalBuffer ||\n      pageX < left - horizontalBuffer ||\n      pageX > right + horizontalBuffer\n    ) {\n      return -1\n    }\n\n    // This is used to allow the _draggableBlockElem to be found when the mouse is in the\n    // buffer zone around the scrollerElem.\n    if (pageX < left || pageX > right) {\n      distanceFromScrollerElem = pageX < left ? pageX - left : pageX - right\n    }\n  }\n  return distanceFromScrollerElem\n}\n", "import type { LexicalEditor, LexicalNode } from 'lexical'\n\nimport { $getNodeByKey } from 'lexical'\n\nimport { Point } from '../../../utils/point.js'\nimport { Rect } from '../../../utils/rect.js'\nimport { getBoundingClientRectWithoutTransform } from '../DraggableBlockPlugin/getBoundingRectWithoutTransform.js'\nimport { getCollapsedMargins } from '../utils/getCollapsedMargins.js'\nimport { getTopLevelNodeKeys } from '../utils/getTopLevelNodeKeys.js'\n\n// Directions\nconst Downward = 1\nconst Upward = -1\nconst Indeterminate = 0\n\ntype Props = {\n  anchorElem: HTMLElement\n  cache_threshold?: number\n  editor: LexicalEditor\n  /** fuzzy makes the search not exact. If no exact match found, find the closes node instead of returning null */\n  fuzzy?: boolean\n  horizontalOffset?: number\n  point: Point\n  /**\n   * By default, empty paragraphs are not returned. Set this to true to return empty paragraphs. @default false\n   */\n  returnEmptyParagraphs?: boolean\n  /**\n   * The index to start searching from. It can be a considerable performance optimization to start searching from the index of the\n   * previously found node, as the node is likely to be close to the next node.\n   */\n  startIndex?: number\n  useEdgeAsDefault?: boolean\n  verbose?: boolean\n}\n\ntype Output = {\n  blockElem: HTMLElement | null\n  blockNode: LexicalNode | null\n  foundAtIndex: number\n  isFoundNodeEmptyParagraph: boolean\n}\n\nconst cache = {\n  props: null as Props | null,\n  result: null as Output | null,\n}\n\nfunction isPointClose(previous: Point, current: Point, threshold: number = 20): boolean {\n  const dx = previous.x - current.x\n  const dy = previous.y - current.y\n  return dx * dx + dy * dy <= threshold * threshold\n}\n\nexport function getNodeCloseToPoint(props: Props): Output {\n  const {\n    anchorElem,\n    cache_threshold = 20,\n    editor,\n    fuzzy = false,\n    horizontalOffset = 0,\n    point: { x, y },\n    startIndex = 0,\n    useEdgeAsDefault = false,\n    verbose = false,\n  } = props\n\n  // Use cache\n  if (\n    cache_threshold > 0 &&\n    cache.props &&\n    cache.result &&\n    cache.props.fuzzy === props.fuzzy &&\n    cache.props.horizontalOffset === props.horizontalOffset &&\n    cache.props.useEdgeAsDefault === props.useEdgeAsDefault &&\n    isPointClose(cache.props.point, props.point, cache_threshold)\n  ) {\n    return cache.result\n  }\n\n  const anchorElementRect = anchorElem.getBoundingClientRect()\n  const topLevelNodeKeys = getTopLevelNodeKeys(editor)\n\n  const closestBlockElem: {\n    blockElem: HTMLElement | null\n    blockNode: LexicalNode | null\n    distance: number\n    foundAtIndex: number\n    isFoundNodeEmptyParagraph: boolean\n  } = {\n    blockElem: null,\n    blockNode: null,\n    distance: Infinity,\n    foundAtIndex: -1,\n    isFoundNodeEmptyParagraph: false,\n  }\n\n  // Return null if matching block element is the first or last node\n  editor.getEditorState().read(() => {\n    if (useEdgeAsDefault) {\n      const [firstNode, lastNode] = [\n        editor.getElementByKey(topLevelNodeKeys[0]),\n        editor.getElementByKey(topLevelNodeKeys[topLevelNodeKeys.length - 1]),\n      ]\n\n      const [firstNodeRect, lastNodeRect] = [\n        getBoundingClientRectWithoutTransform(firstNode),\n        getBoundingClientRectWithoutTransform(lastNode),\n      ]\n\n      if (firstNodeRect && lastNodeRect) {\n        if (y < firstNodeRect.top) {\n          closestBlockElem.blockElem = firstNode\n          closestBlockElem.distance = firstNodeRect.top - y\n          closestBlockElem.blockNode = $getNodeByKey(topLevelNodeKeys[0])\n          closestBlockElem.foundAtIndex = 0\n        } else if (y > lastNodeRect.bottom) {\n          closestBlockElem.distance = y - lastNodeRect.bottom\n          closestBlockElem.blockNode = $getNodeByKey(topLevelNodeKeys[topLevelNodeKeys.length - 1])\n          closestBlockElem.blockElem = lastNode\n          closestBlockElem.foundAtIndex = topLevelNodeKeys.length - 1\n        }\n\n        if (closestBlockElem?.blockElem) {\n          return {\n            blockElem: null,\n            isFoundNodeEmptyParagraph: false,\n          } as Output\n        }\n      }\n    }\n\n    // Find matching block element\n    let index = startIndex\n    let direction = Indeterminate\n\n    while (index >= 0 && index < topLevelNodeKeys.length) {\n      const key = topLevelNodeKeys[index]\n      const elem = editor.getElementByKey(key)\n      if (elem === null) {\n        break\n      }\n      const point = new Point(x + horizontalOffset, y)\n      //const domRect = Rect.fromDOM(elem)\n      // Do not consider transform of blocks when calculating distance\n      const domRect = Rect.fromDOMRect(getBoundingClientRectWithoutTransform(elem))\n\n      const { marginBottom, marginTop } = getCollapsedMargins(elem)\n\n      const rect = domRect.generateNewRect({\n        bottom: domRect.bottom + marginBottom,\n        left: anchorElementRect.left,\n        right: anchorElementRect.right,\n        top: domRect.top - marginTop,\n      })\n\n      const { distance, isOnBottomSide, isOnTopSide } = rect.distanceFromPoint(point)\n\n      if (distance === 0) {\n        closestBlockElem.blockElem = elem\n        closestBlockElem.blockNode = $getNodeByKey(key)\n        closestBlockElem.foundAtIndex = index\n        closestBlockElem.distance = distance\n\n        // Check if blockNode is an empty text node\n        if (\n          closestBlockElem.blockNode &&\n          closestBlockElem.blockNode.getType() === 'paragraph' &&\n          closestBlockElem.blockNode.getTextContent() === ''\n        ) {\n          if (!fuzzy && !props.returnEmptyParagraphs) {\n            closestBlockElem.blockElem = null\n            closestBlockElem.blockNode = null\n          }\n\n          closestBlockElem.isFoundNodeEmptyParagraph = true\n        }\n        break\n      } else if (fuzzy) {\n        if (distance < closestBlockElem.distance) {\n          closestBlockElem.blockElem = elem\n          closestBlockElem.blockNode = $getNodeByKey(key)\n          closestBlockElem.distance = distance\n          closestBlockElem.foundAtIndex = index\n        }\n      }\n\n      if (direction === Indeterminate) {\n        if (isOnTopSide) {\n          direction = Upward\n        } else if (isOnBottomSide) {\n          direction = Downward\n        } else {\n          // stop search block element\n          direction = Infinity\n        }\n      }\n\n      index += direction\n    }\n  })\n\n  // Store in cache before returning\n  cache.props = props\n  cache.result = {\n    blockElem: closestBlockElem.blockElem,\n    blockNode: closestBlockElem.blockNode,\n    foundAtIndex: closestBlockElem.foundAtIndex,\n    isFoundNodeEmptyParagraph: closestBlockElem.isFoundNodeEmptyParagraph,\n  }\n\n  return {\n    blockElem: closestBlockElem.blockElem,\n    blockNode: closestBlockElem.blockNode,\n    foundAtIndex: closestBlockElem.foundAtIndex,\n    isFoundNodeEmptyParagraph: closestBlockElem.isFoundNodeEmptyParagraph,\n  }\n}\n", "export function getBoundingClientRectWithoutTransform(elem: HTMLElement): DOMRect {\n  const rect = elem.getBoundingClientRect()\n\n  // Extract the translation value from the transform style\n  const transformValue = getComputedStyle(elem).getPropertyValue('transform')\n  if (!transformValue || transformValue === 'none') {\n    return rect\n  }\n\n  const lastNumberOfTransformValue = transformValue.split(',').pop()\n  rect.y = rect.y - Number(lastNumberOfTransformValue.replace(')', ''))\n\n  // Return the original bounding rect if no translation is applied\n  return rect\n}\n", "export function getCollapsedMargins(elem: HTMLElement): {\n  marginBottom: number\n  marginTop: number\n} {\n  const getMargin = (element: Element | null, margin: 'marginBottom' | 'marginTop'): number =>\n    element ? parseFloat(window.getComputedStyle(element)[margin]) : 0\n\n  const { marginBottom, marginTop } = window.getComputedStyle(elem)\n  const prevElemSiblingMarginBottom = getMargin(elem.previousElementSibling, 'marginBottom')\n  const nextElemSiblingMarginTop = getMargin(elem.nextElementSibling, 'marginTop')\n  const collapsedTopMargin = Math.max(parseFloat(marginTop), prevElemSiblingMarginBottom)\n  const collapsedBottomMargin = Math.max(parseFloat(marginBottom), nextElemSiblingMarginTop)\n\n  return { marginBottom: collapsedBottomMargin, marginTop: collapsedTopMargin }\n}\n", "import type { LexicalEditor } from 'lexical'\n\nimport { $getRoot } from 'lexical'\n\nexport function getTopLevelNodeKeys(editor: LexicalEditor): string[] {\n  return editor.getEditorState().read(() => $getRoot().getChildrenKeys())\n}\n", "export function isOnHandleElement(element: HTMLElement, handleElementClassName: string): boolean {\n  return !!element.closest(`.${handleElementClassName}`)\n}\n", "const replacedElements = [\n  'IMG',\n  'INPUT',\n  'TEXTAREA',\n  'SELECT',\n  'BUTTON',\n  'VIDEO',\n  'OBJECT',\n  'EMBED',\n  'IFRAME',\n  'HR',\n]\n\n/**\n * From ChatGPT, only that verified it works for HR elements.\n *\n * HTML Elements can have CSS lineHeight applied to them, but it doesn't always affect the visual layout.\n * This function checks if the line-height property has an effect on the element's layout.\n * @param htmlElem\n */\nexport function doesLineHeightAffectElement(htmlElem: HTMLElement) {\n  if (!htmlElem) return false\n\n  // Check for replaced elements, elements that typically don't support line-height adjustments,\n  // and elements without visible content\n\n  if (\n    replacedElements.includes(htmlElem.tagName) ||\n    htmlElem.offsetHeight === 0 ||\n    htmlElem.offsetWidth === 0\n  ) {\n    return false\n  }\n\n  // Check for specific CSS properties that negate line-height's visual effects\n  const style = window.getComputedStyle(htmlElem)\n  if (\n    style.display === 'table-cell' ||\n    style.position === 'absolute' ||\n    style.visibility === 'hidden' ||\n    style.opacity === '0'\n  ) {\n    return false\n  }\n\n  // This is a basic check, and there can be more complex scenarios where line-height doesn't have an effect.\n  return true\n}\n", "import { doesLineHeightAffectElement } from './doesLineHeightAffectElement.js'\n\nexport function setHandlePosition(\n  targetElem: HTMLElement | null,\n  handleElem: HTMLElement,\n  anchorElem: HTMLElement,\n  leftOffset: number = 0, // SPACE\n) {\n  if (!targetElem) {\n    handleElem.style.opacity = '0'\n    handleElem.style.transform = 'translate(-10000px, -10000px)'\n    return\n  }\n\n  const targetRect = targetElem.getBoundingClientRect()\n  const targetStyle = window.getComputedStyle(targetElem)\n  const floatingElemRect = handleElem.getBoundingClientRect()\n  const anchorElementRect = anchorElem.getBoundingClientRect()\n\n  let top: number\n\n  const shouldDisplayHandleInCenter = targetRect.height < 60\n\n  if (!shouldDisplayHandleInCenter) {\n    // No need to let line height affect the re-positioning of the floating element if line height has no\n    // visual effect on the element. Otherwise, the floating element will be positioned incorrectly.\n    const actualLineHeight = doesLineHeightAffectElement(targetElem)\n      ? parseInt(targetStyle.lineHeight, 10)\n      : 0\n\n    top =\n      targetRect.top + (actualLineHeight - floatingElemRect.height) / 2 - anchorElementRect.top - 1 // 1px inaccuracy\n  } else {\n    top =\n      targetRect.top -\n      floatingElemRect.height / 2 -\n      anchorElementRect.top +\n      targetRect.height / 2 -\n      1 // 1px inaccuracy\n  }\n\n  const left = leftOffset\n\n  handleElem.style.opacity = '1'\n  handleElem.style.transform = `translate(${left}px, ${top}px)`\n}\n", "'use client'\nimport type { LexicalEditor } from 'lexical'\nimport type { DragEvent as ReactDragEvent } from 'react'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { eventFiles } from '@lexical/rich-text'\nimport { $getNearestNodeFromDOMNode, $getNodeByKey } from 'lexical'\nimport * as React from 'react'\nimport { useEffect, useRef, useState } from 'react'\nimport { createPortal } from 'react-dom'\n\nimport { useEditorConfigContext } from '../../../config/client/EditorConfigProvider.js'\nimport { isHTMLElement } from '../../../utils/guard.js'\nimport { Point } from '../../../utils/point.js'\nimport { calculateDistanceFromScrollerElem } from '../utils/calculateDistanceFromScrollerElem.js'\nimport { getNodeCloseToPoint } from '../utils/getNodeCloseToPoint.js'\nimport { getTopLevelNodeKeys } from '../utils/getTopLevelNodeKeys.js'\nimport { isOnHandleElement } from '../utils/isOnHandleElement.js'\nimport { setHandlePosition } from '../utils/setHandlePosition.js'\nimport { getBoundingClientRectWithoutTransform } from './getBoundingRectWithoutTransform.js'\nimport { setTargetLine } from './setTargetLine.js'\n\nconst DRAGGABLE_BLOCK_MENU_CLASSNAME = 'draggable-block-menu'\nconst DRAG_DATA_FORMAT = 'application/x-lexical-drag-block'\n\nlet prevIndex = Infinity\n\nfunction getCurrentIndex(keysLength: number): number {\n  if (keysLength === 0) {\n    return Infinity\n  }\n  if (prevIndex >= 0 && prevIndex < keysLength) {\n    return prevIndex\n  }\n\n  return Math.floor(keysLength / 2)\n}\n\nfunction setDragImage(dataTransfer: DataTransfer, draggableBlockElem: HTMLElement) {\n  const { transform } = draggableBlockElem.style\n\n  // Remove dragImage borders\n  dataTransfer.setDragImage(draggableBlockElem, 0, 0)\n\n  setTimeout(() => {\n    draggableBlockElem.style.transform = transform\n  })\n}\n\nfunction hideTargetLine(\n  targetLineElem: HTMLElement | null,\n  lastTargetBlockElem: HTMLElement | null,\n) {\n  if (targetLineElem) {\n    targetLineElem.style.opacity = '0'\n  }\n  if (lastTargetBlockElem) {\n    lastTargetBlockElem.style.opacity = ''\n    // Delete marginBottom and marginTop values we set\n    lastTargetBlockElem.style.marginBottom = ''\n    lastTargetBlockElem.style.marginTop = ''\n    //lastTargetBlock.style.border = 'none'\n  }\n}\n\nfunction useDraggableBlockMenu(\n  editor: LexicalEditor,\n  anchorElem: HTMLElement,\n  isEditable: boolean,\n): React.ReactElement {\n  const scrollerElem = anchorElem.parentElement\n\n  const menuRef = useRef<HTMLDivElement>(null)\n  const targetLineRef = useRef<HTMLDivElement>(null)\n  const debugHighlightRef = useRef<HTMLDivElement>(null)\n  const isDraggingBlockRef = useRef<boolean>(false)\n  const [draggableBlockElem, setDraggableBlockElem] = useState<HTMLElement | null>(null)\n  const [lastTargetBlock, setLastTargetBlock] = useState<{\n    boundingBox?: DOMRect\n    elem: HTMLElement | null\n    isBelow: boolean\n  }>(null)\n\n  const { editorConfig } = useEditorConfigContext()\n\n  const blockHandleHorizontalOffset = editorConfig?.admin?.hideGutter ? -44 : -8\n\n  useEffect(() => {\n    /**\n     * Handles positioning of the drag handle\n     */\n    function onDocumentMouseMove(event: MouseEvent) {\n      const target = event.target\n      if (!isHTMLElement(target)) {\n        return\n      }\n\n      const distanceFromScrollerElem = calculateDistanceFromScrollerElem(\n        scrollerElem,\n        event.pageX,\n        event.pageY,\n        target,\n      )\n      if (distanceFromScrollerElem === -1) {\n        setDraggableBlockElem(null)\n        return\n      }\n\n      if (isOnHandleElement(target, DRAGGABLE_BLOCK_MENU_CLASSNAME)) {\n        return\n      }\n\n      const topLevelNodeKeys = getTopLevelNodeKeys(editor)\n\n      const {\n        blockElem: _draggableBlockElem,\n        foundAtIndex,\n        isFoundNodeEmptyParagraph,\n      } = getNodeCloseToPoint({\n        anchorElem,\n        cache_threshold: 0,\n        editor,\n        horizontalOffset: -distanceFromScrollerElem,\n        point: new Point(event.x, event.y),\n        startIndex: getCurrentIndex(topLevelNodeKeys.length),\n        useEdgeAsDefault: false,\n        verbose: false,\n      })\n\n      prevIndex = foundAtIndex\n\n      //if (DEBUG && _draggableBlockElem) {\n      //targetBlockElem.style.border = '3px solid red'\n      // highlightElemOriginalPosition(debugHighlightRef, _draggableBlockElem, anchorElem)\n      //}\n\n      if (!_draggableBlockElem && !isFoundNodeEmptyParagraph) {\n        return\n      }\n\n      if (draggableBlockElem !== _draggableBlockElem) {\n        setDraggableBlockElem(_draggableBlockElem)\n      }\n    }\n\n    // Since the draggableBlockElem is outside the actual editor, we need to listen to the document\n    // to be able to detect when the mouse is outside the editor and respect a buffer around\n    // the scrollerElem to avoid the draggableBlockElem disappearing too early.\n    document?.addEventListener('mousemove', onDocumentMouseMove)\n\n    return () => {\n      document?.removeEventListener('mousemove', onDocumentMouseMove)\n    }\n  }, [scrollerElem, anchorElem, editor, draggableBlockElem])\n\n  useEffect(() => {\n    if (menuRef.current) {\n      setHandlePosition(\n        draggableBlockElem,\n        menuRef.current,\n        anchorElem,\n        blockHandleHorizontalOffset,\n      )\n    }\n  }, [anchorElem, draggableBlockElem, blockHandleHorizontalOffset])\n\n  useEffect(() => {\n    function onDragover(event: DragEvent): boolean {\n      if (!isDraggingBlockRef.current) {\n        return false\n      }\n      const [isFileTransfer] = eventFiles(event)\n      if (isFileTransfer) {\n        return false\n      }\n\n      const { pageY, target } = event\n      if (!isHTMLElement(target)) {\n        return false\n      }\n\n      const distanceFromScrollerElem = calculateDistanceFromScrollerElem(\n        scrollerElem,\n        event.pageX,\n        event.pageY,\n        target,\n        100,\n        50,\n      )\n\n      const topLevelNodeKeys = getTopLevelNodeKeys(editor)\n\n      const {\n        blockElem: targetBlockElem,\n        foundAtIndex,\n        isFoundNodeEmptyParagraph,\n      } = getNodeCloseToPoint({\n        anchorElem,\n        editor,\n        fuzzy: true,\n        horizontalOffset: -distanceFromScrollerElem,\n        point: new Point(event.x, event.y),\n        startIndex: getCurrentIndex(topLevelNodeKeys.length),\n        useEdgeAsDefault: true,\n        verbose: true,\n      })\n\n      prevIndex = foundAtIndex\n\n      const targetLineElem = targetLineRef.current\n      // targetBlockElem === null shouldn't happen\n      if (targetBlockElem === null || targetLineElem === null) {\n        return false\n      }\n\n      if (draggableBlockElem !== targetBlockElem) {\n        const { isBelow, willStayInSamePosition } = setTargetLine(\n          editorConfig?.admin?.hideGutter ? '0px' : '3rem',\n          blockHandleHorizontalOffset +\n            (editorConfig?.admin?.hideGutter\n              ? menuRef?.current?.getBoundingClientRect()?.width ?? 0\n              : -menuRef?.current?.getBoundingClientRect()?.width ?? 0),\n          targetLineElem,\n          targetBlockElem,\n          lastTargetBlock,\n          pageY,\n          anchorElem,\n          event,\n          debugHighlightRef,\n          isFoundNodeEmptyParagraph,\n        )\n\n        // Prevent default event to be able to trigger onDrop events\n        // Calling preventDefault() adds the green plus icon to the cursor,\n        // indicating that the drop is allowed.\n        event.preventDefault()\n\n        if (!willStayInSamePosition) {\n          setLastTargetBlock({\n            boundingBox: targetBlockElem.getBoundingClientRect(),\n            elem: targetBlockElem,\n            isBelow,\n          })\n        }\n      } else {\n        hideTargetLine(targetLineElem, lastTargetBlock?.elem)\n        setLastTargetBlock({\n          boundingBox: targetBlockElem.getBoundingClientRect(),\n          elem: targetBlockElem,\n          isBelow: false,\n        })\n      }\n\n      return true\n    }\n\n    function onDrop(event: DragEvent): boolean {\n      if (!isDraggingBlockRef.current) {\n        return false\n      }\n      const [isFileTransfer] = eventFiles(event)\n      if (isFileTransfer) {\n        return false\n      }\n      const { dataTransfer, pageY, target } = event\n      const dragData = dataTransfer?.getData(DRAG_DATA_FORMAT) || ''\n\n      editor.update(() => {\n        const draggedNode = $getNodeByKey(dragData)\n        if (!draggedNode) {\n          return false\n        }\n        if (!isHTMLElement(target)) {\n          return false\n        }\n        const distanceFromScrollerElem = calculateDistanceFromScrollerElem(\n          scrollerElem,\n          event.pageX,\n          event.pageY,\n          target,\n          100,\n          50,\n        )\n\n        const { blockElem: targetBlockElem, isFoundNodeEmptyParagraph } = getNodeCloseToPoint({\n          anchorElem,\n          editor,\n          fuzzy: true,\n          horizontalOffset: -distanceFromScrollerElem,\n          point: new Point(event.x, event.y),\n          useEdgeAsDefault: true,\n        })\n\n        if (!targetBlockElem) {\n          return false\n        }\n        const targetNode = $getNearestNodeFromDOMNode(targetBlockElem)\n        if (!targetNode) {\n          return false\n        }\n        if (targetNode === draggedNode) {\n          return true\n        }\n\n        const { height: targetBlockElemHeight, top: targetBlockElemTop } =\n          getBoundingClientRectWithoutTransform(targetBlockElem)\n\n        const mouseY = pageY\n        const isBelow = mouseY >= targetBlockElemTop + targetBlockElemHeight / 2 + window.scrollY\n\n        if (!isFoundNodeEmptyParagraph) {\n          if (isBelow) {\n            // below targetBlockElem\n            targetNode.insertAfter(draggedNode)\n          } else {\n            // above targetBlockElem\n            targetNode.insertBefore(draggedNode)\n          }\n        } else {\n          //\n          targetNode.insertBefore(draggedNode)\n          targetNode.remove()\n        }\n\n        /*\n        if (pageY >= targetBlockElemTop + targetBlockElemHeight / 2) {\n          targetNode.insertAfter(draggedNode)\n        } else {\n          targetNode.insertBefore(draggedNode)\n        }*/\n        if (draggableBlockElem !== null) {\n          setDraggableBlockElem(null)\n        }\n\n        // find all previous elements with lexical-block-highlighter class and remove them\n        const allPrevHighlighters = document.querySelectorAll('.lexical-block-highlighter')\n        allPrevHighlighters.forEach((highlighter) => {\n          highlighter.remove()\n        })\n\n        const newInsertedElem = editor.getElementByKey(draggedNode.getKey())\n        setTimeout(() => {\n          // add new temp html element to newInsertedElem with the same height and width and the class block-selected\n          // to highlight the new inserted element\n          const newInsertedElemRect = newInsertedElem.getBoundingClientRect()\n\n          const highlightElem = document.createElement('div')\n          highlightElem.className = 'lexical-block-highlighter'\n\n          // if html data-theme is dark, set the highlighter color to white\n          if (document.documentElement.getAttribute('data-theme') === 'dark') {\n            highlightElem.style.backgroundColor = 'white'\n          } else {\n            highlightElem.style.backgroundColor = 'black'\n          }\n\n          highlightElem.style.transition = 'opacity 0.1s ease-in-out'\n          highlightElem.style.zIndex = '1'\n          highlightElem.style.pointerEvents = 'none'\n          highlightElem.style.boxSizing = 'border-box'\n          highlightElem.style.borderRadius = '4px'\n          highlightElem.style.position = 'absolute'\n          document.body.appendChild(highlightElem)\n\n          highlightElem.style.opacity = '0.1'\n\n          highlightElem.style.height = `${newInsertedElemRect.height + 8}px`\n          highlightElem.style.width = `${newInsertedElemRect.width + 8}px`\n          highlightElem.style.top = `${newInsertedElemRect.top + window.scrollY - 4}px`\n          highlightElem.style.left = `${newInsertedElemRect.left - 4}px`\n\n          setTimeout(() => {\n            highlightElem.style.opacity = '0'\n            setTimeout(() => {\n              highlightElem.remove()\n            }, 1000)\n          }, 3000)\n        }, 120)\n      })\n\n      return true\n    }\n\n    // register onDragover event listeners:\n    document.addEventListener('dragover', onDragover)\n    // register onDrop event listeners:\n    document.addEventListener('drop', onDrop)\n\n    return () => {\n      document.removeEventListener('dragover', onDragover)\n      document.removeEventListener('drop', onDrop)\n    }\n  }, [\n    scrollerElem,\n    blockHandleHorizontalOffset,\n    anchorElem,\n    editor,\n    lastTargetBlock,\n    draggableBlockElem,\n    editorConfig?.admin?.hideGutter,\n  ])\n\n  function onDragStart(event: ReactDragEvent<HTMLDivElement>): void {\n    const dataTransfer = event.dataTransfer\n    if (!dataTransfer || !draggableBlockElem) {\n      return\n    }\n    setDragImage(dataTransfer, draggableBlockElem)\n    let nodeKey = ''\n    editor.update(() => {\n      const node = $getNearestNodeFromDOMNode(draggableBlockElem)\n      if (node) {\n        nodeKey = node.getKey()\n      }\n    })\n    isDraggingBlockRef.current = true\n    dataTransfer.setData(DRAG_DATA_FORMAT, nodeKey)\n  }\n\n  function onDragEnd(): void {\n    isDraggingBlockRef.current = false\n    hideTargetLine(targetLineRef.current, lastTargetBlock?.elem)\n  }\n\n  return createPortal(\n    <React.Fragment>\n      <div\n        className=\"icon draggable-block-menu\"\n        draggable\n        onDragEnd={onDragEnd}\n        onDragStart={onDragStart}\n        ref={menuRef}\n      >\n        <div className={isEditable ? 'icon' : ''} />\n      </div>\n      <div className=\"draggable-block-target-line\" ref={targetLineRef} />\n      <div className=\"debug-highlight\" ref={debugHighlightRef} />\n    </React.Fragment>,\n    anchorElem,\n  )\n}\n\nexport function DraggableBlockPlugin({\n  anchorElem = document.body,\n}: {\n  anchorElem?: HTMLElement\n}): React.ReactElement {\n  const [editor] = useLexicalComposerContext()\n  return useDraggableBlockMenu(editor, anchorElem, editor._editable)\n}\n", "import type React from 'react'\n\nimport { getBoundingClientRectWithoutTransform } from './getBoundingRectWithoutTransform.js'\n\nexport function highlightElemOriginalPosition(\n  debugHighlightRef: React.RefObject<HTMLDivElement | null>,\n  htmlElem: HTMLElement,\n  anchorElem: HTMLElement,\n) {\n  if (!debugHighlightRef.current) {\n    // If the ref doesn't point to an existing element, we can't set styles\n    return\n  }\n\n  const { left: anchorLeft, top: anchorTop } = anchorElem.getBoundingClientRect()\n\n  // Get computed styles of the given element\n  const boundingRect = getBoundingClientRectWithoutTransform(htmlElem)\n\n  // Extract necessary styles (ignoring transform)\n  const width = boundingRect.width\n  const height = boundingRect.height\n  const top = boundingRect.top - anchorTop\n  const left = boundingRect.left - anchorLeft\n\n  debugHighlightRef.current.style.border = '2px solid green'\n  debugHighlightRef.current.style.boxSizing = 'border-box'\n  debugHighlightRef.current.style.height = height + 'px'\n  debugHighlightRef.current.style.pointerEvents = 'none'\n  debugHighlightRef.current.style.position = 'absolute'\n  debugHighlightRef.current.style.top = top + 'px'\n  debugHighlightRef.current.style.left = left + 'px'\n  debugHighlightRef.current.style.width = width + 'px'\n  debugHighlightRef.current.style.zIndex = '1000'\n  debugHighlightRef.current.style.opacity = '0.5'\n}\n", "import { getCollapsedMargins } from '../utils/getCollapsedMargins.js'\nimport { getBoundingClientRectWithoutTransform } from './getBoundingRectWithoutTransform.js'\nimport { highlightElemOriginalPosition } from './highlightElemOriginalPosition.js'\nconst TARGET_LINE_HALF_HEIGHT = 25\nconst TEXT_BOX_HORIZONTAL_PADDING = -24\nconst DEBUG = false\n\nlet animationTimer = 0\n\nexport function setTargetLine(\n  offsetWidth: string,\n  offsetLeft: number,\n  targetLineElem: HTMLElement,\n  targetBlockElem: HTMLElement,\n  lastTargetBlock: {\n    boundingBox?: DOMRect\n    elem: HTMLElement | null\n    isBelow: boolean\n  },\n  mouseY: number,\n  anchorElem: HTMLElement,\n  event: DragEvent,\n  debugHighlightRef: React.RefObject<HTMLDivElement | null>,\n  isFoundNodeEmptyParagraph: boolean = false,\n) {\n  const { height: targetBlockElemHeight, top: targetBlockElemTop } =\n    targetBlockElem.getBoundingClientRect() // used to be getBoundingClientRectWithoutTransform. Not sure what's better, but the normal getBoundingClientRect seems to work fine\n  const { top: anchorTop, width: anchorWidth } = anchorElem.getBoundingClientRect()\n\n  const { marginBottom, marginTop } = getCollapsedMargins(targetBlockElem)\n  let lineTop = targetBlockElemTop\n\n  const isBelow = mouseY >= targetBlockElemTop + targetBlockElemHeight / 2 + window.scrollY\n\n  let willStayInSamePosition = false\n\n  /**\n   * Do not run any transform or changes if the actual new line position would be the same (even if it's now inserted BEFORE rather than AFTER - position would still be the same)\n   * This prevents unnecessary flickering.\n   *\n   * We still need to let it run even if the position (IGNORING the transform) would not change, as the transform animation is not finished yet. This is what animationTimer does. Otherwise, the positioning will be inaccurate\n   */\n  if (lastTargetBlock?.elem) {\n    if (targetBlockElem !== lastTargetBlock?.elem) {\n      if (\n        isBelow &&\n        lastTargetBlock?.elem &&\n        lastTargetBlock?.elem === targetBlockElem.nextElementSibling\n      ) {\n        animationTimer++\n\n        if (animationTimer < 200) {\n          willStayInSamePosition = true\n        }\n      } else if (\n        !isBelow &&\n        lastTargetBlock?.elem &&\n        lastTargetBlock?.elem === targetBlockElem.previousElementSibling\n      ) {\n        animationTimer++\n        if (animationTimer < 200) {\n          willStayInSamePosition = true\n        }\n      }\n    } else {\n      animationTimer++\n\n      const lastBoundingBoxPosition = lastTargetBlock?.boundingBox?.y\n      const currentBoundingBoxPosition = targetBlockElem.getBoundingClientRect().y\n\n      if (\n        (isBelow === lastTargetBlock?.isBelow &&\n          lastBoundingBoxPosition === currentBoundingBoxPosition) ||\n        animationTimer < 200\n      ) {\n        willStayInSamePosition = false\n      }\n    }\n  }\n  if (willStayInSamePosition) {\n    return {\n      isBelow,\n      willStayInSamePosition,\n    }\n  }\n\n  /**\n   * Paragraphs need no isBelow/above handling,\n   */\n  if (!isFoundNodeEmptyParagraph) {\n    //if (!isFoundNodeEmptyParagraph) {\n    if (isBelow) {\n      // below targetBlockElem\n      lineTop += targetBlockElemHeight + marginBottom / 2\n    } else {\n      // above targetBlockElem\n      lineTop -= marginTop / 2\n    }\n  } else {\n    lineTop += targetBlockElemHeight / 2\n  }\n\n  let targetElemTranslate2 = 0\n\n  if (!isFoundNodeEmptyParagraph) {\n    if (isBelow) {\n      targetElemTranslate2 = -TARGET_LINE_HALF_HEIGHT\n    } else {\n      targetElemTranslate2 = TARGET_LINE_HALF_HEIGHT\n    }\n  }\n\n  const top = lineTop - anchorTop + targetElemTranslate2\n\n  const left = TEXT_BOX_HORIZONTAL_PADDING - offsetLeft\n\n  targetLineElem.style.width = `calc(${anchorWidth}px - ${offsetWidth})`\n  targetLineElem.style.opacity = '.4'\n\n  /**\n   * Move around element below or above the line (= the target / targetBlockElem). Creates \"space\" for the targetLineElem\n   *\n   * Not needed for empty paragraphs, as an empty paragraph is enough space for the targetLineElem anyways.\n   */\n  //targetBlockElem.style.opacity = '0.4'\n  const buffer = 12 // creates more spacing/padding so target line is not directly next to the targetBlockElem\n  if (!isFoundNodeEmptyParagraph) {\n    if (isBelow) {\n      targetBlockElem.style.marginBottom = TARGET_LINE_HALF_HEIGHT * 2 + buffer + 'px'\n      targetLineElem.style.transform = `translate(${left}px, calc(${top}px - ${'0px'}))`\n    } else {\n      targetBlockElem.style.marginTop = TARGET_LINE_HALF_HEIGHT * 2 + buffer + 'px'\n      targetLineElem.style.transform = `translate(${left}px, calc(${top - TARGET_LINE_HALF_HEIGHT * 2}px - ${'0px'}))`\n    }\n  } else {\n    targetLineElem.style.transform = `translate(${left}px, ${top - TARGET_LINE_HALF_HEIGHT}px)`\n  }\n\n  if (DEBUG) {\n    //targetBlockElem.style.border = '3px solid red'\n    highlightElemOriginalPosition(debugHighlightRef, targetBlockElem, anchorElem)\n  }\n\n  /**\n   * Properly reset previous targetBlockElem styles\n   */\n  lastTargetBlock.elem.style.opacity = ''\n\n  if (lastTargetBlock?.elem === targetBlockElem) {\n    if (isBelow) {\n      lastTargetBlock.elem.style.marginTop = ''\n    } else {\n      lastTargetBlock.elem.style.marginBottom = ''\n    }\n  } else {\n    lastTargetBlock.elem.style.marginBottom = ''\n    lastTargetBlock.elem.style.marginTop = ''\n  }\n  animationTimer = 0\n  return {\n    isBelow,\n    willStayInSamePosition,\n  }\n}\n", "import type { JSX } from 'react'\n\nimport { ContentEditable } from '@lexical/react/LexicalContentEditable.js'\nimport * as React from 'react'\n\nexport function LexicalContentEditable({ className }: { className?: string }): JSX.Element {\n  return <ContentEditable className={className ?? 'ContentEditable__root'} />\n}\n"],
  "mappings": "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",
  "names": ["FieldDescription", "FieldError", "FieldLabel", "useField", "useFieldProps", "withCondition", "useCallback", "ErrorBoundary", "LexicalComposer", "React", "useMemo", "useLexicalComposerContext", "LexicalErrorBoundary", "HistoryPlugin", "OnChangePlugin", "RichTextPlugin", "TabIndentationPlugin", "useTranslation", "BLUR_COMMAND", "COMMAND_PRIORITY_LOW", "FOCUS_COMMAND", "React", "useEffect", "useState", "jsx", "EditorPlugin", "anchorElem", "clientProps", "plugin", "LexicalMarkdownShortcutPlugin", "jsx", "MarkdownShortcutPlugin", "editorConfig", "useEditorConfigContext", "LexicalMarkdownShortcutPlugin", "useLexicalComposerContext", "useTranslation", "useCallback", "useMemo", "useState", "React", "ReactDOM", "useCallback", "useMenuTriggerMatch", "trigger", "maxLength", "minLength", "useCallback", "query", "validChars", "PUNCTUATION", "match", "maybeLeadingWhitespace", "matchingString", "jsx", "jsxs", "baseClass", "SlashMenuItem", "isSelected", "item", "onClick", "onMouseEnter", "i18n", "useTranslation", "className", "title", "SlashMenuPlugin", "anchorElem", "editor", "useLexicalComposerContext", "queryString", "setQueryString", "useState", "editorConfig", "useEditorConfigContext", "checkForTriggerMatch", "useMenuTriggerMatch", "getDynamicItems", "useCallback", "groupWithItems", "dynamicItem", "dynamicGroupWithItems", "groups", "useMemo", "groupsWithItems", "groupWithItem", "group", "filteredItems", "itemTitle", "keyword", "dynamicItemGroups", "dynamicGroup", "onSelectItem", "selectedItem", "nodeToRemove", "closeMenu", "matchingString", "LexicalTypeaheadMenuPlugin", "anchorElementRef", "selectItemAndCleanUp", "selectedItemKey", "setSelectedItemKey", "groupTitle", "oi", "useLexicalComposerContext", "$createParagraphNode", "React", "useCallback", "useEffect", "useRef", "useState", "createPortal", "calculateDistanceFromScrollerElem", "scrollerElem", "pageX", "pageY", "target", "horizontalBuffer", "verticalBuffer", "distanceFromScrollerElem", "bottom", "left", "right", "top", "adjustedTop", "adjustedBottom", "$getNodeByKey", "getBoundingClientRectWithoutTransform", "elem", "rect", "transformValue", "lastNumberOfTransformValue", "getCollapsedMargins", "elem", "getMargin", "element", "margin", "marginBottom", "marginTop", "prevElemSiblingMarginBottom", "nextElemSiblingMarginTop", "collapsedTopMargin", "$getRoot", "getTopLevelNodeKeys", "editor", "Downward", "Upward", "Indeterminate", "cache", "isPointClose", "previous", "current", "threshold", "dx", "dy", "getNodeCloseToPoint", "props", "anchorElem", "cache_threshold", "editor", "fuzzy", "horizontalOffset", "x", "y", "startIndex", "useEdgeAsDefault", "verbose", "anchorElementRect", "topLevelNodeKeys", "getTopLevelNodeKeys", "closestBlockElem", "firstNode", "lastNode", "firstNodeRect", "lastNodeRect", "getBoundingClientRectWithoutTransform", "$getNodeByKey", "index", "direction", "key", "elem", "point", "Point", "domRect", "Rect", "marginBottom", "marginTop", "getCollapsedMargins", "rect", "distance", "isOnBottomSide", "isOnTopSide", "isOnHandleElement", "element", "handleElementClassName", "replacedElements", "doesLineHeightAffectElement", "htmlElem", "style", "setHandlePosition", "targetElem", "handleElem", "anchorElem", "leftOffset", "targetRect", "targetStyle", "floatingElemRect", "anchorElementRect", "top", "actualLineHeight", "doesLineHeightAffectElement", "left", "jsx", "ADD_BLOCK_MENU_CLASSNAME", "prevIndex", "getCurrentIndex", "keysLength", "useAddBlockHandle", "editor", "anchorElem", "isEditable", "scrollerElem", "editorConfig", "useEditorConfigContext", "blockHandleHorizontalOffset", "menuRef", "useRef", "hoveredElement", "setHoveredElement", "useState", "useEffect", "onDocumentMouseMove", "event", "target", "isHTMLElement", "distanceFromScrollerElem", "calculateDistanceFromScrollerElem", "isOnHandleElement", "topLevelNodeKeys", "getTopLevelNodeKeys", "_emptyBlockElem", "blockNode", "foundAtIndex", "getNodeCloseToPoint", "Point", "setHandlePosition", "handleAddClick", "useCallback", "hoveredElementToUse", "isEmptyParagraph", "newParagraph", "$createParagraphNode", "ENABLE_SLASH_MENU_COMMAND", "createPortal", "AddBlockHandlePlugin", "useLexicalComposerContext", "useLexicalComposerContext", "eventFiles", "$getNearestNodeFromDOMNode", "$getNodeByKey", "React", "useEffect", "useRef", "useState", "createPortal", "highlightElemOriginalPosition", "debugHighlightRef", "htmlElem", "anchorElem", "anchorLeft", "anchorTop", "boundingRect", "getBoundingClientRectWithoutTransform", "width", "height", "top", "left", "TARGET_LINE_HALF_HEIGHT", "TEXT_BOX_HORIZONTAL_PADDING", "DEBUG", "animationTimer", "setTargetLine", "offsetWidth", "offsetLeft", "targetLineElem", "targetBlockElem", "lastTargetBlock", "mouseY", "anchorElem", "event", "debugHighlightRef", "isFoundNodeEmptyParagraph", "targetBlockElemHeight", "targetBlockElemTop", "anchorTop", "anchorWidth", "marginBottom", "marginTop", "getCollapsedMargins", "lineTop", "isBelow", "willStayInSamePosition", "lastBoundingBoxPosition", "currentBoundingBoxPosition", "targetElemTranslate2", "top", "left", "buffer", "highlightElemOriginalPosition", "jsx", "jsxs", "DRAGGABLE_BLOCK_MENU_CLASSNAME", "DRAG_DATA_FORMAT", "prevIndex", "getCurrentIndex", "keysLength", "setDragImage", "dataTransfer", "draggableBlockElem", "transform", "hideTargetLine", "targetLineElem", "lastTargetBlockElem", "useDraggableBlockMenu", "editor", "anchorElem", "isEditable", "scrollerElem", "menuRef", "useRef", "targetLineRef", "debugHighlightRef", "isDraggingBlockRef", "setDraggableBlockElem", "useState", "lastTargetBlock", "setLastTargetBlock", "editorConfig", "useEditorConfigContext", "blockHandleHorizontalOffset", "useEffect", "onDocumentMouseMove", "event", "target", "isHTMLElement", "distanceFromScrollerElem", "calculateDistanceFromScrollerElem", "isOnHandleElement", "topLevelNodeKeys", "getTopLevelNodeKeys", "_draggableBlockElem", "foundAtIndex", "isFoundNodeEmptyParagraph", "getNodeCloseToPoint", "Point", "setHandlePosition", "onDragover", "isFileTransfer", "eventFiles", "pageY", "targetBlockElem", "isBelow", "willStayInSamePosition", "setTargetLine", "onDrop", "dragData", "draggedNode", "$getNodeByKey", "targetNode", "$getNearestNodeFromDOMNode", "targetBlockElemHeight", "targetBlockElemTop", "getBoundingClientRectWithoutTransform", "highlighter", "newInsertedElem", "newInsertedElemRect", "highlightElem", "onDragStart", "nodeKey", "node", "onDragEnd", "createPortal", "DraggableBlockPlugin", "useLexicalComposerContext", "ContentEditable", "jsx", "LexicalContentEditable", "className", "jsx", "jsxs", "LexicalEditor", "props", "editorConfig", "editorContainerRef", "onChange", "editorConfigContext", "useEditorConfigContext", "editor", "useLexicalComposerContext", "t", "useTranslation", "floatingAnchorElem", "setFloatingAnchorElem", "useState", "onRef", "_floatingAnchorElem", "useEffect", "handleFocus", "handleBlur", "unregisterFocus", "FOCUS_COMMAND", "COMMAND_PRIORITY_LOW", "unregisterBlur", "BLUR_COMMAND", "isSmallWidthViewport", "setIsSmallWidthViewport", "updateViewPortWidth", "isNextSmallWidthViewport", "plugin", "EditorPlugin", "RichTextPlugin", "LexicalErrorBoundary", "LexicalContentEditable", "OnChangePlugin", "editorState", "tags", "DraggableBlockPlugin", "AddBlockHandlePlugin", "SlashMenuPlugin", "HistoryPlugin", "MarkdownShortcutPlugin", "TabIndentationPlugin", "jsx", "NestProviders", "children", "providers", "Component", "LexicalProvider", "props", "editorConfig", "fieldProps", "onChange", "path", "readOnly", "value", "parentContext", "useEditorConfigContext", "editorContainerRef", "processedValue", "useMemo", "processed", "hook", "initialConfig", "getEnabledNodes", "error", "LexicalComposer", "EditorConfigProvider", "LexicalEditor", "jsx", "jsxs", "baseClass", "_RichText", "props", "name", "CustomDescription", "CustomError", "CustomLabel", "className", "descriptionProps", "editorConfig", "errorProps", "label", "labelProps", "pathFromProps", "readOnly", "required", "style", "validate", "width", "memoizedValidate", "useCallback", "value", "validationOptions", "pathFromContext", "useFieldProps", "fieldType", "useField", "errorMessage", "initialValue", "path", "schemaPath", "setValue", "showError", "classes", "FieldError", "FieldLabel", "ErrorBoundary", "fallbackRender", "LexicalProvider", "editorState", "serializedEditorState", "hook", "FieldDescription", "error", "RichText", "withCondition"]
}

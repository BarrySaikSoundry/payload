{
  "version": 3,
  "sources": ["../../../src/lexical/nodes/index.ts", "../../../src/lexical/plugins/SlashMenu/LexicalTypeaheadMenuPlugin/index.tsx", "../../../src/lexical/plugins/SlashMenu/LexicalTypeaheadMenuPlugin/LexicalMenu.tsx", "../../../src/lexical/utils/guard.ts", "../../../src/lexical/utils/point.ts", "../../../src/lexical/utils/rect.ts"],
  "sourcesContent": ["import type { Klass, LexicalNode, LexicalNodeReplacement } from 'lexical'\n\nimport type { SanitizedClientEditorConfig, SanitizedServerEditorConfig } from '../config/types.js'\n\nexport function getEnabledNodes({\n  editorConfig,\n}: {\n  editorConfig: SanitizedClientEditorConfig | SanitizedServerEditorConfig\n}): Array<Klass<LexicalNode> | LexicalNodeReplacement> {\n  return editorConfig.features.nodes.map((node) => {\n    if ('node' in node) {\n      return node.node\n    }\n    return node\n  })\n}\n", "'use client'\nimport type {\n  LexicalCommand,\n  LexicalEditor,\n  ParagraphNode,\n  RangeSelection,\n  TextNode,\n} from 'lexical'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { mergeRegister } from '@lexical/utils'\nimport {\n  $getSelection,\n  $isRangeSelection,\n  $isTextNode,\n  COMMAND_PRIORITY_LOW,\n  createCommand,\n} from 'lexical'\nimport { type JSX, useCallback, useEffect, useState } from 'react'\nimport * as React from 'react'\n\nimport type { MenuTextMatch, TriggerFn } from '../useMenuTriggerMatch.js'\nimport type { MenuRenderFn, MenuResolution } from './LexicalMenu.js'\nimport type { SlashMenuGroup, SlashMenuGroupInternal, SlashMenuItem } from './types.js'\n\nimport { LexicalMenu, useMenuAnchorRef } from './LexicalMenu.js'\n\nexport const PUNCTUATION = '\\\\.,\\\\+\\\\*\\\\?\\\\$\\\\@\\\\|#{}\\\\(\\\\)\\\\^\\\\-\\\\[\\\\]\\\\\\\\/!%\\'\"~=<>_:;'\n\nfunction getTextUpToAnchor(selection: RangeSelection): null | string {\n  const anchor = selection.anchor\n  if (anchor.type !== 'text') {\n    return null\n  }\n  const anchorNode = anchor.getNode()\n  if (!anchorNode.isSimpleText()) {\n    return null\n  }\n  const anchorOffset = anchor.offset\n  return anchorNode.getTextContent().slice(0, anchorOffset)\n}\n\nfunction tryToPositionRange(leadOffset: number, range: Range, editorWindow: Window): boolean {\n  const domSelection = editorWindow.getSelection()\n  if (domSelection === null || !domSelection.isCollapsed) {\n    return false\n  }\n  const anchorNode = domSelection.anchorNode\n  const startOffset = leadOffset\n  const endOffset = domSelection.anchorOffset\n\n  if (anchorNode == null || endOffset == null) {\n    return false\n  }\n\n  try {\n    range.setStart(anchorNode, startOffset)\n    // if endOffset is 0, positioning the range for when you click the plus button to open the slash menu will fial\n    range.setEnd(anchorNode, endOffset > 1 ? endOffset : 1)\n  } catch (error) {\n    return false\n  }\n\n  return true\n}\n\nfunction getQueryTextForSearch(editor: LexicalEditor): null | string {\n  let text = null\n  editor.getEditorState().read(() => {\n    const selection = $getSelection()\n    if (!$isRangeSelection(selection)) {\n      return\n    }\n    text = getTextUpToAnchor(selection)\n  })\n  return text\n}\n\nfunction isSelectionOnEntityBoundary(editor: LexicalEditor, offset: number): boolean {\n  if (offset !== 0) {\n    return false\n  }\n  return editor.getEditorState().read(() => {\n    const selection = $getSelection()\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor\n      const anchorNode = anchor.getNode()\n      const prevSibling = anchorNode.getPreviousSibling()\n      return $isTextNode(prevSibling) && prevSibling.isTextEntity()\n    }\n    return false\n  })\n}\n\nfunction startTransition(callback: () => void) {\n  if (React.startTransition) {\n    React.startTransition(callback)\n  } else {\n    callback()\n  }\n}\n\n// Got from https://stackoverflow.com/a/42543908/2013580\nexport function getScrollParent(\n  element: HTMLElement,\n  includeHidden: boolean,\n): HTMLBodyElement | HTMLElement {\n  let style = getComputedStyle(element)\n  const excludeStaticParent = style.position === 'absolute'\n  const overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/\n  if (style.position === 'fixed') {\n    return document.body\n  }\n  for (let parent: HTMLElement | null = element; (parent = parent.parentElement); ) {\n    style = getComputedStyle(parent)\n    if (excludeStaticParent && style.position === 'static') {\n      continue\n    }\n    if (overflowRegex.test(style.overflow + style.overflowY + style.overflowX)) {\n      return parent\n    }\n  }\n  return document.body\n}\n\nexport { useDynamicPositioning } from './LexicalMenu.js'\n\nexport type TypeaheadMenuPluginProps = {\n  anchorClassName?: string\n  anchorElem: HTMLElement\n  groups: Array<SlashMenuGroupInternal>\n  menuRenderFn: MenuRenderFn\n  onClose?: () => void\n  onOpen?: (resolution: MenuResolution) => void\n  onQueryChange: (matchingString: null | string) => void\n  onSelectItem: (\n    item: SlashMenuItem,\n    textNodeContainingQuery: TextNode | null,\n    closeMenu: () => void,\n    matchingString: string,\n  ) => void\n  triggerFn: TriggerFn\n}\n\nexport const ENABLE_SLASH_MENU_COMMAND: LexicalCommand<{\n  node: ParagraphNode\n}> = createCommand('ENABLE_SLASH_MENU_COMMAND')\n\nexport function LexicalTypeaheadMenuPlugin({\n  anchorClassName,\n  anchorElem,\n  groups,\n  menuRenderFn,\n  onClose,\n  onOpen,\n  onQueryChange,\n  onSelectItem,\n  triggerFn,\n}: TypeaheadMenuPluginProps): JSX.Element | null {\n  const [editor] = useLexicalComposerContext()\n  const [resolution, setResolution] = useState<MenuResolution | null>(null)\n  const anchorElementRef = useMenuAnchorRef(anchorElem, resolution, setResolution, anchorClassName)\n\n  const closeTypeahead = useCallback(() => {\n    setResolution(null)\n    if (onClose != null && resolution !== null) {\n      onClose()\n    }\n  }, [onClose, resolution])\n\n  const openTypeahead = useCallback(\n    (res: MenuResolution) => {\n      setResolution(res)\n      if (onOpen != null && resolution === null) {\n        onOpen(res)\n      }\n    },\n    [onOpen, resolution],\n  )\n\n  // This is mainly used for the AddBlockHandlePlugin, so that the slash menu can be opened from there\n  useEffect(() => {\n    return mergeRegister(\n      editor.registerCommand(\n        ENABLE_SLASH_MENU_COMMAND,\n        ({ node }) => {\n          editor.getEditorState().read(() => {\n            const match: MenuTextMatch = {\n              leadOffset: 0,\n              matchingString: '',\n              replaceableString: '',\n            }\n            if (match !== null && !isSelectionOnEntityBoundary(editor, match.leadOffset)) {\n              if (node !== null) {\n                const editorWindow = editor._window ?? window\n                const range = editorWindow.document.createRange()\n\n                const isRangePositioned = tryToPositionRange(match.leadOffset, range, editorWindow)\n                if (isRangePositioned !== null) {\n                  startTransition(() =>\n                    openTypeahead({\n                      getRect: () => {\n                        return range.getBoundingClientRect()\n                      },\n                      match,\n                    }),\n                  )\n                }\n\n                return\n              }\n            }\n          })\n\n          return true\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n    )\n  }, [editor, openTypeahead])\n\n  useEffect(() => {\n    const updateListener = () => {\n      editor.getEditorState().read(() => {\n        const editorWindow = editor._window ?? window\n        const range = editorWindow.document.createRange()\n        const selection = $getSelection()\n        const text = getQueryTextForSearch(editor)\n\n        if (\n          !$isRangeSelection(selection) ||\n          !selection.isCollapsed() ||\n          text === null ||\n          range === null\n        ) {\n          closeTypeahead()\n          return\n        }\n\n        const match = triggerFn({ editor, query: text })\n        onQueryChange(match ? match.matchingString : null)\n\n        if (match !== null && !isSelectionOnEntityBoundary(editor, match.leadOffset)) {\n          const isRangePositioned = tryToPositionRange(match.leadOffset, range, editorWindow)\n          if (isRangePositioned !== null) {\n            startTransition(() =>\n              openTypeahead({\n                getRect: () => {\n                  return range.getBoundingClientRect()\n                },\n                match,\n              }),\n            )\n            return\n          }\n        }\n        closeTypeahead()\n      })\n    }\n\n    const removeUpdateListener = editor.registerUpdateListener(updateListener)\n\n    return () => {\n      removeUpdateListener()\n    }\n  }, [editor, triggerFn, onQueryChange, resolution, closeTypeahead, openTypeahead])\n\n  return resolution === null || editor === null ? null : (\n    <LexicalMenu\n      anchorElementRef={anchorElementRef}\n      close={closeTypeahead}\n      editor={editor}\n      groups={groups}\n      menuRenderFn={menuRenderFn}\n      onSelectItem={onSelectItem}\n      resolution={resolution}\n      shouldSplitNodeWithQuery\n    />\n  )\n}\n\nexport type { MenuRenderFn, MenuResolution, MenuTextMatch, TriggerFn }\n", "'use client'\nimport type { LexicalCommand, LexicalEditor, TextNode } from 'lexical'\nimport type { JSX, MutableRefObject, ReactPortal } from 'react'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { mergeRegister } from '@lexical/utils'\nimport {\n  $getSelection,\n  $isRangeSelection,\n  COMMAND_PRIORITY_LOW,\n  KEY_ARROW_DOWN_COMMAND,\n  KEY_ARROW_UP_COMMAND,\n  KEY_ENTER_COMMAND,\n  KEY_ESCAPE_COMMAND,\n  KEY_TAB_COMMAND,\n  createCommand,\n} from 'lexical'\nimport { useCallback, useEffect, useLayoutEffect, useMemo, useRef, useState } from 'react'\n\nimport type { MenuTextMatch } from '../useMenuTriggerMatch.js'\nimport type { SlashMenuGroupInternal, SlashMenuItem, SlashMenuItemInternal } from './types.js'\n\nexport type MenuResolution = {\n  getRect: () => DOMRect\n  match?: MenuTextMatch\n}\n\nconst baseClass = 'slash-menu-popup'\n\nexport type MenuRenderFn = (\n  anchorElementRef: MutableRefObject<HTMLElement | null>,\n  itemProps: {\n    groups: Array<SlashMenuGroupInternal>\n    selectItemAndCleanUp: (selectedItem: SlashMenuItem) => void\n    selectedItemKey: null | string\n    setSelectedItemKey: (itemKey: string) => void\n  },\n  matchingString: null | string,\n) => JSX.Element | ReactPortal | null\n\nconst scrollIntoViewIfNeeded = (target: HTMLElement) => {\n  const typeaheadContainerNode = document.getElementById('slash-menu')\n  if (!typeaheadContainerNode) return\n\n  const typeaheadRect = typeaheadContainerNode.getBoundingClientRect()\n\n  if (typeaheadRect.top + typeaheadRect.height > window.innerHeight) {\n    typeaheadContainerNode.scrollIntoView({\n      block: 'center',\n    })\n  }\n\n  if (typeaheadRect.top < 0) {\n    typeaheadContainerNode.scrollIntoView({\n      block: 'center',\n    })\n  }\n\n  target.scrollIntoView({ block: 'nearest' })\n}\n\n/**\n * Walk backwards along user input and forward through entity title to try\n * and replace more of the user's text with entity.\n */\nfunction getFullMatchOffset(documentText: string, entryText: string, offset: number) {\n  let triggerOffset = offset\n  for (let i = triggerOffset; i <= entryText.length; i++) {\n    if (documentText.substring(documentText.length - i) === entryText.substring(0, i)) {\n      triggerOffset = i\n    }\n  }\n  return triggerOffset\n}\n\n/**\n * Split Lexical TextNode and return a new TextNode only containing matched text.\n * Common use cases include: removing the node, replacing with a new node.\n */\nfunction $splitNodeContainingQuery(match: MenuTextMatch): TextNode | null {\n  const selection = $getSelection()\n  if (!$isRangeSelection(selection) || !selection.isCollapsed()) {\n    return null\n  }\n  const anchor = selection.anchor\n  if (anchor.type !== 'text') {\n    return null\n  }\n  const anchorNode = anchor.getNode()\n  if (!anchorNode.isSimpleText()) {\n    return null\n  }\n  const selectionOffset = anchor.offset\n  const textContent = anchorNode.getTextContent().slice(0, selectionOffset)\n  const characterOffset = match.replaceableString.length\n  const queryOffset = getFullMatchOffset(textContent, match.matchingString, characterOffset)\n  const startOffset = selectionOffset - queryOffset\n  if (startOffset < 0) {\n    return null\n  }\n  let newNode\n  if (startOffset === 0) {\n    ;[newNode] = anchorNode.splitText(selectionOffset)\n  } else {\n    ;[, newNode] = anchorNode.splitText(startOffset, selectionOffset)\n  }\n\n  return newNode\n}\n\n// Got from https://stackoverflow.com/a/42543908/2013580\nexport function getScrollParent(\n  element: HTMLElement,\n  includeHidden: boolean,\n): HTMLBodyElement | HTMLElement {\n  let style = getComputedStyle(element)\n  const excludeStaticParent = style.position === 'absolute'\n  const overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/\n  if (style.position === 'fixed') {\n    return document.body\n  }\n  for (let parent: HTMLElement | null = element; (parent = parent.parentElement); ) {\n    style = getComputedStyle(parent)\n    if (excludeStaticParent && style.position === 'static') {\n      continue\n    }\n    if (overflowRegex.test(style.overflow + style.overflowY + style.overflowX)) {\n      return parent\n    }\n  }\n  return document.body\n}\n\nfunction isTriggerVisibleInNearestScrollContainer(\n  targetElement: HTMLElement,\n  containerElement: HTMLElement,\n): boolean {\n  const tRect = targetElement.getBoundingClientRect()\n  const cRect = containerElement.getBoundingClientRect()\n  return tRect.top > cRect.top && tRect.top < cRect.bottom\n}\n\n// Reposition the menu on scroll, window resize, and element resize.\nexport function useDynamicPositioning(\n  resolution: MenuResolution | null,\n  targetElement: HTMLElement | null,\n  onReposition: () => void,\n  onVisibilityChange?: (isInView: boolean) => void,\n) {\n  const [editor] = useLexicalComposerContext()\n  useEffect(() => {\n    if (targetElement != null && resolution != null) {\n      const rootElement = editor.getRootElement()\n      const rootScrollParent =\n        rootElement != null ? getScrollParent(rootElement, false) : document.body\n      let ticking = false\n      let previousIsInView = isTriggerVisibleInNearestScrollContainer(\n        targetElement,\n        rootScrollParent,\n      )\n      const handleScroll = function () {\n        if (!ticking) {\n          window.requestAnimationFrame(function () {\n            onReposition()\n            ticking = false\n          })\n          ticking = true\n        }\n        const isInView = isTriggerVisibleInNearestScrollContainer(targetElement, rootScrollParent)\n        if (isInView !== previousIsInView) {\n          previousIsInView = isInView\n          if (onVisibilityChange != null) {\n            onVisibilityChange(isInView)\n          }\n        }\n      }\n      const resizeObserver = new ResizeObserver(onReposition)\n      window.addEventListener('resize', onReposition)\n      document.addEventListener('scroll', handleScroll, {\n        capture: true,\n        passive: true,\n      })\n      resizeObserver.observe(targetElement)\n      return () => {\n        resizeObserver.unobserve(targetElement)\n        window.removeEventListener('resize', onReposition)\n        document.removeEventListener('scroll', handleScroll, true)\n      }\n    }\n  }, [targetElement, editor, onVisibilityChange, onReposition, resolution])\n}\n\nexport const SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND: LexicalCommand<{\n  index: number\n  item: SlashMenuItemInternal\n}> = createCommand('SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND')\n\nexport function LexicalMenu({\n  anchorElementRef,\n  close,\n  editor,\n  // groups filtering is already handled in SlashMenu/index.tsx. Thus, groups always contains the matching items.\n  groups,\n  menuRenderFn,\n  onSelectItem,\n  resolution,\n  shouldSplitNodeWithQuery = false,\n}: {\n  anchorElementRef: MutableRefObject<HTMLElement>\n  close: () => void\n  editor: LexicalEditor\n  groups: Array<SlashMenuGroupInternal>\n  menuRenderFn: MenuRenderFn\n  onSelectItem: (\n    item: SlashMenuItem,\n    textNodeContainingQuery: TextNode | null,\n    closeMenu: () => void,\n    matchingString: string,\n  ) => void\n  resolution: MenuResolution\n  shouldSplitNodeWithQuery?: boolean\n}): JSX.Element | null {\n  const [selectedItemKey, setSelectedItemKey] = useState<null | string>(null)\n\n  const matchingString = (resolution.match && resolution.match.matchingString) || ''\n\n  const updateSelectedItem = useCallback(\n    (item: SlashMenuItem) => {\n      const rootElem = editor.getRootElement()\n      if (rootElem !== null) {\n        rootElem.setAttribute('aria-activedescendant', `${baseClass}__item-${item.key}`)\n        setSelectedItemKey(item.key)\n      }\n    },\n    [editor],\n  )\n\n  const setSelectedItemKeyToFirstMatchingItem = useCallback(() => {\n    // set selected item to the first of the matching ones\n    if (groups !== null && matchingString != null) {\n      // groups filtering is already handled in SlashMenu/index.tsx. Thus, groups always contains the matching items.\n      const allItems = groups.flatMap((group) => group.items)\n\n      if (allItems.length) {\n        const firstMatchingItem = allItems[0]\n        updateSelectedItem(firstMatchingItem)\n      }\n    }\n  }, [groups, updateSelectedItem, matchingString])\n\n  useEffect(() => {\n    setSelectedItemKeyToFirstMatchingItem()\n  }, [matchingString, setSelectedItemKeyToFirstMatchingItem])\n\n  const selectItemAndCleanUp = useCallback(\n    (selectedItem: SlashMenuItem) => {\n      editor.update(() => {\n        const textNodeContainingQuery =\n          resolution.match != null && shouldSplitNodeWithQuery\n            ? $splitNodeContainingQuery(resolution.match)\n            : null\n\n        onSelectItem(\n          selectedItem,\n          textNodeContainingQuery,\n          close,\n          resolution.match ? resolution.match.matchingString : '',\n        )\n      })\n    },\n    [editor, shouldSplitNodeWithQuery, resolution.match, onSelectItem, close],\n  )\n\n  useEffect(() => {\n    return () => {\n      const rootElem = editor.getRootElement()\n      if (rootElem !== null) {\n        rootElem.removeAttribute('aria-activedescendant')\n      }\n    }\n  }, [editor])\n\n  useLayoutEffect(() => {\n    if (groups === null) {\n      setSelectedItemKey(null)\n    } else if (selectedItemKey === null) {\n      setSelectedItemKeyToFirstMatchingItem()\n    }\n  }, [groups, selectedItemKey, updateSelectedItem, setSelectedItemKeyToFirstMatchingItem])\n\n  useEffect(() => {\n    return mergeRegister(\n      editor.registerCommand(\n        SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND,\n        ({ item }) => {\n          if (item.ref && item.ref.current != null) {\n            scrollIntoViewIfNeeded(item.ref.current)\n            return true\n          }\n\n          return false\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n    )\n  }, [editor, updateSelectedItem])\n\n  useEffect(() => {\n    return mergeRegister(\n      editor.registerCommand<KeyboardEvent>(\n        KEY_ARROW_DOWN_COMMAND,\n        (payload) => {\n          const event = payload\n          if (groups !== null && groups.length && selectedItemKey !== null) {\n            const allItems = groups.flatMap((group) => group.items)\n            const selectedIndex = allItems.findIndex((item) => item.key === selectedItemKey)\n\n            const newSelectedIndex = selectedIndex !== allItems.length - 1 ? selectedIndex + 1 : 0\n\n            const newSelectedItem = allItems[newSelectedIndex]\n\n            updateSelectedItem(newSelectedItem)\n            if (newSelectedItem.ref != null && newSelectedItem.ref.current) {\n              editor.dispatchCommand(SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND, {\n                index: newSelectedIndex,\n                item: newSelectedItem,\n              })\n            }\n            event.preventDefault()\n            event.stopImmediatePropagation()\n          }\n          return true\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n      editor.registerCommand<KeyboardEvent>(\n        KEY_ARROW_UP_COMMAND,\n        (payload) => {\n          const event = payload\n          if (groups !== null && groups.length && selectedItemKey !== null) {\n            const allItems = groups.flatMap((group) => group.items)\n            const selectedIndex = allItems.findIndex((item) => item.key === selectedItemKey)\n\n            const newSelectedIndex = selectedIndex !== 0 ? selectedIndex - 1 : allItems.length - 1\n\n            const newSelectedItem = allItems[newSelectedIndex]\n\n            updateSelectedItem(newSelectedItem)\n            if (newSelectedItem.ref != null && newSelectedItem.ref.current) {\n              scrollIntoViewIfNeeded(newSelectedItem.ref.current)\n            }\n            event.preventDefault()\n            event.stopImmediatePropagation()\n          }\n          return true\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n      editor.registerCommand<KeyboardEvent>(\n        KEY_ESCAPE_COMMAND,\n        (payload) => {\n          const event = payload\n          event.preventDefault()\n          event.stopImmediatePropagation()\n          close()\n          return true\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n      editor.registerCommand<KeyboardEvent>(\n        KEY_TAB_COMMAND,\n        (payload) => {\n          const event = payload\n\n          if (groups === null || selectedItemKey === null) {\n            return false\n          }\n          const allItems = groups.flatMap((group) => group.items)\n          const selectedItem = allItems.find((item) => item.key === selectedItemKey)\n          if (!selectedItem) {\n            return false\n          }\n\n          event.preventDefault()\n          event.stopImmediatePropagation()\n          selectItemAndCleanUp(selectedItem)\n          return true\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n      editor.registerCommand(\n        KEY_ENTER_COMMAND,\n        (event: KeyboardEvent | null) => {\n          if (groups === null || selectedItemKey === null) {\n            return false\n          }\n          const allItems = groups.flatMap((group) => group.items)\n          const selectedItem = allItems.find((item) => item.key === selectedItemKey)\n          if (!selectedItem) {\n            return false\n          }\n\n          if (event !== null) {\n            event.preventDefault()\n            event.stopImmediatePropagation()\n          }\n          selectItemAndCleanUp(selectedItem)\n          return true\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n    )\n  }, [selectItemAndCleanUp, close, editor, groups, selectedItemKey, updateSelectedItem])\n\n  const listItemProps = useMemo(\n    () => ({\n      groups,\n      selectItemAndCleanUp,\n      selectedItemKey,\n      setSelectedItemKey,\n    }),\n    [selectItemAndCleanUp, selectedItemKey, groups],\n  )\n\n  return menuRenderFn(\n    anchorElementRef,\n    listItemProps,\n    resolution.match ? resolution.match.matchingString : '',\n  )\n}\n\nexport function useMenuAnchorRef(\n  anchorElem: HTMLElement,\n  resolution: MenuResolution | null,\n  setResolution: (r: MenuResolution | null) => void,\n  className?: string,\n): MutableRefObject<HTMLElement> {\n  const [editor] = useLexicalComposerContext()\n  const anchorElementRef = useRef<HTMLElement>(document.createElement('div'))\n  const positionMenu = useCallback(() => {\n    const rootElement = editor.getRootElement()\n    const containerDiv = anchorElementRef.current\n\n    const VERTICAL_OFFSET = 32\n\n    const menuEle = containerDiv.firstChild as Element\n    if (rootElement !== null && resolution !== null) {\n      const { height, width } = resolution.getRect()\n      let { left, top } = resolution.getRect()\n\n      const rawTop = top\n      top -= anchorElem.getBoundingClientRect().top + window.scrollY\n      left -= anchorElem.getBoundingClientRect().left + window.scrollX\n      containerDiv.style.left = `${left + window.scrollX}px`\n      containerDiv.style.height = `${height}px`\n      containerDiv.style.width = `${width}px`\n      if (menuEle !== null) {\n        const menuRect = menuEle.getBoundingClientRect()\n        const menuHeight = menuRect.height\n        const menuWidth = menuRect.width\n\n        const rootElementRect = rootElement.getBoundingClientRect()\n\n        if (left + menuWidth > rootElementRect.right) {\n          containerDiv.style.left = `${rootElementRect.right - menuWidth + window.scrollX}px`\n        }\n\n        const wouldGoOffBottomOfScreen = rawTop + menuHeight + VERTICAL_OFFSET > window.innerHeight\n        //const wouldGoOffBottomOfContainer = top + menuHeight > rootElementRect.bottom\n        const wouldGoOffTopOfScreen = rawTop < 0\n\n        // Position slash menu above the cursor instead of below (default) if it would otherwise go off the bottom of the screen.\n        if (wouldGoOffBottomOfScreen && !wouldGoOffTopOfScreen) {\n          const margin = 24\n          containerDiv.style.top = `${\n            top + VERTICAL_OFFSET - menuHeight + window.scrollY - (height + margin)\n          }px`\n        } else {\n          containerDiv.style.top = `${top + window.scrollY + VERTICAL_OFFSET}px`\n        }\n      }\n\n      if (!containerDiv.isConnected) {\n        if (className != null) {\n          containerDiv.className = className\n        }\n        containerDiv.setAttribute('aria-label', 'Slash menu')\n        containerDiv.setAttribute('id', 'slash-menu')\n        containerDiv.setAttribute('role', 'listbox')\n        containerDiv.style.display = 'block'\n        containerDiv.style.position = 'absolute'\n        anchorElem.append(containerDiv)\n      }\n      anchorElementRef.current = containerDiv\n      rootElement.setAttribute('aria-controls', 'slash-menu')\n    }\n  }, [editor, resolution, className, anchorElem])\n\n  useEffect(() => {\n    const rootElement = editor.getRootElement()\n    if (resolution !== null) {\n      positionMenu()\n      return () => {\n        if (rootElement !== null) {\n          rootElement.removeAttribute('aria-controls')\n        }\n\n        const containerDiv = anchorElementRef.current\n        if (containerDiv !== null && containerDiv.isConnected) {\n          containerDiv.remove()\n        }\n      }\n    }\n  }, [editor, positionMenu, resolution])\n\n  const onVisibilityChange = useCallback(\n    (isInView: boolean) => {\n      if (resolution !== null) {\n        if (!isInView) {\n          setResolution(null)\n        }\n      }\n    },\n    [resolution, setResolution],\n  )\n\n  useDynamicPositioning(resolution, anchorElementRef.current, positionMenu, onVisibilityChange)\n\n  return anchorElementRef\n}\n", "export function isHTMLElement(x: unknown): x is HTMLElement {\n  return x instanceof HTMLElement\n}\n", "export class Point {\n  private readonly _x: number\n\n  private readonly _y: number\n\n  constructor(x: number, y: number) {\n    this._x = x\n    this._y = y\n  }\n\n  public calcDeltaXTo({ x }: Point): number {\n    return this.x - x\n  }\n\n  public calcDeltaYTo({ y }: Point): number {\n    return this.y - y\n  }\n\n  public calcDistanceTo(point: Point): number {\n    return Math.sqrt(Math.pow(this.calcDeltaXTo(point), 2) + Math.pow(this.calcDeltaYTo(point), 2))\n  }\n\n  public calcHorizontalDistanceTo(point: Point): number {\n    return Math.abs(this.calcDeltaXTo(point))\n  }\n\n  public calcVerticalDistance(point: Point): number {\n    return Math.abs(this.calcDeltaYTo(point))\n  }\n\n  public equals({ x, y }: Point): boolean {\n    return this.x === x && this.y === y\n  }\n\n  get x(): number {\n    return this._x\n  }\n\n  get y(): number {\n    return this._y\n  }\n}\n\nexport function isPoint(x: unknown): x is Point {\n  return x instanceof Point\n}\n", "import { type Point, isPoint } from './point.js'\n\ninterface ContainsPointReturn {\n  reason: {\n    isOnBottomSide: boolean\n    isOnLeftSide: boolean\n    isOnRightSide: boolean\n    isOnTopSide: boolean\n  }\n  result: boolean\n}\n\nexport class Rect {\n  private readonly _bottom: number\n\n  private readonly _left: number\n\n  private readonly _right: number\n\n  private readonly _top: number\n\n  constructor(left: number, top: number, right: number, bottom: number) {\n    const [physicTop, physicBottom] = top <= bottom ? [top, bottom] : [bottom, top]\n\n    const [physicLeft, physicRight] = left <= right ? [left, right] : [right, left]\n\n    this._top = physicTop\n    this._right = physicRight\n    this._left = physicLeft\n    this._bottom = physicBottom\n  }\n\n  static fromDOM(dom: HTMLElement): Rect {\n    const { height, left, top, width } = dom.getBoundingClientRect()\n    return Rect.fromLWTH(left, width, top, height)\n  }\n\n  static fromDOMRect(domRect: DOMRect): Rect {\n    const { height, left, top, width } = domRect\n    return Rect.fromLWTH(left, width, top, height)\n  }\n\n  static fromLTRB(left: number, top: number, right: number, bottom: number): Rect {\n    return new Rect(left, top, right, bottom)\n  }\n\n  static fromLWTH(left: number, width: number, top: number, height: number): Rect {\n    return new Rect(left, top, left + width, top + height)\n  }\n\n  static fromPoints(startPoint: Point, endPoint: Point): Rect {\n    const { x: left, y: top } = startPoint\n    const { x: right, y: bottom } = endPoint\n    return Rect.fromLTRB(left, top, right, bottom)\n  }\n\n  public contains({ x, y }: Point): ContainsPointReturn\n\n  public contains({ bottom, left, right, top }: Rect): boolean\n\n  public contains(target: Point | Rect): ContainsPointReturn | boolean {\n    if (isPoint(target)) {\n      const { x, y } = target\n\n      const isOnTopSide = y < this._top\n      const isOnBottomSide = y > this._bottom\n      const isOnLeftSide = x < this._left\n      const isOnRightSide = x > this._right\n\n      const result = !isOnTopSide && !isOnBottomSide && !isOnLeftSide && !isOnRightSide\n\n      return {\n        reason: {\n          isOnBottomSide,\n          isOnLeftSide,\n          isOnRightSide,\n          isOnTopSide,\n        },\n        result,\n      }\n    }\n    const { bottom, left, right, top } = target\n\n    return (\n      top >= this._top &&\n      top <= this._bottom &&\n      bottom >= this._top &&\n      bottom <= this._bottom &&\n      left >= this._left &&\n      left <= this._right &&\n      right >= this._left &&\n      right <= this._right\n    )\n  }\n\n  public distanceFromPoint(point: Point): {\n    distance: number\n    isOnBottomSide: boolean\n    isOnLeftSide: boolean\n    isOnRightSide: boolean\n    isOnTopSide: boolean\n  } {\n    const containsResult = this.contains(point)\n    if (containsResult.result) {\n      return {\n        distance: 0,\n        isOnBottomSide: containsResult.reason.isOnBottomSide,\n        isOnLeftSide: containsResult.reason.isOnLeftSide,\n        isOnRightSide: containsResult.reason.isOnRightSide,\n        isOnTopSide: containsResult.reason.isOnTopSide,\n      }\n    }\n\n    let dx = 0 // Horizontal distance to the closest edge\n    let dy = 0 // Vertical distance to the closest edge\n\n    // If the point is to the left of the rectangle\n    if (point.x < this._left) {\n      dx = this._left - point.x\n    }\n    // If the point is to the right of the rectangle\n    else if (point.x > this._right) {\n      dx = point.x - this._right\n    }\n\n    // If the point is above the rectangle\n    if (point.y < this._top) {\n      dy = this._top - point.y\n    }\n    // If the point is below the rectangle\n    else if (point.y > this._bottom) {\n      dy = point.y - this._bottom\n    }\n\n    // Use the Pythagorean theorem to calculate the distance\n    return {\n      distance: Math.sqrt(dx * dx + dy * dy),\n      isOnBottomSide: point.y > this._bottom,\n      isOnLeftSide: point.x < this._left,\n      isOnRightSide: point.x > this._right,\n      isOnTopSide: point.y < this._top,\n    }\n  }\n\n  public equals({ bottom, left, right, top }: Rect): boolean {\n    return (\n      top === this._top && bottom === this._bottom && left === this._left && right === this._right\n    )\n  }\n\n  public generateNewRect({\n    bottom = this.bottom,\n    left = this.left,\n    right = this.right,\n    top = this.top,\n  }): Rect {\n    return new Rect(left, top, right, bottom)\n  }\n\n  public intersectsWith(rect: Rect): boolean {\n    const { height: h1, left: x1, top: y1, width: w1 } = rect\n    const { height: h2, left: x2, top: y2, width: w2 } = this\n    const maxX = x1 + w1 >= x2 + w2 ? x1 + w1 : x2 + w2\n    const maxY = y1 + h1 >= y2 + h2 ? y1 + h1 : y2 + h2\n    const minX = x1 <= x2 ? x1 : x2\n    const minY = y1 <= y2 ? y1 : y2\n    return maxX - minX <= w1 + w2 && maxY - minY <= h1 + h2\n  }\n\n  get bottom(): number {\n    return this._bottom\n  }\n\n  get height(): number {\n    return Math.abs(this._bottom - this._top)\n  }\n\n  get left(): number {\n    return this._left\n  }\n\n  get right(): number {\n    return this._right\n  }\n\n  get top(): number {\n    return this._top\n  }\n\n  get width(): number {\n    return Math.abs(this._left - this._right)\n  }\n}\n"],
  "mappings": "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",
  "names": ["getEnabledNodes", "editorConfig", "node", "useLexicalComposerContext", "mergeRegister", "$getSelection", "$isRangeSelection", "$isTextNode", "COMMAND_PRIORITY_LOW", "createCommand", "useCallback", "useEffect", "useState", "React", "useLexicalComposerContext", "mergeRegister", "$getSelection", "$isRangeSelection", "COMMAND_PRIORITY_LOW", "KEY_ARROW_DOWN_COMMAND", "KEY_ARROW_UP_COMMAND", "KEY_ENTER_COMMAND", "KEY_ESCAPE_COMMAND", "KEY_TAB_COMMAND", "createCommand", "useCallback", "useEffect", "useLayoutEffect", "useMemo", "useRef", "useState", "baseClass", "scrollIntoViewIfNeeded", "target", "typeaheadContainerNode", "typeaheadRect", "getFullMatchOffset", "documentText", "entryText", "offset", "triggerOffset", "i", "$splitNodeContainingQuery", "match", "selection", "anchor", "anchorNode", "selectionOffset", "textContent", "characterOffset", "queryOffset", "startOffset", "newNode", "getScrollParent", "element", "includeHidden", "style", "excludeStaticParent", "overflowRegex", "parent", "isTriggerVisibleInNearestScrollContainer", "targetElement", "containerElement", "tRect", "cRect", "useDynamicPositioning", "resolution", "onReposition", "onVisibilityChange", "editor", "rootElement", "rootScrollParent", "ticking", "previousIsInView", "handleScroll", "isInView", "resizeObserver", "SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND", "LexicalMenu", "anchorElementRef", "close", "groups", "menuRenderFn", "onSelectItem", "shouldSplitNodeWithQuery", "selectedItemKey", "setSelectedItemKey", "matchingString", "updateSelectedItem", "item", "rootElem", "setSelectedItemKeyToFirstMatchingItem", "allItems", "group", "firstMatchingItem", "selectItemAndCleanUp", "selectedItem", "textNodeContainingQuery", "payload", "event", "selectedIndex", "newSelectedIndex", "newSelectedItem", "listItemProps", "useMenuAnchorRef", "anchorElem", "setResolution", "className", "positionMenu", "containerDiv", "VERTICAL_OFFSET", "menuEle", "height", "width", "left", "top", "rawTop", "menuRect", "menuHeight", "menuWidth", "rootElementRect", "wouldGoOffBottomOfScreen", "wouldGoOffTopOfScreen", "jsx", "PUNCTUATION", "getTextUpToAnchor", "selection", "anchor", "anchorNode", "anchorOffset", "tryToPositionRange", "leadOffset", "range", "editorWindow", "domSelection", "startOffset", "endOffset", "getQueryTextForSearch", "editor", "text", "$getSelection", "$isRangeSelection", "isSelectionOnEntityBoundary", "offset", "prevSibling", "$isTextNode", "startTransition", "callback", "ENABLE_SLASH_MENU_COMMAND", "createCommand", "LexicalTypeaheadMenuPlugin", "anchorClassName", "anchorElem", "groups", "menuRenderFn", "onClose", "onOpen", "onQueryChange", "onSelectItem", "triggerFn", "editor", "useLexicalComposerContext", "resolution", "setResolution", "useState", "anchorElementRef", "useMenuAnchorRef", "closeTypeahead", "useCallback", "openTypeahead", "res", "useEffect", "mergeRegister", "node", "match", "isSelectionOnEntityBoundary", "editorWindow", "range", "tryToPositionRange", "startTransition", "COMMAND_PRIORITY_LOW", "updateListener", "selection", "$getSelection", "text", "getQueryTextForSearch", "$isRangeSelection", "removeUpdateListener", "jsx", "LexicalMenu", "isHTMLElement", "x", "Point", "x", "y", "point", "isPoint", "Rect", "_Rect", "left", "top", "right", "bottom", "physicTop", "physicBottom", "physicLeft", "physicRight", "dom", "height", "width", "domRect", "startPoint", "endPoint", "target", "isPoint", "x", "y", "isOnTopSide", "isOnBottomSide", "isOnLeftSide", "isOnRightSide", "point", "containsResult", "dx", "dy", "rect", "h1", "x1", "y1", "w1", "h2", "x2", "y2", "w2", "maxX", "maxY", "minX", "minY"]
}

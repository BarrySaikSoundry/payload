{"version":3,"sources":["../../../../../src/features/converters/html/converter/index.ts"],"sourcesContent":["import type { SerializedEditorState, SerializedLexicalNode } from 'lexical'\nimport type { Payload, PayloadRequest } from 'payload'\n\nimport { createLocalReq } from 'payload'\n\nimport type { HTMLConverter, SerializedLexicalNodeWithParent } from './types.js'\n\nexport type ConvertLexicalToHTMLArgs = {\n  converters: HTMLConverter[]\n  data: SerializedEditorState\n} & (\n  | {\n      /**\n       * This payload property will only be used if req is undefined.\n       */\n      payload?: Payload\n      /**\n       * When the converter is called, req CAN be passed in depending on where it's run.\n       * If this is undefined and config is passed through, lexical will create a new req object for you. If this is null or\n       * config is undefined, lexical will not create a new req object for you and local API / server-side-only\n       * functionality will be disabled.\n       */\n      req?: null | undefined\n    }\n  | {\n      /**\n       * This payload property will only be used if req is undefined.\n       */\n      payload?: never\n      /**\n       * When the converter is called, req CAN be passed in depending on where it's run.\n       * If this is undefined and config is passed through, lexical will create a new req object for you. If this is null or\n       * config is undefined, lexical will not create a new req object for you and local API / server-side-only\n       * functionality will be disabled.\n       */\n      req: PayloadRequest\n    }\n)\n\nexport async function convertLexicalToHTML({\n  converters,\n  data,\n  payload,\n  req,\n}: ConvertLexicalToHTMLArgs): Promise<string> {\n  if (data?.root?.children?.length) {\n    if (req === undefined && payload) {\n      req = await createLocalReq({}, payload)\n    }\n\n    return await convertLexicalNodesToHTML({\n      converters,\n      lexicalNodes: data?.root?.children,\n      parent: data?.root,\n      req,\n    })\n  }\n  return ''\n}\n\nexport async function convertLexicalNodesToHTML({\n  converters,\n  lexicalNodes,\n  parent,\n  req,\n}: {\n  converters: HTMLConverter[]\n  lexicalNodes: SerializedLexicalNode[]\n  parent: SerializedLexicalNodeWithParent\n  /**\n   * When the converter is called, req CAN be passed in depending on where it's run.\n   */\n  req: PayloadRequest | null\n}): Promise<string> {\n  const unknownConverter = converters.find((converter) => converter.nodeTypes.includes('unknown'))\n\n  const htmlArray = await Promise.all(\n    lexicalNodes.map(async (node, i) => {\n      const converterForNode = converters.find((converter) =>\n        converter.nodeTypes.includes(node.type),\n      )\n      try {\n        if (!converterForNode) {\n          if (unknownConverter) {\n            return await unknownConverter.converter({\n              childIndex: i,\n              converters,\n              node,\n              parent,\n              req,\n            })\n          }\n          return '<span>unknown node</span>'\n        }\n        return await converterForNode.converter({\n          childIndex: i,\n          converters,\n          node,\n          parent,\n          req,\n        })\n      } catch (error) {\n        console.error('Error converting lexical node to HTML:', error, 'node:', node)\n        return ''\n      }\n    }),\n  )\n\n  return htmlArray.join('') || ''\n}\n"],"names":["createLocalReq","convertLexicalToHTML","converters","data","payload","req","root","children","length","undefined","convertLexicalNodesToHTML","lexicalNodes","parent","unknownConverter","find","converter","nodeTypes","includes","htmlArray","Promise","all","map","node","i","converterForNode","type","childIndex","error","console","join"],"mappings":"AAGA,SAASA,cAAc,QAAQ,UAAS;AAoCxC,OAAO,eAAeC,qBAAqB,EACzCC,UAAU,EACVC,IAAI,EACJC,OAAO,EACPC,GAAG,EACsB;IACzB,IAAIF,MAAMG,MAAMC,UAAUC,QAAQ;QAChC,IAAIH,QAAQI,aAAaL,SAAS;YAChCC,MAAM,MAAML,eAAe,CAAC,GAAGI;QACjC;QAEA,OAAO,MAAMM,0BAA0B;YACrCR;YACAS,cAAcR,MAAMG,MAAMC;YAC1BK,QAAQT,MAAMG;YACdD;QACF;IACF;IACA,OAAO;AACT;AAEA,OAAO,eAAeK,0BAA0B,EAC9CR,UAAU,EACVS,YAAY,EACZC,MAAM,EACNP,GAAG,EASJ;IACC,MAAMQ,mBAAmBX,WAAWY,IAAI,CAAC,CAACC,YAAcA,UAAUC,SAAS,CAACC,QAAQ,CAAC;IAErF,MAAMC,YAAY,MAAMC,QAAQC,GAAG,CACjCT,aAAaU,GAAG,CAAC,OAAOC,MAAMC;QAC5B,MAAMC,mBAAmBtB,WAAWY,IAAI,CAAC,CAACC,YACxCA,UAAUC,SAAS,CAACC,QAAQ,CAACK,KAAKG,IAAI;QAExC,IAAI;YACF,IAAI,CAACD,kBAAkB;gBACrB,IAAIX,kBAAkB;oBACpB,OAAO,MAAMA,iBAAiBE,SAAS,CAAC;wBACtCW,YAAYH;wBACZrB;wBACAoB;wBACAV;wBACAP;oBACF;gBACF;gBACA,OAAO;YACT;YACA,OAAO,MAAMmB,iBAAiBT,SAAS,CAAC;gBACtCW,YAAYH;gBACZrB;gBACAoB;gBACAV;gBACAP;YACF;QACF,EAAE,OAAOsB,OAAO;YACdC,QAAQD,KAAK,CAAC,0CAA0CA,OAAO,SAASL;YACxE,OAAO;QACT;IACF;IAGF,OAAOJ,UAAUW,IAAI,CAAC,OAAO;AAC/B"}
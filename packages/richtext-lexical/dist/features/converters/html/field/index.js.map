{"version":3,"sources":["../../../../../src/features/converters/html/field/index.ts"],"sourcesContent":["import type { SerializedEditorState } from 'lexical'\nimport type { Field, FieldAffectingData, RichTextField } from 'payload'\n\nimport type { SanitizedServerEditorConfig } from '../../../../lexical/config/types.js'\nimport type { AdapterProps, LexicalRichTextAdapter } from '../../../../types.js'\nimport type { HTMLConverter } from '../converter/types.js'\nimport type { HTMLConverterFeatureProps } from '../feature.server.js'\n\nimport { defaultHTMLConverters } from '../converter/defaultConverters.js'\nimport { convertLexicalToHTML } from '../converter/index.js'\n\ntype Props = {\n  /**\n   * Whether the lexicalHTML field should be hidden in the admin panel\n   *\n   * @default true\n   */\n  hidden?: boolean\n  name: string\n  /**\n   * Whether the HTML should be stored in the database\n   *\n   * @default false\n   */\n  storeInDB?: boolean\n}\n\n/**\n * Combines the default HTML converters with HTML converters found in the features, and with HTML converters configured in the htmlConverter feature.\n *\n * @param editorConfig\n */\nexport const consolidateHTMLConverters = ({\n  editorConfig,\n}: {\n  editorConfig: SanitizedServerEditorConfig\n}): HTMLConverter[] => {\n  const htmlConverterFeature = editorConfig.resolvedFeatureMap.get('htmlConverter')\n  const htmlConverterFeatureProps: HTMLConverterFeatureProps =\n    htmlConverterFeature?.sanitizedServerFeatureProps\n\n  const defaultConvertersWithConvertersFromFeatures = [...defaultHTMLConverters]\n\n  for (const converter of editorConfig.features.converters.html) {\n    defaultConvertersWithConvertersFromFeatures.push(converter)\n  }\n\n  const finalConverters =\n    htmlConverterFeatureProps?.converters &&\n    typeof htmlConverterFeatureProps?.converters === 'function'\n      ? htmlConverterFeatureProps.converters({\n          defaultConverters: defaultConvertersWithConvertersFromFeatures,\n        })\n      : (htmlConverterFeatureProps?.converters as HTMLConverter[]) ||\n        defaultConvertersWithConvertersFromFeatures\n\n  // filter converters by nodeTypes. The last converter in the list wins. If there are multiple converters for the same nodeType, the last one will be used and the node types will be removed from\n  // previous converters. If previous converters do not have any nodeTypes left, they will be removed from the list.\n  // This guarantees that user-added converters which are added after the default ones will always have precedence\n  const foundNodeTypes: string[] = []\n  const filteredConverters: HTMLConverter[] = []\n  for (const converter of finalConverters.reverse()) {\n    if (!converter.nodeTypes?.length) {\n      continue\n    }\n    const newConverter: HTMLConverter = {\n      converter: converter.converter,\n      nodeTypes: [...converter.nodeTypes],\n    }\n    newConverter.nodeTypes = newConverter.nodeTypes.filter((nodeType) => {\n      if (foundNodeTypes.includes(nodeType)) {\n        return false\n      }\n      foundNodeTypes.push(nodeType)\n      return true\n    })\n\n    if (newConverter.nodeTypes.length) {\n      filteredConverters.push(newConverter)\n    }\n  }\n\n  return filteredConverters\n}\n\n// find the path of this field, as well as its sibling fields, by looking for this `field` in fields and traversing it recursively\nfunction findFieldPathAndSiblingFields(\n  fields: Field[],\n  path: string[],\n  field: FieldAffectingData,\n): {\n  path: string[]\n  siblingFields: Field[]\n} {\n  for (const curField of fields) {\n    if (curField === field) {\n      return {\n        path: [...path, curField.name],\n        siblingFields: fields,\n      }\n    }\n\n    if ('fields' in curField) {\n      const result = findFieldPathAndSiblingFields(\n        curField.fields,\n        'name' in curField ? [...path, curField.name] : [...path],\n        field,\n      )\n      if (result) {\n        return result\n      }\n    } else if ('tabs' in curField) {\n      for (const tab of curField.tabs) {\n        const result = findFieldPathAndSiblingFields(\n          tab.fields,\n          'name' in tab ? [...path, tab.name] : [...path],\n          field,\n        )\n        if (result) {\n          return result\n        }\n      }\n    } else if ('blocks' in curField) {\n      for (const block of curField.blocks) {\n        if (block?.fields?.length) {\n          const result = findFieldPathAndSiblingFields(\n            block.fields,\n            [...path, curField.name, block.slug],\n            field,\n          )\n          if (result) {\n            return result\n          }\n        }\n      }\n    }\n  }\n\n  return null\n}\n\nexport const lexicalHTML: (\n  /**\n   * A string which matches the lexical field name you want to convert to HTML.\n   *\n   * This has to be a SIBLING field of this lexicalHTML field - otherwise, it won't be able to find the lexical field.\n   **/\n  lexicalFieldName: string,\n  props: Props,\n) => Field = (lexicalFieldName, props) => {\n  const { name = 'lexicalHTML', hidden = true, storeInDB = false } = props\n  return {\n    name,\n    type: 'code',\n    admin: {\n      editorOptions: {\n        language: 'html',\n      },\n      hidden,\n    },\n    hooks: {\n      afterRead: [\n        async ({ collection, field, global, req, siblingData }) => {\n          const fields = collection ? collection.fields : global.fields\n\n          const foundSiblingFields = findFieldPathAndSiblingFields(fields, [], field)\n\n          if (!foundSiblingFields)\n            throw new Error(\n              `Could not find sibling fields of current lexicalHTML field with name ${field?.name}`,\n            )\n\n          const { siblingFields } = foundSiblingFields\n          const lexicalField: RichTextField<SerializedEditorState, AdapterProps> =\n            siblingFields.find(\n              (field) => 'name' in field && field.name === lexicalFieldName,\n            ) as RichTextField<SerializedEditorState, AdapterProps>\n\n          const lexicalFieldData: SerializedEditorState = siblingData[lexicalFieldName]\n\n          if (!lexicalFieldData) {\n            return ''\n          }\n\n          if (!lexicalField) {\n            throw new Error(\n              'You cannot use the lexicalHTML field because the referenced lexical field was not found',\n            )\n          }\n\n          const config = (lexicalField?.editor as LexicalRichTextAdapter)?.editorConfig\n\n          if (!config) {\n            throw new Error(\n              'The linked lexical field does not have an editorConfig. This is needed for the lexicalHTML field.',\n            )\n          }\n\n          if (!config?.resolvedFeatureMap?.has('htmlConverter')) {\n            throw new Error(\n              'You cannot use the lexicalHTML field because the linked lexical field does not have a HTMLConverterFeature',\n            )\n          }\n\n          const finalConverters = consolidateHTMLConverters({\n            editorConfig: config,\n          })\n\n          return await convertLexicalToHTML({\n            converters: finalConverters,\n            data: lexicalFieldData,\n            req,\n          })\n        },\n      ],\n      beforeChange: [\n        ({ siblingData, value }) => {\n          if (storeInDB) {\n            return value\n          }\n          delete siblingData[name]\n          return null\n        },\n      ],\n    },\n  }\n}\n"],"names":["defaultHTMLConverters","convertLexicalToHTML","consolidateHTMLConverters","editorConfig","htmlConverterFeature","resolvedFeatureMap","get","htmlConverterFeatureProps","sanitizedServerFeatureProps","defaultConvertersWithConvertersFromFeatures","converter","features","converters","html","push","finalConverters","defaultConverters","foundNodeTypes","filteredConverters","reverse","nodeTypes","length","newConverter","filter","nodeType","includes","findFieldPathAndSiblingFields","fields","path","field","curField","name","siblingFields","result","tab","tabs","block","blocks","slug","lexicalHTML","lexicalFieldName","props","hidden","storeInDB","type","admin","editorOptions","language","hooks","afterRead","collection","global","req","siblingData","foundSiblingFields","Error","lexicalField","find","lexicalFieldData","config","editor","has","data","beforeChange","value"],"mappings":"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"}
{"version":3,"sources":["../../src/features/typesClient.ts"],"sourcesContent":["import type { Transformer } from '@lexical/markdown'\nimport type {\n  Klass,\n  LexicalEditor,\n  LexicalNode,\n  LexicalNodeReplacement,\n  SerializedEditorState,\n} from 'lexical'\nimport type React from 'react'\n\nimport type { ClientEditorConfig } from '../lexical/config/types.js'\nimport type { SlashMenuGroup } from '../lexical/plugins/SlashMenu/LexicalTypeaheadMenuPlugin/types.js'\nimport type { ToolbarGroup } from './toolbars/types.js'\n\nexport type FeatureProviderProviderClient<\n  UnSanitizedClientFeatureProps = undefined,\n  ClientFeatureProps = UnSanitizedClientFeatureProps,\n> = (props: ClientComponentProps<ClientFeatureProps>) => FeatureProviderClient<ClientFeatureProps>\n\n/**\n * No dependencies => Features need to be sorted on the server first, then sent to client in right order\n */\nexport type FeatureProviderClient<\n  UnSanitizedClientFeatureProps = undefined,\n  ClientFeatureProps = UnSanitizedClientFeatureProps,\n> = {\n  /**\n   * Return props, to make it easy to retrieve passed in props to this Feature for the client if anyone wants to\n   */\n  clientFeatureProps: ClientComponentProps<UnSanitizedClientFeatureProps>\n  feature:\n    | ((props: {\n        clientFunctions: Record<string, any>\n        /** unSanitizedEditorConfig.features, but mapped */\n        featureProviderMap: ClientFeatureProviderMap\n        // other resolved features, which have been loaded before this one. All features declared in 'dependencies' should be available here\n        resolvedFeatures: ResolvedClientFeatureMap\n        // unSanitized EditorConfig,\n        unSanitizedEditorConfig: ClientEditorConfig\n      }) => ClientFeature<ClientFeatureProps>)\n    | ClientFeature<ClientFeatureProps>\n}\n\nexport type PluginComponent<ClientFeatureProps = any> = React.FC<{\n  clientProps: ClientFeatureProps\n}>\nexport type PluginComponentWithAnchor<ClientFeatureProps = any> = React.FC<{\n  anchorElem: HTMLElement\n  clientProps: ClientFeatureProps\n}>\n\nexport type ClientFeature<ClientFeatureProps> = {\n  hooks?: {\n    load?: ({\n      incomingEditorState,\n    }: {\n      incomingEditorState: SerializedEditorState\n    }) => SerializedEditorState\n    save?: ({\n      incomingEditorState,\n    }: {\n      incomingEditorState: SerializedEditorState\n    }) => SerializedEditorState\n  }\n  markdownTransformers?: Transformer[]\n  nodes?: Array<Klass<LexicalNode> | LexicalNodeReplacement>\n  /**\n   * Plugins are react components which get added to the editor. You can use them to interact with lexical, e.g. to create a command which creates a node, or opens a modal, or some other more \"outside\" functionality\n   */\n  plugins?: Array<\n    | {\n        // plugins are anything which is not directly part of the editor. Like, creating a command which creates a node, or opens a modal, or some other more \"outside\" functionality\n        Component: PluginComponent<ClientFeatureProps>\n        position: 'aboveContainer' // Determines at which position the Component will be added.\n      }\n    | {\n        // plugins are anything which is not directly part of the editor. Like, creating a command which creates a node, or opens a modal, or some other more \"outside\" functionality\n        Component: PluginComponent<ClientFeatureProps>\n        position: 'bottom' // Determines at which position the Component will be added.\n      }\n    | {\n        // plugins are anything which is not directly part of the editor. Like, creating a command which creates a node, or opens a modal, or some other more \"outside\" functionality\n        Component: PluginComponent<ClientFeatureProps>\n        position: 'normal' // Determines at which position the Component will be added.\n      }\n    | {\n        // plugins are anything which is not directly part of the editor. Like, creating a command which creates a node, or opens a modal, or some other more \"outside\" functionality\n        Component: PluginComponent<ClientFeatureProps>\n        position: 'top' // Determines at which position the Component will be added.\n      }\n    | {\n        // plugins are anything which is not directly part of the editor. Like, creating a command which creates a node, or opens a modal, or some other more \"outside\" functionality\n        Component: PluginComponentWithAnchor<ClientFeatureProps>\n        position: 'floatingAnchorElem' // Determines at which position the Component will be added.\n      }\n    | {\n        Component: PluginComponent<ClientFeatureProps>\n        position: 'belowContainer' // Determines at which position the Component will be added.\n      }\n  >\n  /**\n   * Client Features can register their own providers, which will be nested below the EditorConfigProvider\n   */\n  providers?: Array<React.FC>\n  /**\n   * Return props, to make it easy to retrieve passed in props to this Feature for the client if anyone wants to\n   */\n  sanitizedClientFeatureProps?: ClientComponentProps<ClientFeatureProps>\n  slashMenu?: {\n    /**\n     * Dynamic groups allow you to add different groups depending on the query string (so, the text after the slash).\n     * Thus, to re-calculate the available groups, this function will be called every time you type after the /.\n     *\n     * The groups provided by dynamicGroups will be merged with the static groups provided by the groups property.\n     */\n    dynamicGroups?: ({\n      editor,\n      queryString,\n    }: {\n      editor: LexicalEditor\n      queryString: string\n    }) => SlashMenuGroup[]\n    /**\n     * Static array of groups together with the items in them. These will always be present.\n     * While typing after the /, they will be filtered by the query string and the keywords, key and display name of the items.\n     */\n    groups?: SlashMenuGroup[]\n  }\n  /**\n   * An opt-in, classic fixed toolbar which stays at the top of the editor\n   */\n  toolbarFixed?: {\n    groups: ToolbarGroup[]\n  }\n  /**\n   * The default, floating toolbar which appears when you select text.\n   */\n  toolbarInline?: {\n    /**\n     * Array of toolbar groups / sections. Each section can contain multiple toolbar items.\n     */\n    groups: ToolbarGroup[]\n  }\n}\n\nexport type ClientComponentProps<ClientFeatureProps> = ClientFeatureProps extends undefined\n  ? {\n      featureKey: string\n      order: number\n    }\n  : {\n      featureKey: string\n      order: number\n    } & ClientFeatureProps\n\nexport type ResolvedClientFeature<ClientFeatureProps> = {\n  key: string\n  order: number\n} & ClientFeature<ClientFeatureProps>\n\nexport type ResolvedClientFeatureMap = Map<string, ResolvedClientFeature<any>>\n\nexport type ClientFeatureProviderMap = Map<string, FeatureProviderClient<any, any>>\n\n/**\n * Plugins are react components which get added to the editor. You can use them to interact with lexical, e.g. to create a command which creates a node, or opens a modal, or some other more \"outside\" functionality\n */\nexport type SanitizedPlugin =\n  | {\n      // plugins are anything which is not directly part of the editor. Like, creating a command which creates a node, or opens a modal, or some other more \"outside\" functionality\n      Component: PluginComponent\n      clientProps: any\n      key: string\n      position: 'bottom' // Determines at which position the Component will be added.\n    }\n  | {\n      // plugins are anything which is not directly part of the editor. Like, creating a command which creates a node, or opens a modal, or some other more \"outside\" functionality\n      Component: PluginComponent\n      clientProps: any\n      key: string\n      position: 'normal' // Determines at which position the Component will be added.\n    }\n  | {\n      // plugins are anything which is not directly part of the editor. Like, creating a command which creates a node, or opens a modal, or some other more \"outside\" functionality\n      Component: PluginComponent\n      clientProps: any\n      key: string\n      position: 'top' // Determines at which position the Component will be added.\n    }\n  | {\n      // plugins are anything which is not directly part of the editor. Like, creating a command which creates a node, or opens a modal, or some other more \"outside\" functionality\n      Component: PluginComponentWithAnchor\n      clientProps: any\n      desktopOnly?: boolean\n      key: string\n      position: 'floatingAnchorElem' // Determines at which position the Component will be added.\n    }\n  | {\n      Component: PluginComponent\n      clientProps: any\n      key: string\n      position: 'aboveContainer'\n    }\n  | {\n      Component: PluginComponent\n      clientProps: any\n      key: string\n      position: 'belowContainer'\n    }\n\nexport type SanitizedClientFeatures = {\n  /** The keys of all enabled features */\n  enabledFeatures: string[]\n  hooks: {\n    load: Array<\n      ({\n        incomingEditorState,\n      }: {\n        incomingEditorState: SerializedEditorState\n      }) => SerializedEditorState\n    >\n    save: Array<\n      ({\n        incomingEditorState,\n      }: {\n        incomingEditorState: SerializedEditorState\n      }) => SerializedEditorState\n    >\n  }\n  /**\n   * Plugins are react components which get added to the editor. You can use them to interact with lexical, e.g. to create a command which creates a node, or opens a modal, or some other more \"outside\" functionality\n   */\n  plugins?: Array<SanitizedPlugin>\n  slashMenu: {\n    /**\n     * Dynamic groups allow you to add different groups depending on the query string (so, the text after the slash).\n     * Thus, to re-calculate the available groups, this function will be called every time you type after the /.\n     *\n     * The groups provided by dynamicGroups will be merged with the static groups provided by the groups property.\n     */\n    dynamicGroups: Array<\n      ({ editor, queryString }: { editor: LexicalEditor; queryString: string }) => SlashMenuGroup[]\n    >\n    /**\n     * Static array of groups together with the items in them. These will always be present.\n     * While typing after the /, they will be filtered by the query string and the keywords, key and display name of the items.\n     */\n    groups: SlashMenuGroup[]\n  }\n} & Required<\n  Pick<\n    ResolvedClientFeature<unknown>,\n    'markdownTransformers' | 'nodes' | 'providers' | 'toolbarFixed' | 'toolbarInline'\n  >\n>\n"],"names":[],"mappings":"AAkNA,WA4CC"}
{"version":3,"sources":["../../../../src/features/link/nodes/LinkNode.ts"],"sourcesContent":["import type {\n  BaseSelection,\n  DOMConversionMap,\n  DOMConversionOutput,\n  EditorConfig,\n  ElementNode as ElementNodeType,\n  LexicalCommand,\n  LexicalNode,\n  NodeKey,\n  RangeSelection,\n} from 'lexical'\n\nimport { addClassNamesToElement, isHTMLAnchorElement } from '@lexical/utils'\nimport ObjectID from 'bson-objectid'\nimport {\n  $applyNodeReplacement,\n  $createTextNode,\n  $getSelection,\n  $isElementNode,\n  $isRangeSelection,\n  ElementNode,\n  createCommand,\n} from 'lexical'\n\nimport type { LinkPayload } from '../plugins/floatingLinkEditor/types.js'\nimport type { LinkFields, SerializedLinkNode } from './types.js'\n\nconst SUPPORTED_URL_PROTOCOLS = new Set(['http:', 'https:', 'mailto:', 'sms:', 'tel:'])\n\n/** @noInheritDoc */\nexport class LinkNode extends ElementNode {\n  __fields: LinkFields\n  __id: string\n\n  constructor({\n    id,\n    fields = {\n      doc: null,\n      linkType: 'custom',\n      newTab: false,\n      url: undefined,\n    },\n    key,\n  }: {\n    fields: LinkFields\n    id: string\n    key?: NodeKey\n  }) {\n    super(key)\n    this.__fields = fields\n    this.__id = id\n  }\n\n  static clone(node: LinkNode): LinkNode {\n    return new LinkNode({\n      id: node.__id,\n      fields: node.__fields,\n      key: node.__key,\n    })\n  }\n\n  static getType(): string {\n    return 'link'\n  }\n\n  static importDOM(): DOMConversionMap | null {\n    return {\n      a: (node: Node) => ({\n        conversion: $convertAnchorElement,\n        priority: 1,\n      }),\n    }\n  }\n\n  static importJSON(serializedNode: SerializedLinkNode): LinkNode {\n    if (\n      serializedNode.version === 1 &&\n      typeof serializedNode.fields?.doc?.value === 'object' &&\n      serializedNode.fields?.doc?.value?.id\n    ) {\n      serializedNode.fields.doc.value = serializedNode.fields.doc.value.id\n      serializedNode.version = 2\n    }\n\n    if (serializedNode.version === 2 && !serializedNode.id) {\n      serializedNode.id = new ObjectID.default().toHexString()\n      serializedNode.version = 3\n    }\n\n    const node = $createLinkNode({\n      id: serializedNode.id,\n      fields: serializedNode.fields,\n    })\n    node.setFormat(serializedNode.format)\n    node.setIndent(serializedNode.indent)\n    node.setDirection(serializedNode.direction)\n    return node\n  }\n\n  canBeEmpty(): false {\n    return false\n  }\n\n  canInsertTextAfter(): false {\n    return false\n  }\n\n  canInsertTextBefore(): false {\n    return false\n  }\n\n  createDOM(config: EditorConfig): HTMLAnchorElement {\n    const element = document.createElement('a')\n    if (this.__fields?.linkType === 'custom') {\n      element.href = this.sanitizeUrl(this.__fields.url ?? '')\n    }\n    if (this.__fields?.newTab ?? false) {\n      element.target = '_blank'\n    }\n\n    if (this.__fields?.newTab === true && this.__fields?.linkType === 'custom') {\n      element.rel = manageRel(element.rel, 'add', 'noopener')\n    }\n\n    addClassNamesToElement(element, config.theme.link)\n    return element\n  }\n\n  exportJSON(): SerializedLinkNode {\n    const returnObject: SerializedLinkNode = {\n      ...super.exportJSON(),\n      type: 'link',\n      fields: this.getFields(),\n      version: 3,\n    }\n    const id = this.getID()\n    if (id) {\n      returnObject.id = id\n    }\n    return returnObject\n  }\n\n  extractWithChild(\n    child: LexicalNode,\n    selection: BaseSelection,\n    destination: 'clone' | 'html',\n  ): boolean {\n    if (!$isRangeSelection(selection)) {\n      return false\n    }\n\n    const anchorNode = selection.anchor.getNode()\n    const focusNode = selection.focus.getNode()\n\n    return (\n      this.isParentOf(anchorNode) &&\n      this.isParentOf(focusNode) &&\n      selection.getTextContent().length > 0\n    )\n  }\n\n  getFields(): LinkFields {\n    return this.getLatest().__fields\n  }\n\n  getID(): string {\n    return this.getLatest().__id\n  }\n\n  insertNewAfter(selection: RangeSelection, restoreSelection = true): ElementNodeType | null {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection)\n    if ($isElementNode(element)) {\n      const linkNode = $createLinkNode({ fields: this.__fields })\n      element.append(linkNode)\n      return linkNode\n    }\n    return null\n  }\n\n  isInline(): true {\n    return true\n  }\n\n  sanitizeUrl(url: string): string {\n    try {\n      const parsedUrl = new URL(url)\n\n      if (!SUPPORTED_URL_PROTOCOLS.has(parsedUrl.protocol)) {\n        return 'about:blank'\n      }\n    } catch (e) {\n      return 'https://'\n    }\n    return url\n  }\n\n  setFields(fields: LinkFields): void {\n    const writable = this.getWritable()\n    writable.__fields = fields\n  }\n\n  updateDOM(prevNode: LinkNode, anchor: HTMLAnchorElement, config: EditorConfig): boolean {\n    const url = this.__fields?.url\n    const newTab = this.__fields?.newTab\n    if (url != null && url !== prevNode.__fields?.url && this.__fields?.linkType === 'custom') {\n      anchor.href = url\n    }\n    if (this.__fields?.linkType === 'internal' && prevNode.__fields?.linkType === 'custom') {\n      anchor.removeAttribute('href')\n    }\n\n    // TODO: not 100% sure why we're settign rel to '' - revisit\n    // Start rel config here, then check newTab below\n    if (anchor.rel == null) {\n      anchor.rel = ''\n    }\n\n    if (newTab !== prevNode.__fields?.newTab) {\n      if (newTab ?? false) {\n        anchor.target = '_blank'\n        if (this.__fields?.linkType === 'custom') {\n          anchor.rel = manageRel(anchor.rel, 'add', 'noopener')\n        }\n      } else {\n        anchor.removeAttribute('target')\n        anchor.rel = manageRel(anchor.rel, 'remove', 'noopener')\n      }\n    }\n\n    return false\n  }\n}\n\nfunction $convertAnchorElement(domNode: Node): DOMConversionOutput {\n  let node: LinkNode | null = null\n  if (isHTMLAnchorElement(domNode)) {\n    const content = domNode.textContent\n    if (content !== null && content !== '') {\n      node = $createLinkNode({\n        id: new ObjectID.default().toHexString(),\n        fields: {\n          doc: null,\n          linkType: 'custom',\n          newTab: domNode.getAttribute('target') === '_blank',\n          url: domNode.getAttribute('href') ?? '',\n        },\n      })\n    }\n  }\n  return { node }\n}\n\nexport function $createLinkNode({ id, fields }: { fields: LinkFields; id?: string }): LinkNode {\n  return $applyNodeReplacement(\n    new LinkNode({\n      id: id ?? new ObjectID.default().toHexString(),\n      fields,\n    }),\n  )\n}\n\nexport function $isLinkNode(node: LexicalNode | null | undefined): node is LinkNode {\n  return node instanceof LinkNode\n}\n\nexport const TOGGLE_LINK_COMMAND: LexicalCommand<LinkPayload | null> =\n  createCommand('TOGGLE_LINK_COMMAND')\n\nexport function $toggleLink(payload: LinkPayload): void {\n  const selection = $getSelection()\n\n  if (!$isRangeSelection(selection) && !payload.selectedNodes.length) {\n    return\n  }\n  const nodes = $isRangeSelection(selection) ? selection.extract() : payload.selectedNodes\n\n  if (payload === null) {\n    // Remove LinkNodes\n    nodes.forEach((node) => {\n      const parent = node.getParent()\n\n      if ($isLinkNode(parent)) {\n        const children = parent.getChildren()\n\n        for (let i = 0; i < children.length; i += 1) {\n          parent.insertBefore(children[i])\n        }\n\n        parent.remove()\n      }\n    })\n  } else {\n    // Add or merge LinkNodes\n    if (nodes.length === 1) {\n      const firstNode = nodes[0]\n      // if the first node is a LinkNode or if its\n      // parent is a LinkNode, we update the URL, target and rel.\n      const linkNode: LinkNode | null = $isLinkNode(firstNode)\n        ? firstNode\n        : $getLinkAncestor(firstNode)\n      if (linkNode !== null) {\n        linkNode.setFields(payload.fields)\n\n        if (payload.text != null && payload.text !== linkNode.getTextContent()) {\n          // remove all children and add child with new textcontent:\n          linkNode.append($createTextNode(payload.text))\n          linkNode.getChildren().forEach((child) => {\n            if (child !== linkNode.getLastChild()) {\n              child.remove()\n            }\n          })\n        }\n        return\n      }\n    }\n\n    let prevParent: ElementNodeType | LinkNode | null = null\n    let linkNode: LinkNode | null = null\n\n    nodes.forEach((node) => {\n      const parent = node.getParent()\n\n      if (parent === linkNode || parent === null || ($isElementNode(node) && !node.isInline())) {\n        return\n      }\n\n      if ($isLinkNode(parent)) {\n        linkNode = parent\n        parent.setFields(payload.fields)\n        if (payload.text != null && payload.text !== parent.getTextContent()) {\n          // remove all children and add child with new textcontent:\n          parent.append($createTextNode(payload.text))\n          parent.getChildren().forEach((child) => {\n            if (child !== parent.getLastChild()) {\n              child.remove()\n            }\n          })\n        }\n        return\n      }\n\n      if (!parent.is(prevParent)) {\n        prevParent = parent\n        linkNode = $createLinkNode({ fields: payload.fields })\n\n        if ($isLinkNode(parent)) {\n          if (node.getPreviousSibling() === null) {\n            parent.insertBefore(linkNode)\n          } else {\n            parent.insertAfter(linkNode)\n          }\n        } else {\n          node.insertBefore(linkNode)\n        }\n      }\n\n      if ($isLinkNode(node)) {\n        if (node.is(linkNode)) {\n          return\n        }\n        if (linkNode !== null) {\n          const children = node.getChildren()\n\n          for (let i = 0; i < children.length; i += 1) {\n            linkNode.append(children[i])\n          }\n        }\n\n        node.remove()\n        return\n      }\n\n      if (linkNode !== null) {\n        linkNode.append(node)\n      }\n    })\n  }\n}\n\nfunction $getLinkAncestor(node: LexicalNode): LinkNode | null {\n  return $getAncestor(node, (ancestor) => $isLinkNode(ancestor)) as LinkNode\n}\n\nfunction $getAncestor(\n  node: LexicalNode,\n  predicate: (ancestor: LexicalNode) => boolean,\n): LexicalNode | null {\n  let parent: LexicalNode | null = node\n  while (parent !== null && (parent = parent.getParent()) !== null && !predicate(parent));\n  return parent\n}\n\nfunction manageRel(input: string, action: 'add' | 'remove', value: string): string {\n  let result: string\n  let mutableInput = `${input}`\n  if (action === 'add') {\n    // if we somehow got out of sync - clean up\n    if (mutableInput.includes(value)) {\n      const re = new RegExp(value, 'g')\n      mutableInput = mutableInput.replace(re, '').trim()\n    }\n    mutableInput = mutableInput.trim()\n    result = mutableInput.length === 0 ? `${value}` : `${mutableInput} ${value}`\n  } else {\n    const re = new RegExp(value, 'g')\n    result = mutableInput.replace(re, '').trim()\n  }\n  return result\n}\n"],"names":["addClassNamesToElement","isHTMLAnchorElement","ObjectID","$applyNodeReplacement","$createTextNode","$getSelection","$isElementNode","$isRangeSelection","ElementNode","createCommand","SUPPORTED_URL_PROTOCOLS","Set","LinkNode","__fields","__id","constructor","id","fields","doc","linkType","newTab","url","undefined","key","clone","node","__key","getType","importDOM","a","conversion","$convertAnchorElement","priority","importJSON","serializedNode","version","value","default","toHexString","$createLinkNode","setFormat","format","setIndent","indent","setDirection","direction","canBeEmpty","canInsertTextAfter","canInsertTextBefore","createDOM","config","element","document","createElement","href","sanitizeUrl","target","rel","manageRel","theme","link","exportJSON","returnObject","type","getFields","getID","extractWithChild","child","selection","destination","anchorNode","anchor","getNode","focusNode","focus","isParentOf","getTextContent","length","getLatest","insertNewAfter","restoreSelection","getParentOrThrow","linkNode","append","isInline","parsedUrl","URL","has","protocol","e","setFields","writable","getWritable","updateDOM","prevNode","removeAttribute","domNode","content","textContent","getAttribute","$isLinkNode","TOGGLE_LINK_COMMAND","$toggleLink","payload","selectedNodes","nodes","extract","forEach","parent","getParent","children","getChildren","i","insertBefore","remove","firstNode","$getLinkAncestor","text","getLastChild","prevParent","is","getPreviousSibling","insertAfter","$getAncestor","ancestor","predicate","input","action","result","mutableInput","includes","re","RegExp","replace","trim"],"mappings":"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"}
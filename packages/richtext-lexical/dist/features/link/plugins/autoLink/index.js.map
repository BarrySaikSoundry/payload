{"version":3,"sources":["../../../../../src/features/link/plugins/autoLink/index.tsx"],"sourcesContent":["'use client'\nimport type { ElementNode, LexicalEditor, LexicalNode, TextNode } from 'lexical'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { mergeRegister } from '@lexical/utils'\nimport {\n  $createTextNode,\n  $getSelection,\n  $isElementNode,\n  $isLineBreakNode,\n  $isNodeSelection,\n  $isRangeSelection,\n  $isTextNode,\n  TextNode as TextNodeValue,\n} from 'lexical'\nimport { useEffect } from 'react'\n\nimport type { PluginComponent } from '../../../typesClient.js'\nimport type { ClientProps } from '../../feature.client.js'\nimport type { LinkFields } from '../../nodes/types.js'\n\nimport { invariant } from '../../../../lexical/utils/invariant.js'\nimport { $createAutoLinkNode, $isAutoLinkNode, AutoLinkNode } from '../../nodes/AutoLinkNode.js'\nimport { $isLinkNode } from '../../nodes/LinkNode.js'\n\ntype ChangeHandler = (url: null | string, prevUrl: null | string) => void\n\ninterface LinkMatcherResult {\n  fields?: LinkFields\n  index: number\n  length: number\n  text: string\n  url: string\n}\n\nexport type LinkMatcher = (text: string) => LinkMatcherResult | null\n\nexport function createLinkMatcherWithRegExp(\n  regExp: RegExp,\n  urlTransformer: (text: string) => string = (text) => text,\n) {\n  return (text: string) => {\n    const match = regExp.exec(text)\n    if (match === null) return null\n    return {\n      index: match.index,\n      length: match[0].length,\n      text: match[0],\n      url: urlTransformer(match[0]),\n    }\n  }\n}\n\nfunction findFirstMatch(text: string, matchers: LinkMatcher[]): LinkMatcherResult | null {\n  for (let i = 0; i < matchers.length; i++) {\n    const match = matchers[i](text)\n\n    if (match != null) {\n      return match\n    }\n  }\n\n  return null\n}\n\nconst PUNCTUATION_OR_SPACE = /[.,;\\s]/\n\nfunction isSeparator(char: string): boolean {\n  return PUNCTUATION_OR_SPACE.test(char)\n}\n\nfunction endsWithSeparator(textContent: string): boolean {\n  return isSeparator(textContent[textContent.length - 1])\n}\n\nfunction startsWithSeparator(textContent: string): boolean {\n  return isSeparator(textContent[0])\n}\n\nfunction startsWithFullStop(textContent: string): boolean {\n  return /^\\.[a-z\\d]+/i.test(textContent)\n}\n\nfunction isPreviousNodeValid(node: LexicalNode): boolean {\n  let previousNode = node.getPreviousSibling()\n  if ($isElementNode(previousNode)) {\n    previousNode = previousNode.getLastDescendant()\n  }\n  return (\n    previousNode === null ||\n    $isLineBreakNode(previousNode) ||\n    ($isTextNode(previousNode) && endsWithSeparator(previousNode.getTextContent()))\n  )\n}\n\nfunction isNextNodeValid(node: LexicalNode): boolean {\n  let nextNode = node.getNextSibling()\n  if ($isElementNode(nextNode)) {\n    nextNode = nextNode.getFirstDescendant()\n  }\n  return (\n    nextNode === null ||\n    $isLineBreakNode(nextNode) ||\n    ($isTextNode(nextNode) && startsWithSeparator(nextNode.getTextContent()))\n  )\n}\n\nfunction isContentAroundIsValid(\n  matchStart: number,\n  matchEnd: number,\n  text: string,\n  nodes: TextNode[],\n): boolean {\n  const contentBeforeIsValid =\n    matchStart > 0 ? isSeparator(text[matchStart - 1]) : isPreviousNodeValid(nodes[0])\n  if (!contentBeforeIsValid) {\n    return false\n  }\n\n  const contentAfterIsValid =\n    matchEnd < text.length ? isSeparator(text[matchEnd]) : isNextNodeValid(nodes[nodes.length - 1])\n  return contentAfterIsValid\n}\n\nfunction extractMatchingNodes(\n  nodes: TextNode[],\n  startIndex: number,\n  endIndex: number,\n): [\n  matchingOffset: number,\n  unmodifiedBeforeNodes: TextNode[],\n  matchingNodes: TextNode[],\n  unmodifiedAfterNodes: TextNode[],\n] {\n  const unmodifiedBeforeNodes: TextNode[] = []\n  const matchingNodes: TextNode[] = []\n  const unmodifiedAfterNodes: TextNode[] = []\n  let matchingOffset = 0\n\n  let currentOffset = 0\n  const currentNodes = [...nodes]\n\n  while (currentNodes.length > 0) {\n    const currentNode = currentNodes[0]\n    const currentNodeText = currentNode.getTextContent()\n    const currentNodeLength = currentNodeText.length\n    const currentNodeStart = currentOffset\n    const currentNodeEnd = currentOffset + currentNodeLength\n\n    if (currentNodeEnd <= startIndex) {\n      unmodifiedBeforeNodes.push(currentNode)\n      matchingOffset += currentNodeLength\n    } else if (currentNodeStart >= endIndex) {\n      unmodifiedAfterNodes.push(currentNode)\n    } else {\n      matchingNodes.push(currentNode)\n    }\n    currentOffset += currentNodeLength\n    currentNodes.shift()\n  }\n  return [matchingOffset, unmodifiedBeforeNodes, matchingNodes, unmodifiedAfterNodes]\n}\n\nfunction $createAutoLinkNode_(\n  nodes: TextNode[],\n  startIndex: number,\n  endIndex: number,\n  match: LinkMatcherResult,\n): TextNode | undefined {\n  const fields: LinkFields = {\n    linkType: 'custom',\n    url: match.url,\n    ...match.fields,\n  }\n\n  const linkNode = $createAutoLinkNode({ fields })\n  if (nodes.length === 1) {\n    let remainingTextNode = nodes[0]\n    let linkTextNode\n    if (startIndex === 0) {\n      ;[linkTextNode, remainingTextNode] = remainingTextNode.splitText(endIndex)\n    } else {\n      ;[, linkTextNode, remainingTextNode] = remainingTextNode.splitText(startIndex, endIndex)\n    }\n    const textNode = $createTextNode(match.text)\n    textNode.setFormat(linkTextNode.getFormat())\n    textNode.setDetail(linkTextNode.getDetail())\n    textNode.setStyle(linkTextNode.getStyle())\n    linkNode.append(textNode)\n    linkTextNode.replace(linkNode)\n    return remainingTextNode\n  } else if (nodes.length > 1) {\n    const firstTextNode = nodes[0]\n    let offset = firstTextNode.getTextContent().length\n    let firstLinkTextNode\n    if (startIndex === 0) {\n      firstLinkTextNode = firstTextNode\n    } else {\n      ;[, firstLinkTextNode] = firstTextNode.splitText(startIndex)\n    }\n    const linkNodes = []\n    let remainingTextNode\n    for (let i = 1; i < nodes.length; i++) {\n      const currentNode = nodes[i]\n      const currentNodeText = currentNode.getTextContent()\n      const currentNodeLength = currentNodeText.length\n      const currentNodeStart = offset\n      const currentNodeEnd = offset + currentNodeLength\n      if (currentNodeStart < endIndex) {\n        if (currentNodeEnd <= endIndex) {\n          linkNodes.push(currentNode)\n        } else {\n          const [linkTextNode, endNode] = currentNode.splitText(endIndex - currentNodeStart)\n          linkNodes.push(linkTextNode)\n          remainingTextNode = endNode\n        }\n      }\n      offset += currentNodeLength\n    }\n    const selection = $getSelection()\n    const selectedTextNode = selection ? selection.getNodes().find($isTextNode) : undefined\n    const textNode = $createTextNode(firstLinkTextNode.getTextContent())\n    textNode.setFormat(firstLinkTextNode.getFormat())\n    textNode.setDetail(firstLinkTextNode.getDetail())\n    textNode.setStyle(firstLinkTextNode.getStyle())\n    linkNode.append(textNode, ...linkNodes)\n    // it does not preserve caret position if caret was at the first text node\n    // so we need to restore caret position\n    if (selectedTextNode && selectedTextNode === firstLinkTextNode) {\n      if ($isRangeSelection(selection)) {\n        textNode.select(selection.anchor.offset, selection.focus.offset)\n      } else if ($isNodeSelection(selection)) {\n        textNode.select(0, textNode.getTextContent().length)\n      }\n    }\n    firstLinkTextNode.replace(linkNode)\n    return remainingTextNode\n  }\n  return undefined\n}\n\nfunction $handleLinkCreation(\n  nodes: TextNode[],\n  matchers: LinkMatcher[],\n  onChange: ChangeHandler,\n): void {\n  let currentNodes = [...nodes]\n  const initialText = currentNodes.map((node) => node.getTextContent()).join('')\n  let text = initialText\n\n  let match\n  let invalidMatchEnd = 0\n\n  while ((match = findFirstMatch(text, matchers)) != null && match !== null) {\n    const matchStart: number = match.index\n    const matchLength: number = match.length\n    const matchEnd = matchStart + matchLength\n    const isValid = isContentAroundIsValid(\n      invalidMatchEnd + matchStart,\n      invalidMatchEnd + matchEnd,\n      initialText,\n      currentNodes,\n    )\n\n    if (isValid) {\n      const [matchingOffset, , matchingNodes, unmodifiedAfterNodes] = extractMatchingNodes(\n        currentNodes,\n        invalidMatchEnd + matchStart,\n        invalidMatchEnd + matchEnd,\n      )\n\n      const actualMatchStart = invalidMatchEnd + matchStart - matchingOffset\n      const actualMatchEnd = invalidMatchEnd + matchEnd - matchingOffset\n      const remainingTextNode = $createAutoLinkNode_(\n        matchingNodes,\n        actualMatchStart,\n        actualMatchEnd,\n        match,\n      )\n      currentNodes = remainingTextNode\n        ? [remainingTextNode, ...unmodifiedAfterNodes]\n        : unmodifiedAfterNodes\n      onChange(match.url, null)\n      invalidMatchEnd = 0\n    } else {\n      invalidMatchEnd += matchEnd\n    }\n\n    text = text.substring(matchEnd)\n  }\n}\n\nfunction handleLinkEdit(\n  linkNode: AutoLinkNode,\n  matchers: LinkMatcher[],\n  onChange: ChangeHandler,\n): void {\n  // Check children are simple text\n  const children = linkNode.getChildren()\n  const childrenLength = children.length\n  for (let i = 0; i < childrenLength; i++) {\n    const child = children[i]\n    if (!$isTextNode(child) || !child.isSimpleText()) {\n      replaceWithChildren(linkNode)\n      onChange(null, linkNode.getFields()?.url ?? null)\n      return\n    }\n  }\n\n  // Check text content fully matches\n  const text = linkNode.getTextContent()\n  const match = findFirstMatch(text, matchers)\n  if (match === null || match.text !== text) {\n    replaceWithChildren(linkNode)\n    onChange(null, linkNode.getFields()?.url ?? null)\n    return\n  }\n\n  // Check neighbors\n  if (!isPreviousNodeValid(linkNode) || !isNextNodeValid(linkNode)) {\n    replaceWithChildren(linkNode)\n    onChange(null, linkNode.getFields()?.url ?? null)\n    return\n  }\n\n  const url = linkNode.getFields()?.url\n  if (url !== match?.url) {\n    const flds = linkNode.getFields()\n    flds.url = match?.url\n    linkNode.setFields(flds)\n    onChange(match.url, url ?? null)\n  }\n}\n\n// Bad neighbors are edits in neighbor nodes that make AutoLinks incompatible.\n// Given the creation preconditions, these can only be simple text nodes.\nfunction handleBadNeighbors(\n  textNode: TextNode,\n  matchers: LinkMatcher[],\n  onChange: ChangeHandler,\n): void {\n  const previousSibling = textNode.getPreviousSibling()\n  const nextSibling = textNode.getNextSibling()\n  const text = textNode.getTextContent()\n\n  if (\n    $isAutoLinkNode(previousSibling) &&\n    (!startsWithSeparator(text) || startsWithFullStop(text))\n  ) {\n    previousSibling.append(textNode)\n    handleLinkEdit(previousSibling, matchers, onChange)\n    onChange(null, previousSibling.getFields()?.url ?? null)\n  }\n\n  if ($isAutoLinkNode(nextSibling) && !endsWithSeparator(text)) {\n    replaceWithChildren(nextSibling)\n    handleLinkEdit(nextSibling, matchers, onChange)\n    onChange(null, nextSibling.getFields()?.url ?? null)\n  }\n}\n\nfunction replaceWithChildren(node: ElementNode): LexicalNode[] {\n  const children = node.getChildren()\n  const childrenLength = children.length\n\n  for (let j = childrenLength - 1; j >= 0; j--) {\n    node.insertAfter(children[j])\n  }\n\n  node.remove()\n  return children.map((child) => child.getLatest())\n}\n\nfunction getTextNodesToMatch(textNode: TextNode): TextNode[] {\n  // check if next siblings are simple text nodes till a node contains a space separator\n  const textNodesToMatch = [textNode]\n  let nextSibling = textNode.getNextSibling()\n  while (nextSibling !== null && $isTextNode(nextSibling) && nextSibling.isSimpleText()) {\n    textNodesToMatch.push(nextSibling)\n    if (/\\s/.test(nextSibling.getTextContent())) {\n      break\n    }\n    nextSibling = nextSibling.getNextSibling()\n  }\n  return textNodesToMatch\n}\n\nfunction useAutoLink(\n  editor: LexicalEditor,\n  matchers: LinkMatcher[],\n  onChange?: ChangeHandler,\n): void {\n  useEffect(() => {\n    if (!editor.hasNodes([AutoLinkNode])) {\n      invariant(false, 'LexicalAutoLinkPlugin: AutoLinkNode not registered on editor')\n    }\n\n    const onChangeWrapped = (url: null | string, prevUrl: null | string): void => {\n      if (onChange != null) {\n        onChange(url, prevUrl)\n      }\n    }\n\n    return mergeRegister(\n      editor.registerNodeTransform(TextNodeValue, (textNode: TextNode) => {\n        const parent = textNode.getParentOrThrow()\n        const previous = textNode.getPreviousSibling()\n        if ($isAutoLinkNode(parent)) {\n          handleLinkEdit(parent, matchers, onChangeWrapped)\n        } else if (!$isLinkNode(parent)) {\n          if (\n            textNode.isSimpleText() &&\n            (startsWithSeparator(textNode.getTextContent()) || !$isAutoLinkNode(previous))\n          ) {\n            const textNodesToMatch = getTextNodesToMatch(textNode)\n            $handleLinkCreation(textNodesToMatch, matchers, onChangeWrapped)\n          }\n\n          handleBadNeighbors(textNode, matchers, onChangeWrapped)\n        }\n      }),\n    )\n  }, [editor, matchers, onChange])\n}\n\nconst URL_REGEX =\n  /((https?:\\/\\/(www\\.)?)|(www\\.))[-\\w@:%.+~#=]{1,256}\\.[a-zA-Z\\d()]{1,6}\\b([-\\w()@:%+.~#?&/=]*)(?<![-.+():%])/\n\nconst EMAIL_REGEX =\n  /(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\])|(([a-z\\-\\d]+\\.)+[a-z]{2,}))/i\n\nconst MATCHERS = [\n  createLinkMatcherWithRegExp(URL_REGEX, (text) => {\n    return text.startsWith('http') ? text : `https://${text}`\n  }),\n  createLinkMatcherWithRegExp(EMAIL_REGEX, (text) => {\n    return `mailto:${text}`\n  }),\n]\n\nexport const AutoLinkPlugin: PluginComponent<ClientProps> = () => {\n  const [editor] = useLexicalComposerContext()\n\n  useAutoLink(editor, MATCHERS)\n\n  return null\n}\n"],"names":["useLexicalComposerContext","mergeRegister","$createTextNode","$getSelection","$isElementNode","$isLineBreakNode","$isNodeSelection","$isRangeSelection","$isTextNode","TextNode","TextNodeValue","useEffect","invariant","$createAutoLinkNode","$isAutoLinkNode","AutoLinkNode","$isLinkNode","createLinkMatcherWithRegExp","regExp","urlTransformer","text","match","exec","index","length","url","findFirstMatch","matchers","i","PUNCTUATION_OR_SPACE","isSeparator","char","test","endsWithSeparator","textContent","startsWithSeparator","startsWithFullStop","isPreviousNodeValid","node","previousNode","getPreviousSibling","getLastDescendant","getTextContent","isNextNodeValid","nextNode","getNextSibling","getFirstDescendant","isContentAroundIsValid","matchStart","matchEnd","nodes","contentBeforeIsValid","contentAfterIsValid","extractMatchingNodes","startIndex","endIndex","unmodifiedBeforeNodes","matchingNodes","unmodifiedAfterNodes","matchingOffset","currentOffset","currentNodes","currentNode","currentNodeText","currentNodeLength","currentNodeStart","currentNodeEnd","push","shift","$createAutoLinkNode_","fields","linkType","linkNode","remainingTextNode","linkTextNode","splitText","textNode","setFormat","getFormat","setDetail","getDetail","setStyle","getStyle","append","replace","firstTextNode","offset","firstLinkTextNode","linkNodes","endNode","selection","selectedTextNode","getNodes","find","undefined","select","anchor","focus","$handleLinkCreation","onChange","initialText","map","join","invalidMatchEnd","matchLength","isValid","actualMatchStart","actualMatchEnd","substring","handleLinkEdit","children","getChildren","childrenLength","child","isSimpleText","replaceWithChildren","getFields","flds","setFields","handleBadNeighbors","previousSibling","nextSibling","j","insertAfter","remove","getLatest","getTextNodesToMatch","textNodesToMatch","useAutoLink","editor","hasNodes","onChangeWrapped","prevUrl","registerNodeTransform","parent","getParentOrThrow","previous","URL_REGEX","EMAIL_REGEX","MATCHERS","startsWith","AutoLinkPlugin"],"mappings":"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"}
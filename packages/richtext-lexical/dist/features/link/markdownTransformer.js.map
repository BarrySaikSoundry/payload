{"version":3,"sources":["../../../src/features/link/markdownTransformer.ts"],"sourcesContent":["/**\n * Code taken from https://github.com/facebook/lexical/blob/main/packages/lexical-markdown/src/MarkdownTransformers.ts#L357\n */\n\n// Order of text transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n\nimport type { TextMatchTransformer } from '@lexical/markdown'\n\nimport { $createTextNode, $isTextNode } from 'lexical'\n\nimport { $createLinkNode, $isLinkNode, LinkNode } from './nodes/LinkNode.js'\n\n// - then longer tags match (e.g. ** or __ should go before * or _)\nexport const LinkMarkdownTransformer: TextMatchTransformer = {\n  type: 'text-match',\n  dependencies: [LinkNode],\n  export: (_node, exportChildren, exportFormat) => {\n    if (!$isLinkNode(_node)) {\n      return null\n    }\n    const node: LinkNode = _node\n    const { url } = node.getFields()\n    const linkContent = `[${node.getTextContent()}](${url})`\n    const firstChild = node.getFirstChild()\n    // Add text styles only if link has single text node inside. If it's more\n    // then one we ignore it as markdown does not support nested styles for links\n    if (node.getChildrenSize() === 1 && $isTextNode(firstChild)) {\n      return exportFormat(firstChild, linkContent)\n    } else {\n      return linkContent\n    }\n  },\n  importRegExp: /\\[([^[]+)\\]\\(([^()\\s]+)(?:\\s\"((?:[^\"]*\\\\\")*[^\"]*)\"\\s*)?\\)/,\n  regExp: /\\[([^[]+)\\]\\(([^()\\s]+)(?:\\s\"((?:[^\"]*\\\\\")*[^\"]*)\"\\s*)?\\)$/,\n  replace: (textNode, match) => {\n    const [, linkText, linkUrl] = match\n    const linkNode = $createLinkNode({\n      fields: {\n        doc: null,\n        linkType: 'custom',\n        newTab: false,\n        url: linkUrl,\n      },\n    })\n    const linkTextNode = $createTextNode(linkText)\n    linkTextNode.setFormat(textNode.getFormat())\n    linkNode.append(linkTextNode)\n    textNode.replace(linkNode)\n  },\n  trigger: ')',\n}\n"],"names":["$createTextNode","$isTextNode","$createLinkNode","$isLinkNode","LinkNode","LinkMarkdownTransformer","type","dependencies","export","_node","exportChildren","exportFormat","node","url","getFields","linkContent","getTextContent","firstChild","getFirstChild","getChildrenSize","importRegExp","regExp","replace","textNode","match","linkText","linkUrl","linkNode","fields","doc","linkType","newTab","linkTextNode","setFormat","getFormat","append","trigger"],"mappings":"AAAA;;CAEC,GAED,sCAAsC;AACtC,EAAE;AACF,mEAAmE;AAInE,SAASA,eAAe,EAAEC,WAAW,QAAQ,UAAS;AAEtD,SAASC,eAAe,EAAEC,WAAW,EAAEC,QAAQ,QAAQ,sBAAqB;AAE5E,mEAAmE;AACnE,OAAO,MAAMC,0BAAgD;IAC3DC,MAAM;IACNC,cAAc;QAACH;KAAS;IACxBI,QAAQ,CAACC,OAAOC,gBAAgBC;QAC9B,IAAI,CAACR,YAAYM,QAAQ;YACvB,OAAO;QACT;QACA,MAAMG,OAAiBH;QACvB,MAAM,EAAEI,GAAG,EAAE,GAAGD,KAAKE,SAAS;QAC9B,MAAMC,cAAc,CAAC,CAAC,EAAEH,KAAKI,cAAc,GAAG,EAAE,EAAEH,IAAI,CAAC,CAAC;QACxD,MAAMI,aAAaL,KAAKM,aAAa;QACrC,yEAAyE;QACzE,6EAA6E;QAC7E,IAAIN,KAAKO,eAAe,OAAO,KAAKlB,YAAYgB,aAAa;YAC3D,OAAON,aAAaM,YAAYF;QAClC,OAAO;YACL,OAAOA;QACT;IACF;IACAK,cAAc;IACdC,QAAQ;IACRC,SAAS,CAACC,UAAUC;QAClB,MAAM,GAAGC,UAAUC,QAAQ,GAAGF;QAC9B,MAAMG,WAAWzB,gBAAgB;YAC/B0B,QAAQ;gBACNC,KAAK;gBACLC,UAAU;gBACVC,QAAQ;gBACRlB,KAAKa;YACP;QACF;QACA,MAAMM,eAAehC,gBAAgByB;QACrCO,aAAaC,SAAS,CAACV,SAASW,SAAS;QACzCP,SAASQ,MAAM,CAACH;QAChBT,SAASD,OAAO,CAACK;IACnB;IACAS,SAAS;AACX,EAAC"}
{"version":3,"sources":["../../../../../src/features/experimental_table/plugins/TableCellResizerPlugin/index.tsx"],"sourcesContent":["'use client'\n\nimport type { TableCellNode, TableDOMCell, TableMapType, TableMapValueType } from '@lexical/table'\nimport type { LexicalEditor } from 'lexical'\nimport type { JSX, MouseEventHandler } from 'react'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext'\nimport { useLexicalEditable } from '@lexical/react/useLexicalEditable'\nimport {\n  $computeTableMapSkipCellCheck,\n  $getTableNodeFromLexicalNodeOrThrow,\n  $getTableRowIndexFromTableCellNode,\n  $isTableCellNode,\n  $isTableRowNode,\n  getDOMCellFromTarget,\n} from '@lexical/table'\nimport { calculateZoomLevel } from '@lexical/utils'\nimport { $getNearestNodeFromDOMNode } from 'lexical'\nimport * as React from 'react'\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react'\nimport { createPortal } from 'react-dom'\n\nimport type { PluginComponent, PluginComponentWithAnchor } from '../../../typesClient.js'\n\nimport './index.scss'\n\ntype MousePosition = {\n  x: number\n  y: number\n}\n\ntype MouseDraggingDirection = 'bottom' | 'right'\n\nconst MIN_ROW_HEIGHT = 33\nconst MIN_COLUMN_WIDTH = 50\n\nfunction TableCellResizer({ editor }: { editor: LexicalEditor }): JSX.Element {\n  const targetRef = useRef<HTMLElement | null>(null)\n  const resizerRef = useRef<HTMLDivElement | null>(null)\n  const tableRectRef = useRef<ClientRect | null>(null)\n\n  const mouseStartPosRef = useRef<MousePosition | null>(null)\n  const [mouseCurrentPos, updateMouseCurrentPos] = useState<MousePosition | null>(null)\n\n  const [activeCell, updateActiveCell] = useState<TableDOMCell | null>(null)\n  const [isMouseDown, updateIsMouseDown] = useState<boolean>(false)\n  const [draggingDirection, updateDraggingDirection] = useState<MouseDraggingDirection | null>(null)\n\n  const resetState = useCallback(() => {\n    updateActiveCell(null)\n    targetRef.current = null\n    updateDraggingDirection(null)\n    mouseStartPosRef.current = null\n    tableRectRef.current = null\n  }, [])\n\n  const isMouseDownOnEvent = (event: MouseEvent) => {\n    return (event.buttons & 1) === 1\n  }\n\n  useEffect(() => {\n    const onMouseMove = (event: MouseEvent) => {\n      setTimeout(() => {\n        const target = event.target\n\n        if (draggingDirection) {\n          updateMouseCurrentPos({\n            x: event.clientX,\n            y: event.clientY,\n          })\n          return\n        }\n        updateIsMouseDown(isMouseDownOnEvent(event))\n        if (resizerRef.current && resizerRef.current.contains(target as Node)) {\n          return\n        }\n\n        if (targetRef.current !== target) {\n          targetRef.current = target as HTMLElement\n          const cell = getDOMCellFromTarget(target as HTMLElement)\n\n          if (cell && activeCell !== cell) {\n            editor.update(() => {\n              const tableCellNode = $getNearestNodeFromDOMNode(cell.elem)\n\n              if (!tableCellNode) {\n                throw new Error('TableCellResizer: Table cell node not found.')\n              }\n\n              const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode)\n              const tableElement = editor.getElementByKey(tableNode.getKey())\n\n              if (!tableElement) {\n                throw new Error('TableCellResizer: Table element not found.')\n              }\n\n              targetRef.current = target as HTMLElement\n              tableRectRef.current = tableElement.getBoundingClientRect()\n              updateActiveCell(cell)\n            })\n          } else if (cell == null) {\n            resetState()\n          }\n        }\n      }, 0)\n    }\n\n    const onMouseDown = (event: MouseEvent) => {\n      setTimeout(() => {\n        updateIsMouseDown(true)\n      }, 0)\n    }\n\n    const onMouseUp = (event: MouseEvent) => {\n      setTimeout(() => {\n        updateIsMouseDown(false)\n      }, 0)\n    }\n\n    document.addEventListener('mousemove', onMouseMove)\n    document.addEventListener('mousedown', onMouseDown)\n    document.addEventListener('mouseup', onMouseUp)\n\n    return () => {\n      document.removeEventListener('mousemove', onMouseMove)\n      document.removeEventListener('mousedown', onMouseDown)\n      document.removeEventListener('mouseup', onMouseUp)\n    }\n  }, [activeCell, draggingDirection, editor, resetState])\n\n  const isHeightChanging = (direction: MouseDraggingDirection) => {\n    if (direction === 'bottom') {\n      return true\n    }\n    return false\n  }\n\n  const updateRowHeight = useCallback(\n    (heightChange: number) => {\n      if (!activeCell) {\n        throw new Error('TableCellResizer: Expected active cell.')\n      }\n\n      editor.update(\n        () => {\n          const tableCellNode = $getNearestNodeFromDOMNode(activeCell.elem)\n          if (!$isTableCellNode(tableCellNode)) {\n            throw new Error('TableCellResizer: Table cell node not found.')\n          }\n\n          const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode)\n\n          const tableRowIndex = $getTableRowIndexFromTableCellNode(tableCellNode)\n\n          const tableRows = tableNode.getChildren()\n\n          if (tableRowIndex >= tableRows.length || tableRowIndex < 0) {\n            throw new Error('Expected table cell to be inside of table row.')\n          }\n\n          const tableRow = tableRows[tableRowIndex]\n\n          if (!$isTableRowNode(tableRow)) {\n            throw new Error('Expected table row')\n          }\n\n          let height = tableRow.getHeight()\n          if (height === undefined) {\n            const rowCells = tableRow.getChildren<TableCellNode>()\n            height = Math.min(\n              ...rowCells.map((cell) => getCellNodeHeight(cell, editor) ?? Infinity),\n            )\n          }\n\n          const newHeight = Math.max(height + heightChange, MIN_ROW_HEIGHT)\n          tableRow.setHeight(newHeight)\n        },\n        { tag: 'skip-scroll-into-view' },\n      )\n    },\n    [activeCell, editor],\n  )\n\n  const getCellNodeWidth = (\n    cell: TableCellNode,\n    activeEditor: LexicalEditor,\n  ): number | undefined => {\n    const width = cell.getWidth()\n    if (width !== undefined) {\n      return width\n    }\n\n    const domCellNode = activeEditor.getElementByKey(cell.getKey())\n    if (domCellNode == null) {\n      return undefined\n    }\n    const computedStyle = getComputedStyle(domCellNode)\n    return (\n      domCellNode.clientWidth -\n      parseFloat(computedStyle.paddingLeft) -\n      parseFloat(computedStyle.paddingRight)\n    )\n  }\n\n  const getCellNodeHeight = (\n    cell: TableCellNode,\n    activeEditor: LexicalEditor,\n  ): number | undefined => {\n    const domCellNode = activeEditor.getElementByKey(cell.getKey())\n    return domCellNode?.clientHeight\n  }\n\n  const getCellColumnIndex = (tableCellNode: TableCellNode, tableMap: TableMapType) => {\n    for (let row = 0; row < tableMap.length; row++) {\n      for (let column = 0; column < tableMap[row].length; column++) {\n        if (tableMap[row][column].cell === tableCellNode) {\n          return column\n        }\n      }\n    }\n  }\n\n  const updateColumnWidth = useCallback(\n    (widthChange: number) => {\n      if (!activeCell) {\n        throw new Error('TableCellResizer: Expected active cell.')\n      }\n      editor.update(\n        () => {\n          const tableCellNode = $getNearestNodeFromDOMNode(activeCell.elem)\n          if (!$isTableCellNode(tableCellNode)) {\n            throw new Error('TableCellResizer: Table cell node not found.')\n          }\n\n          const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode)\n          const [tableMap] = $computeTableMapSkipCellCheck(tableNode, null, null)\n          const columnIndex = getCellColumnIndex(tableCellNode, tableMap)\n          if (columnIndex === undefined) {\n            throw new Error('TableCellResizer: Table column not found.')\n          }\n\n          for (let row = 0; row < tableMap.length; row++) {\n            const cell: TableMapValueType = tableMap[row][columnIndex]\n            if (\n              cell.startRow === row &&\n              (columnIndex === tableMap[row].length - 1 ||\n                tableMap[row][columnIndex].cell !== tableMap[row][columnIndex + 1].cell)\n            ) {\n              const width = getCellNodeWidth(cell.cell, editor)\n              if (width === undefined) {\n                continue\n              }\n              const newWidth = Math.max(width + widthChange, MIN_COLUMN_WIDTH)\n              cell.cell.setWidth(newWidth)\n            }\n          }\n        },\n        { tag: 'skip-scroll-into-view' },\n      )\n    },\n    [activeCell, editor],\n  )\n\n  const mouseUpHandler = useCallback(\n    (direction: MouseDraggingDirection) => {\n      const handler = (event: MouseEvent) => {\n        event.preventDefault()\n        event.stopPropagation()\n\n        if (!activeCell) {\n          throw new Error('TableCellResizer: Expected active cell.')\n        }\n\n        if (mouseStartPosRef.current) {\n          const { x, y } = mouseStartPosRef.current\n\n          if (activeCell === null) {\n            return\n          }\n          const zoom = calculateZoomLevel(event.target as Element)\n\n          if (isHeightChanging(direction)) {\n            const heightChange = (event.clientY - y) / zoom\n            updateRowHeight(heightChange)\n          } else {\n            const widthChange = (event.clientX - x) / zoom\n            updateColumnWidth(widthChange)\n          }\n\n          resetState()\n          document.removeEventListener('mouseup', handler)\n        }\n      }\n      return handler\n    },\n    [activeCell, resetState, updateColumnWidth, updateRowHeight],\n  )\n\n  const toggleResize = useCallback(\n    (direction: MouseDraggingDirection): MouseEventHandler<HTMLDivElement> =>\n      (event) => {\n        event.preventDefault()\n        event.stopPropagation()\n\n        if (!activeCell) {\n          throw new Error('TableCellResizer: Expected active cell.')\n        }\n\n        mouseStartPosRef.current = {\n          x: event.clientX,\n          y: event.clientY,\n        }\n        updateMouseCurrentPos(mouseStartPosRef.current)\n        updateDraggingDirection(direction)\n\n        document.addEventListener('mouseup', mouseUpHandler(direction))\n      },\n    [activeCell, mouseUpHandler],\n  )\n\n  const getResizers = useCallback(() => {\n    if (activeCell) {\n      const { height, left, top, width } = activeCell.elem.getBoundingClientRect()\n      const zoom = calculateZoomLevel(activeCell.elem)\n      const zoneWidth = 10 // Pixel width of the zone where you can drag the edge\n      const styles = {\n        bottom: {\n          backgroundColor: 'none',\n          cursor: 'row-resize',\n          height: `${zoneWidth}px`,\n          left: `${window.pageXOffset + left}px`,\n          top: `${window.pageYOffset + top + height - zoneWidth / 2}px`,\n          width: `${width}px`,\n        },\n        right: {\n          backgroundColor: 'none',\n          cursor: 'col-resize',\n          height: `${height}px`,\n          left: `${window.pageXOffset + left + width - zoneWidth / 2}px`,\n          top: `${window.pageYOffset + top}px`,\n          width: `${zoneWidth}px`,\n        },\n      }\n\n      const tableRect = tableRectRef.current\n\n      if (draggingDirection && mouseCurrentPos && tableRect) {\n        if (isHeightChanging(draggingDirection)) {\n          styles[draggingDirection].left = `${window.pageXOffset + tableRect.left}px`\n          styles[draggingDirection].top = `${window.pageYOffset + mouseCurrentPos.y / zoom}px`\n          styles[draggingDirection].height = '3px'\n          styles[draggingDirection].width = `${tableRect.width}px`\n        } else {\n          styles[draggingDirection].top = `${window.pageYOffset + tableRect.top}px`\n          styles[draggingDirection].left = `${window.pageXOffset + mouseCurrentPos.x / zoom}px`\n          styles[draggingDirection].width = '3px'\n          styles[draggingDirection].height = `${tableRect.height}px`\n        }\n\n        styles[draggingDirection].backgroundColor = '#adf'\n      }\n\n      return styles\n    }\n\n    return {\n      bottom: null,\n      left: null,\n      right: null,\n      top: null,\n    }\n  }, [activeCell, draggingDirection, mouseCurrentPos])\n\n  const resizerStyles = getResizers()\n\n  return (\n    <div ref={resizerRef}>\n      {activeCell != null && !isMouseDown && (\n        <React.Fragment>\n          <div\n            className=\"TableCellResizer__resizer TableCellResizer__ui\"\n            onMouseDown={toggleResize('right')}\n            style={resizerStyles.right || undefined}\n          />\n          <div\n            className=\"TableCellResizer__resizer TableCellResizer__ui\"\n            onMouseDown={toggleResize('bottom')}\n            style={resizerStyles.bottom || undefined}\n          />\n        </React.Fragment>\n      )}\n    </div>\n  )\n}\n\nexport const TableCellResizerPlugin: PluginComponent = () => {\n  const [editor] = useLexicalComposerContext()\n  const isEditable = useLexicalEditable()\n\n  return useMemo(\n    () => (isEditable ? createPortal(<TableCellResizer editor={editor} />, document.body) : null),\n    [editor, isEditable],\n  )\n}\n"],"names":["useLexicalComposerContext","useLexicalEditable","$computeTableMapSkipCellCheck","$getTableNodeFromLexicalNodeOrThrow","$getTableRowIndexFromTableCellNode","$isTableCellNode","$isTableRowNode","getDOMCellFromTarget","calculateZoomLevel","$getNearestNodeFromDOMNode","React","useCallback","useEffect","useMemo","useRef","useState","createPortal","MIN_ROW_HEIGHT","MIN_COLUMN_WIDTH","TableCellResizer","editor","targetRef","resizerRef","tableRectRef","mouseStartPosRef","mouseCurrentPos","updateMouseCurrentPos","activeCell","updateActiveCell","isMouseDown","updateIsMouseDown","draggingDirection","updateDraggingDirection","resetState","current","isMouseDownOnEvent","event","buttons","onMouseMove","setTimeout","target","x","clientX","y","clientY","contains","cell","update","tableCellNode","elem","Error","tableNode","tableElement","getElementByKey","getKey","getBoundingClientRect","onMouseDown","onMouseUp","document","addEventListener","removeEventListener","isHeightChanging","direction","updateRowHeight","heightChange","tableRowIndex","tableRows","getChildren","length","tableRow","height","getHeight","undefined","rowCells","Math","min","map","getCellNodeHeight","Infinity","newHeight","max","setHeight","tag","getCellNodeWidth","activeEditor","width","getWidth","domCellNode","computedStyle","getComputedStyle","clientWidth","parseFloat","paddingLeft","paddingRight","clientHeight","getCellColumnIndex","tableMap","row","column","updateColumnWidth","widthChange","columnIndex","startRow","newWidth","setWidth","mouseUpHandler","handler","preventDefault","stopPropagation","zoom","toggleResize","getResizers","left","top","zoneWidth","styles","bottom","backgroundColor","cursor","window","pageXOffset","pageYOffset","right","tableRect","resizerStyles","div","ref","Fragment","className","style","TableCellResizerPlugin","isEditable","body"],"mappings":"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"}
{"version":3,"sources":["../../../../../src/features/experimental_table/plugins/TableActionMenuPlugin/index.tsx"],"sourcesContent":["'use client'\n\nimport type {\n  HTMLTableElementWithWithTableSelectionState,\n  TableRowNode,\n  TableSelection,\n} from '@lexical/table'\nimport type { ElementNode } from 'lexical'\nimport type { JSX } from 'react'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext'\nimport { useLexicalEditable } from '@lexical/react/useLexicalEditable'\nimport {\n  $deleteTableColumn__EXPERIMENTAL,\n  $deleteTableRow__EXPERIMENTAL,\n  $getNodeTriplet,\n  $getTableCellNodeFromLexicalNode,\n  $getTableColumnIndexFromTableCellNode,\n  $getTableNodeFromLexicalNodeOrThrow,\n  $getTableRowIndexFromTableCellNode,\n  $insertTableColumn__EXPERIMENTAL,\n  $insertTableRow__EXPERIMENTAL,\n  $isTableCellNode,\n  $isTableRowNode,\n  $isTableSelection,\n  $unmergeCell,\n  TableCellHeaderStates,\n  TableCellNode,\n  getTableObserverFromTableElement,\n} from '@lexical/table'\nimport { useScrollInfo } from '@payloadcms/ui'\nimport {\n  $createParagraphNode,\n  $getRoot,\n  $getSelection,\n  $isElementNode,\n  $isParagraphNode,\n  $isRangeSelection,\n  $isTextNode,\n} from 'lexical'\nimport * as React from 'react'\nimport { useCallback, useEffect, useRef, useState } from 'react'\nimport { createPortal } from 'react-dom'\n\nimport type { PluginComponentWithAnchor } from '../../../typesClient.js'\n\nimport { MeatballsIcon } from '../../../../lexical/ui/icons/Meatballs/index.js'\nimport { invariant } from '../../../../lexical/utils/invariant.js'\nimport './index.scss'\n\nfunction computeSelectionCount(selection: TableSelection): {\n  columns: number\n  rows: number\n} {\n  const selectionShape = selection.getShape()\n  return {\n    columns: selectionShape.toX - selectionShape.fromX + 1,\n    rows: selectionShape.toY - selectionShape.fromY + 1,\n  }\n}\n\n// This is important when merging cells as there is no good way to re-merge weird shapes (a result\n// of selecting merged cells and non-merged)\nfunction isTableSelectionRectangular(selection: TableSelection): boolean {\n  const nodes = selection.getNodes()\n  const currentRows: Array<number> = []\n  let currentRow = null\n  let expectedColumns = null\n  let currentColumns = 0\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i]\n    if ($isTableCellNode(node)) {\n      const row = node.getParentOrThrow()\n      invariant($isTableRowNode(row), 'Expected CellNode to have a RowNode parent')\n      if (currentRow !== row) {\n        if (expectedColumns !== null && currentColumns !== expectedColumns) {\n          return false\n        }\n        if (currentRow !== null) {\n          expectedColumns = currentColumns\n        }\n        currentRow = row\n        currentColumns = 0\n      }\n      const colSpan = node.__colSpan\n      for (let j = 0; j < colSpan; j++) {\n        if (currentRows[currentColumns + j] === undefined) {\n          currentRows[currentColumns + j] = 0\n        }\n        currentRows[currentColumns + j] += node.__rowSpan\n      }\n      currentColumns += colSpan\n    }\n  }\n  return (\n    (expectedColumns === null || currentColumns === expectedColumns) &&\n    currentRows.every((v) => v === currentRows[0])\n  )\n}\n\nfunction $canUnmerge(): boolean {\n  const selection = $getSelection()\n  if (\n    ($isRangeSelection(selection) && !selection.isCollapsed()) ||\n    ($isTableSelection(selection) && !selection.anchor.is(selection.focus)) ||\n    (!$isRangeSelection(selection) && !$isTableSelection(selection))\n  ) {\n    return false\n  }\n  const [cell] = $getNodeTriplet(selection.anchor)\n  return cell.__colSpan > 1 || cell.__rowSpan > 1\n}\n\nfunction $cellContainsEmptyParagraph(cell: TableCellNode): boolean {\n  if (cell.getChildrenSize() !== 1) {\n    return false\n  }\n  const firstChild = cell.getFirstChildOrThrow()\n  if (!$isParagraphNode(firstChild) || !firstChild.isEmpty()) {\n    return false\n  }\n  return true\n}\n\nfunction $selectLastDescendant(node: ElementNode): void {\n  const lastDescendant = node.getLastDescendant()\n  if ($isTextNode(lastDescendant)) {\n    lastDescendant.select()\n  } else if ($isElementNode(lastDescendant)) {\n    lastDescendant.selectEnd()\n  } else if (lastDescendant !== null) {\n    lastDescendant.selectNext()\n  }\n}\n\ntype TableCellActionMenuProps = Readonly<{\n  cellMerge: boolean\n  contextRef: { current: HTMLElement | null }\n  onClose: () => void\n  setIsMenuOpen: (isOpen: boolean) => void\n  tableCellNode: TableCellNode\n}>\n\nfunction TableActionMenu({\n  cellMerge,\n  contextRef,\n  onClose,\n  setIsMenuOpen,\n  tableCellNode: _tableCellNode,\n}: TableCellActionMenuProps) {\n  const [editor] = useLexicalComposerContext()\n  const dropDownRef = useRef<HTMLDivElement | null>(null)\n  const [tableCellNode, updateTableCellNode] = useState(_tableCellNode)\n  const [selectionCounts, updateSelectionCounts] = useState({\n    columns: 1,\n    rows: 1,\n  })\n  const [canMergeCells, setCanMergeCells] = useState(false)\n  const [canUnmergeCell, setCanUnmergeCell] = useState(false)\n  const { y } = useScrollInfo()\n\n  useEffect(() => {\n    return editor.registerMutationListener(TableCellNode, (nodeMutations) => {\n      const nodeUpdated = nodeMutations.get(tableCellNode.getKey()) === 'updated'\n\n      if (nodeUpdated) {\n        editor.getEditorState().read(() => {\n          updateTableCellNode(tableCellNode.getLatest())\n        })\n      }\n    })\n  }, [editor, tableCellNode])\n\n  useEffect(() => {\n    editor.getEditorState().read(() => {\n      const selection = $getSelection()\n      // Merge cells\n      if ($isTableSelection(selection)) {\n        const currentSelectionCounts = computeSelectionCount(selection)\n        updateSelectionCounts(computeSelectionCount(selection))\n        setCanMergeCells(\n          isTableSelectionRectangular(selection) &&\n            (currentSelectionCounts.columns > 1 || currentSelectionCounts.rows > 1),\n        )\n      }\n      // Unmerge cell\n      setCanUnmergeCell($canUnmerge())\n    })\n  }, [editor])\n\n  useEffect(() => {\n    const menuButtonElement = contextRef.current\n    const dropDownElement = dropDownRef.current\n    const rootElement = editor.getRootElement()\n\n    if (menuButtonElement != null && dropDownElement != null && rootElement != null) {\n      const rootEleRect = rootElement.getBoundingClientRect()\n      const menuButtonRect = menuButtonElement.getBoundingClientRect()\n      dropDownElement.style.opacity = '1'\n      const dropDownElementRect = dropDownElement.getBoundingClientRect()\n      const margin = 5\n      let leftPosition = menuButtonRect.right + margin\n      if (\n        leftPosition + dropDownElementRect.width > window.innerWidth ||\n        leftPosition + dropDownElementRect.width > rootEleRect.right\n      ) {\n        const position = menuButtonRect.left - dropDownElementRect.width - margin\n        leftPosition = (position < 0 ? margin : position) + window.pageXOffset\n      }\n      dropDownElement.style.left = `${leftPosition + window.pageXOffset}px`\n\n      let topPosition = menuButtonRect.top\n      if (topPosition + dropDownElementRect.height > window.innerHeight) {\n        const position = menuButtonRect.bottom - dropDownElementRect.height\n        topPosition = (position < 0 ? margin : position) + window.pageYOffset\n      }\n      dropDownElement.style.top = `${topPosition}px`\n    }\n  }, [contextRef, dropDownRef, editor, y])\n\n  useEffect(() => {\n    function handleClickOutside(event: MouseEvent) {\n      if (\n        dropDownRef.current != null &&\n        contextRef.current != null &&\n        !dropDownRef.current.contains(event.target as Node) &&\n        !contextRef.current.contains(event.target as Node)\n      ) {\n        setIsMenuOpen(false)\n      }\n    }\n\n    window.addEventListener('click', handleClickOutside)\n\n    return () => window.removeEventListener('click', handleClickOutside)\n  }, [setIsMenuOpen, contextRef])\n\n  const clearTableSelection = useCallback(() => {\n    editor.update(() => {\n      if (tableCellNode.isAttached()) {\n        const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode)\n        const tableElement = editor.getElementByKey(\n          tableNode.getKey(),\n        ) as HTMLTableElementWithWithTableSelectionState\n\n        if (!tableElement) {\n          throw new Error('Expected to find tableElement in DOM')\n        }\n\n        const tableSelection = getTableObserverFromTableElement(tableElement)\n        if (tableSelection !== null) {\n          tableSelection.clearHighlight()\n        }\n\n        tableNode.markDirty()\n        updateTableCellNode(tableCellNode.getLatest())\n      }\n\n      const rootNode = $getRoot()\n      rootNode.selectStart()\n    })\n  }, [editor, tableCellNode])\n\n  const mergeTableCellsAtSelection = () => {\n    editor.update(() => {\n      const selection = $getSelection()\n      if ($isTableSelection(selection)) {\n        const { columns, rows } = computeSelectionCount(selection)\n        const nodes = selection.getNodes()\n        let firstCell: TableCellNode | null = null\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i]\n          if ($isTableCellNode(node)) {\n            if (firstCell === null) {\n              node.setColSpan(columns).setRowSpan(rows)\n              firstCell = node\n              const isEmpty = $cellContainsEmptyParagraph(node)\n              let firstChild\n              if (isEmpty && $isParagraphNode((firstChild = node.getFirstChild()))) {\n                firstChild.remove()\n              }\n            } else if ($isTableCellNode(firstCell)) {\n              const isEmpty = $cellContainsEmptyParagraph(node)\n              if (!isEmpty) {\n                firstCell.append(...node.getChildren())\n              }\n              node.remove()\n            }\n          }\n        }\n        if (firstCell !== null) {\n          if (firstCell.getChildrenSize() === 0) {\n            firstCell.append($createParagraphNode())\n          }\n          $selectLastDescendant(firstCell)\n        }\n        onClose()\n      }\n    })\n  }\n\n  const unmergeTableCellsAtSelection = () => {\n    editor.update(() => {\n      $unmergeCell()\n    })\n  }\n\n  const insertTableRowAtSelection = useCallback(\n    (shouldInsertAfter: boolean) => {\n      editor.update(() => {\n        $insertTableRow__EXPERIMENTAL(shouldInsertAfter)\n        onClose()\n      })\n    },\n    [editor, onClose],\n  )\n\n  const insertTableColumnAtSelection = useCallback(\n    (shouldInsertAfter: boolean) => {\n      editor.update(() => {\n        for (let i = 0; i < selectionCounts.columns; i++) {\n          $insertTableColumn__EXPERIMENTAL(shouldInsertAfter)\n        }\n        onClose()\n      })\n    },\n    [editor, onClose, selectionCounts.columns],\n  )\n\n  const deleteTableRowAtSelection = useCallback(() => {\n    editor.update(() => {\n      $deleteTableRow__EXPERIMENTAL()\n      onClose()\n    })\n  }, [editor, onClose])\n\n  const deleteTableAtSelection = useCallback(() => {\n    editor.update(() => {\n      const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode)\n      tableNode.remove()\n\n      clearTableSelection()\n      onClose()\n    })\n  }, [editor, tableCellNode, clearTableSelection, onClose])\n\n  const deleteTableColumnAtSelection = useCallback(() => {\n    editor.update(() => {\n      $deleteTableColumn__EXPERIMENTAL()\n      onClose()\n    })\n  }, [editor, onClose])\n\n  const toggleTableRowIsHeader = useCallback(() => {\n    editor.update(() => {\n      const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode)\n\n      const tableRowIndex = $getTableRowIndexFromTableCellNode(tableCellNode)\n\n      const tableRows = tableNode.getChildren()\n\n      if (tableRowIndex >= tableRows.length || tableRowIndex < 0) {\n        throw new Error('Expected table cell to be inside of table row.')\n      }\n\n      const tableRow = tableRows[tableRowIndex]\n\n      if (!$isTableRowNode(tableRow)) {\n        throw new Error('Expected table row')\n      }\n\n      tableRow.getChildren().forEach((tableCell) => {\n        if (!$isTableCellNode(tableCell)) {\n          throw new Error('Expected table cell')\n        }\n\n        tableCell.toggleHeaderStyle(TableCellHeaderStates.ROW)\n      })\n\n      clearTableSelection()\n      onClose()\n    })\n  }, [editor, tableCellNode, clearTableSelection, onClose])\n\n  const toggleTableColumnIsHeader = useCallback(() => {\n    editor.update(() => {\n      const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode)\n\n      const tableColumnIndex = $getTableColumnIndexFromTableCellNode(tableCellNode)\n\n      const tableRows = tableNode.getChildren<TableRowNode>()\n      const maxRowsLength = Math.max(...tableRows.map((row) => row.getChildren().length))\n\n      if (tableColumnIndex >= maxRowsLength || tableColumnIndex < 0) {\n        throw new Error('Expected table cell to be inside of table row.')\n      }\n\n      for (let r = 0; r < tableRows.length; r++) {\n        const tableRow = tableRows[r]\n\n        if (!$isTableRowNode(tableRow)) {\n          throw new Error('Expected table row')\n        }\n\n        const tableCells = tableRow.getChildren()\n        if (tableColumnIndex >= tableCells.length) {\n          // if cell is outside of bounds for the current row (for example various merge cell cases) we shouldn't highlight it\n          continue\n        }\n\n        const tableCell = tableCells[tableColumnIndex]\n\n        if (!$isTableCellNode(tableCell)) {\n          throw new Error('Expected table cell')\n        }\n\n        tableCell.toggleHeaderStyle(TableCellHeaderStates.COLUMN)\n      }\n\n      clearTableSelection()\n      onClose()\n    })\n  }, [editor, tableCellNode, clearTableSelection, onClose])\n\n  let mergeCellButton: JSX.Element | null = null\n  if (cellMerge) {\n    if (canMergeCells) {\n      mergeCellButton = (\n        <button\n          className=\"item\"\n          data-test-id=\"table-merge-cells\"\n          onClick={() => mergeTableCellsAtSelection()}\n          type=\"button\"\n        >\n          Merge cells\n        </button>\n      )\n    } else if (canUnmergeCell) {\n      mergeCellButton = (\n        <button\n          className=\"item\"\n          data-test-id=\"table-unmerge-cells\"\n          onClick={() => unmergeTableCellsAtSelection()}\n          type=\"button\"\n        >\n          Unmerge cells\n        </button>\n      )\n    }\n  }\n\n  return createPortal(\n    // eslint-disable-next-line jsx-a11y/no-static-element-interactions,jsx-a11y/click-events-have-key-events\n    <div\n      className=\"table-action-menu-dropdown\"\n      onClick={(e) => {\n        e.stopPropagation()\n      }}\n      ref={dropDownRef}\n    >\n      {mergeCellButton ? (\n        <React.Fragment>\n          {mergeCellButton}\n          <hr />\n        </React.Fragment>\n      ) : null}\n\n      <button\n        className=\"item\"\n        data-test-id=\"table-insert-row-above\"\n        onClick={() => insertTableRowAtSelection(false)}\n        type=\"button\"\n      >\n        <span className=\"text\">\n          Insert {selectionCounts.rows === 1 ? 'row' : `${selectionCounts.rows} rows`} above\n        </span>\n      </button>\n      <button\n        className=\"item\"\n        data-test-id=\"table-insert-row-below\"\n        onClick={() => insertTableRowAtSelection(true)}\n        type=\"button\"\n      >\n        <span className=\"text\">\n          Insert {selectionCounts.rows === 1 ? 'row' : `${selectionCounts.rows} rows`} below\n        </span>\n      </button>\n      <hr />\n      <button\n        className=\"item\"\n        data-test-id=\"table-insert-column-before\"\n        onClick={() => insertTableColumnAtSelection(false)}\n        type=\"button\"\n      >\n        <span className=\"text\">\n          Insert {selectionCounts.columns === 1 ? 'column' : `${selectionCounts.columns} columns`}{' '}\n          left\n        </span>\n      </button>\n      <button\n        className=\"item\"\n        data-test-id=\"table-insert-column-after\"\n        onClick={() => insertTableColumnAtSelection(true)}\n        type=\"button\"\n      >\n        <span className=\"text\">\n          Insert {selectionCounts.columns === 1 ? 'column' : `${selectionCounts.columns} columns`}{' '}\n          right\n        </span>\n      </button>\n      <hr />\n      <button\n        className=\"item\"\n        data-test-id=\"table-delete-columns\"\n        onClick={() => deleteTableColumnAtSelection()}\n        type=\"button\"\n      >\n        <span className=\"text\">Delete column</span>\n      </button>\n      <button\n        className=\"item\"\n        data-test-id=\"table-delete-rows\"\n        onClick={() => deleteTableRowAtSelection()}\n        type=\"button\"\n      >\n        <span className=\"text\">Delete row</span>\n      </button>\n      <button\n        className=\"item\"\n        data-test-id=\"table-delete\"\n        onClick={() => deleteTableAtSelection()}\n        type=\"button\"\n      >\n        <span className=\"text\">Delete table</span>\n      </button>\n      <hr />\n      <button className=\"item\" onClick={() => toggleTableRowIsHeader()} type=\"button\">\n        <span className=\"text\">\n          {(tableCellNode.__headerState & TableCellHeaderStates.ROW) === TableCellHeaderStates.ROW\n            ? 'Remove'\n            : 'Add'}{' '}\n          row header\n        </span>\n      </button>\n      <button\n        className=\"item\"\n        data-test-id=\"table-column-header\"\n        onClick={() => toggleTableColumnIsHeader()}\n        type=\"button\"\n      >\n        <span className=\"text\">\n          {(tableCellNode.__headerState & TableCellHeaderStates.COLUMN) ===\n          TableCellHeaderStates.COLUMN\n            ? 'Remove'\n            : 'Add'}{' '}\n          column header\n        </span>\n      </button>\n    </div>,\n    document.body,\n  )\n}\n\nfunction TableCellActionMenuContainer({\n  anchorElem,\n  cellMerge,\n}: {\n  anchorElem: HTMLElement\n  cellMerge: boolean\n}): JSX.Element {\n  const [editor] = useLexicalComposerContext()\n\n  const menuButtonRef = useRef(null)\n  const menuRootRef = useRef(null)\n  const [isMenuOpen, setIsMenuOpen] = useState(false)\n\n  const [tableCellNode, setTableMenuCellNode] = useState<TableCellNode | null>(null)\n\n  const $moveMenu = useCallback(() => {\n    const menu = menuButtonRef.current\n    const selection = $getSelection()\n    const nativeSelection = window.getSelection()\n    const activeElement = document.activeElement\n\n    if (selection == null || menu == null) {\n      setTableMenuCellNode(null)\n      return\n    }\n\n    const rootElement = editor.getRootElement()\n\n    if (\n      $isRangeSelection(selection) &&\n      rootElement !== null &&\n      nativeSelection !== null &&\n      rootElement.contains(nativeSelection.anchorNode)\n    ) {\n      const tableCellNodeFromSelection = $getTableCellNodeFromLexicalNode(\n        selection.anchor.getNode(),\n      )\n\n      if (tableCellNodeFromSelection == null) {\n        setTableMenuCellNode(null)\n        return\n      }\n\n      const tableCellParentNodeDOM = editor.getElementByKey(tableCellNodeFromSelection.getKey())\n\n      if (tableCellParentNodeDOM == null) {\n        setTableMenuCellNode(null)\n        return\n      }\n\n      setTableMenuCellNode(tableCellNodeFromSelection)\n    } else if (!activeElement) {\n      setTableMenuCellNode(null)\n    }\n  }, [editor])\n\n  useEffect(() => {\n    return editor.registerUpdateListener(() => {\n      editor.getEditorState().read(() => {\n        $moveMenu()\n      })\n    })\n  })\n\n  useEffect(() => {\n    const menuButtonDOM = menuButtonRef.current as HTMLButtonElement | null\n\n    if (menuButtonDOM != null && tableCellNode != null) {\n      const tableCellNodeDOM = editor.getElementByKey(tableCellNode.getKey())\n\n      if (tableCellNodeDOM != null) {\n        const tableCellRect = tableCellNodeDOM.getBoundingClientRect()\n        const menuRect = menuButtonDOM.getBoundingClientRect()\n        const anchorRect = anchorElem.getBoundingClientRect()\n\n        const top = tableCellRect.top - anchorRect.top + 4\n        const left = tableCellRect.right - menuRect.width - 10 - anchorRect.left\n\n        menuButtonDOM.style.opacity = '1'\n        menuButtonDOM.style.transform = `translate(${left}px, ${top}px)`\n      } else {\n        menuButtonDOM.style.opacity = '0'\n        menuButtonDOM.style.transform = 'translate(-10000px, -10000px)'\n      }\n    }\n  }, [menuButtonRef, tableCellNode, editor, anchorElem])\n\n  const prevTableCellDOM = useRef(tableCellNode)\n\n  useEffect(() => {\n    if (prevTableCellDOM.current !== tableCellNode) {\n      setIsMenuOpen(false)\n    }\n\n    prevTableCellDOM.current = tableCellNode\n  }, [prevTableCellDOM, tableCellNode])\n\n  return (\n    <div className=\"table-cell-action-button-container\" ref={menuButtonRef}>\n      {tableCellNode != null && (\n        <React.Fragment>\n          <button\n            className=\"table-cell-action-button\"\n            onClick={(e) => {\n              e.stopPropagation()\n              setIsMenuOpen(!isMenuOpen)\n            }}\n            ref={menuRootRef}\n            type=\"button\"\n          >\n            <MeatballsIcon />\n          </button>\n          {isMenuOpen && (\n            <TableActionMenu\n              cellMerge={cellMerge}\n              contextRef={menuRootRef}\n              onClose={() => setIsMenuOpen(false)}\n              setIsMenuOpen={setIsMenuOpen}\n              tableCellNode={tableCellNode}\n            />\n          )}\n        </React.Fragment>\n      )}\n    </div>\n  )\n}\n\nexport const TableActionMenuPlugin: PluginComponentWithAnchor = ({ anchorElem }) => {\n  const isEditable = useLexicalEditable()\n  return createPortal(\n    isEditable ? (\n      <TableCellActionMenuContainer anchorElem={anchorElem ?? document.body} cellMerge />\n    ) : null,\n    anchorElem ?? document.body,\n  )\n}\n"],"names":["useLexicalComposerContext","useLexicalEditable","$deleteTableColumn__EXPERIMENTAL","$deleteTableRow__EXPERIMENTAL","$getNodeTriplet","$getTableCellNodeFromLexicalNode","$getTableColumnIndexFromTableCellNode","$getTableNodeFromLexicalNodeOrThrow","$getTableRowIndexFromTableCellNode","$insertTableColumn__EXPERIMENTAL","$insertTableRow__EXPERIMENTAL","$isTableCellNode","$isTableRowNode","$isTableSelection","$unmergeCell","TableCellHeaderStates","TableCellNode","getTableObserverFromTableElement","useScrollInfo","$createParagraphNode","$getRoot","$getSelection","$isElementNode","$isParagraphNode","$isRangeSelection","$isTextNode","React","useCallback","useEffect","useRef","useState","createPortal","MeatballsIcon","invariant","computeSelectionCount","selection","selectionShape","getShape","columns","toX","fromX","rows","toY","fromY","isTableSelectionRectangular","nodes","getNodes","currentRows","currentRow","expectedColumns","currentColumns","i","length","node","row","getParentOrThrow","colSpan","__colSpan","j","undefined","__rowSpan","every","v","$canUnmerge","isCollapsed","anchor","is","focus","cell","$cellContainsEmptyParagraph","getChildrenSize","firstChild","getFirstChildOrThrow","isEmpty","$selectLastDescendant","lastDescendant","getLastDescendant","select","selectEnd","selectNext","TableActionMenu","cellMerge","contextRef","onClose","setIsMenuOpen","tableCellNode","_tableCellNode","editor","dropDownRef","updateTableCellNode","selectionCounts","updateSelectionCounts","canMergeCells","setCanMergeCells","canUnmergeCell","setCanUnmergeCell","y","registerMutationListener","nodeMutations","nodeUpdated","get","getKey","getEditorState","read","getLatest","currentSelectionCounts","menuButtonElement","current","dropDownElement","rootElement","getRootElement","rootEleRect","getBoundingClientRect","menuButtonRect","style","opacity","dropDownElementRect","margin","leftPosition","right","width","window","innerWidth","position","left","pageXOffset","topPosition","top","height","innerHeight","bottom","pageYOffset","handleClickOutside","event","contains","target","addEventListener","removeEventListener","clearTableSelection","update","isAttached","tableNode","tableElement","getElementByKey","Error","tableSelection","clearHighlight","markDirty","rootNode","selectStart","mergeTableCellsAtSelection","firstCell","setColSpan","setRowSpan","getFirstChild","remove","append","getChildren","unmergeTableCellsAtSelection","insertTableRowAtSelection","shouldInsertAfter","insertTableColumnAtSelection","deleteTableRowAtSelection","deleteTableAtSelection","deleteTableColumnAtSelection","toggleTableRowIsHeader","tableRowIndex","tableRows","tableRow","forEach","tableCell","toggleHeaderStyle","ROW","toggleTableColumnIsHeader","tableColumnIndex","maxRowsLength","Math","max","map","r","tableCells","COLUMN","mergeCellButton","button","className","data-test-id","onClick","type","div","e","stopPropagation","ref","Fragment","hr","span","__headerState","document","body","TableCellActionMenuContainer","anchorElem","menuButtonRef","menuRootRef","isMenuOpen","setTableMenuCellNode","$moveMenu","menu","nativeSelection","getSelection","activeElement","anchorNode","tableCellNodeFromSelection","getNode","tableCellParentNodeDOM","registerUpdateListener","menuButtonDOM","tableCellNodeDOM","tableCellRect","menuRect","anchorRect","transform","prevTableCellDOM","TableActionMenuPlugin","isEditable"],"mappings":"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"}
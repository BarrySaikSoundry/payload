{"version":3,"sources":["../../../../../src/features/migrations/slateToLexical/converter/index.ts"],"sourcesContent":["import type {\n  SerializedEditorState,\n  SerializedLexicalNode,\n  SerializedParagraphNode,\n  SerializedTextNode,\n} from 'lexical'\n\nimport type { SlateNode, SlateNodeConverter } from './types.js'\n\nimport { NodeFormat } from '../../../../lexical/utils/nodeFormat.js'\n\nexport function convertSlateToLexical({\n  converters,\n  slateData,\n}: {\n  converters: SlateNodeConverter[]\n  slateData: SlateNode[]\n}): SerializedEditorState {\n  return {\n    root: {\n      type: 'root',\n      children: convertSlateNodesToLexical({\n        canContainParagraphs: true,\n        converters,\n        parentNodeType: 'root',\n        slateNodes: slateData,\n      }),\n      direction: 'ltr',\n      format: '',\n      indent: 0,\n      version: 1,\n    },\n  }\n}\n\nexport function convertSlateNodesToLexical({\n  canContainParagraphs,\n  converters,\n  parentNodeType,\n  slateNodes,\n}: {\n  canContainParagraphs: boolean\n  converters: SlateNodeConverter[] | undefined\n  /**\n   * Type of the parent lexical node (not the type of the original, parent slate type)\n   */\n  parentNodeType: string\n  slateNodes: SlateNode[]\n}): SerializedLexicalNode[] {\n  if (!converters?.length) {\n    return []\n  }\n  const unknownConverter = converters.find((converter) => converter.nodeTypes.includes('unknown'))\n  return (\n    slateNodes.map((slateNode, i) => {\n      if (!('type' in slateNode)) {\n        if (canContainParagraphs) {\n          // This is a paragraph node. They do not have a type property in Slate\n          return convertParagraphNode(converters, slateNode)\n        } else {\n          // This is a simple text node. canContainParagraphs may be false if this is nested inside a paragraph already, since paragraphs cannot contain paragraphs\n          return convertTextNode(slateNode)\n        }\n      }\n      if (slateNode.type === 'p') {\n        return convertParagraphNode(converters, slateNode)\n      }\n\n      const converter = converters.find((converter) => converter.nodeTypes.includes(slateNode.type))\n\n      if (converter) {\n        return converter.converter({ childIndex: i, converters, parentNodeType, slateNode })\n      }\n\n      console.warn('slateToLexical > No converter found for node type: ' + slateNode.type)\n      return unknownConverter?.converter({\n        childIndex: i,\n        converters,\n        parentNodeType,\n        slateNode,\n      })\n    }) || []\n  )\n}\n\nexport function convertParagraphNode(\n  converters: SlateNodeConverter[],\n  node: SlateNode,\n): SerializedParagraphNode {\n  return {\n    type: 'paragraph',\n    children: convertSlateNodesToLexical({\n      canContainParagraphs: false,\n      converters,\n      parentNodeType: 'paragraph',\n      slateNodes: node.children || [],\n    }),\n    direction: 'ltr',\n    format: '',\n    indent: 0,\n    textFormat: 0,\n    version: 1,\n  }\n}\nexport function convertTextNode(node: SlateNode): SerializedTextNode {\n  return {\n    type: 'text',\n    detail: 0,\n    format: convertNodeToFormat(node),\n    mode: 'normal',\n    style: '',\n    text: node.text,\n    version: 1,\n  }\n}\n\nexport function convertNodeToFormat(node: SlateNode): number {\n  let format = 0\n  if (node.bold) {\n    format = format | NodeFormat.IS_BOLD\n  }\n  if (node.italic) {\n    format = format | NodeFormat.IS_ITALIC\n  }\n  if (node.strikethrough) {\n    format = format | NodeFormat.IS_STRIKETHROUGH\n  }\n  if (node.underline) {\n    format = format | NodeFormat.IS_UNDERLINE\n  }\n  if (node.subscript) {\n    format = format | NodeFormat.IS_SUBSCRIPT\n  }\n  if (node.superscript) {\n    format = format | NodeFormat.IS_SUPERSCRIPT\n  }\n  if (node.code) {\n    format = format | NodeFormat.IS_CODE\n  }\n  return format\n}\n"],"names":["NodeFormat","convertSlateToLexical","converters","slateData","root","type","children","convertSlateNodesToLexical","canContainParagraphs","parentNodeType","slateNodes","direction","format","indent","version","length","unknownConverter","find","converter","nodeTypes","includes","map","slateNode","i","convertParagraphNode","convertTextNode","childIndex","console","warn","node","textFormat","detail","convertNodeToFormat","mode","style","text","bold","IS_BOLD","italic","IS_ITALIC","strikethrough","IS_STRIKETHROUGH","underline","IS_UNDERLINE","subscript","IS_SUBSCRIPT","superscript","IS_SUPERSCRIPT","code","IS_CODE"],"mappings":"AASA,SAASA,UAAU,QAAQ,0CAAyC;AAEpE,OAAO,SAASC,sBAAsB,EACpCC,UAAU,EACVC,SAAS,EAIV;IACC,OAAO;QACLC,MAAM;YACJC,MAAM;YACNC,UAAUC,2BAA2B;gBACnCC,sBAAsB;gBACtBN;gBACAO,gBAAgB;gBAChBC,YAAYP;YACd;YACAQ,WAAW;YACXC,QAAQ;YACRC,QAAQ;YACRC,SAAS;QACX;IACF;AACF;AAEA,OAAO,SAASP,2BAA2B,EACzCC,oBAAoB,EACpBN,UAAU,EACVO,cAAc,EACdC,UAAU,EASX;IACC,IAAI,CAACR,YAAYa,QAAQ;QACvB,OAAO,EAAE;IACX;IACA,MAAMC,mBAAmBd,WAAWe,IAAI,CAAC,CAACC,YAAcA,UAAUC,SAAS,CAACC,QAAQ,CAAC;IACrF,OACEV,WAAWW,GAAG,CAAC,CAACC,WAAWC;QACzB,IAAI,CAAE,CAAA,UAAUD,SAAQ,GAAI;YAC1B,IAAId,sBAAsB;gBACxB,sEAAsE;gBACtE,OAAOgB,qBAAqBtB,YAAYoB;YAC1C,OAAO;gBACL,yJAAyJ;gBACzJ,OAAOG,gBAAgBH;YACzB;QACF;QACA,IAAIA,UAAUjB,IAAI,KAAK,KAAK;YAC1B,OAAOmB,qBAAqBtB,YAAYoB;QAC1C;QAEA,MAAMJ,YAAYhB,WAAWe,IAAI,CAAC,CAACC,YAAcA,UAAUC,SAAS,CAACC,QAAQ,CAACE,UAAUjB,IAAI;QAE5F,IAAIa,WAAW;YACb,OAAOA,UAAUA,SAAS,CAAC;gBAAEQ,YAAYH;gBAAGrB;gBAAYO;gBAAgBa;YAAU;QACpF;QAEAK,QAAQC,IAAI,CAAC,wDAAwDN,UAAUjB,IAAI;QACnF,OAAOW,kBAAkBE,UAAU;YACjCQ,YAAYH;YACZrB;YACAO;YACAa;QACF;IACF,MAAM,EAAE;AAEZ;AAEA,OAAO,SAASE,qBACdtB,UAAgC,EAChC2B,IAAe;IAEf,OAAO;QACLxB,MAAM;QACNC,UAAUC,2BAA2B;YACnCC,sBAAsB;YACtBN;YACAO,gBAAgB;YAChBC,YAAYmB,KAAKvB,QAAQ,IAAI,EAAE;QACjC;QACAK,WAAW;QACXC,QAAQ;QACRC,QAAQ;QACRiB,YAAY;QACZhB,SAAS;IACX;AACF;AACA,OAAO,SAASW,gBAAgBI,IAAe;IAC7C,OAAO;QACLxB,MAAM;QACN0B,QAAQ;QACRnB,QAAQoB,oBAAoBH;QAC5BI,MAAM;QACNC,OAAO;QACPC,MAAMN,KAAKM,IAAI;QACfrB,SAAS;IACX;AACF;AAEA,OAAO,SAASkB,oBAAoBH,IAAe;IACjD,IAAIjB,SAAS;IACb,IAAIiB,KAAKO,IAAI,EAAE;QACbxB,SAASA,SAASZ,WAAWqC,OAAO;IACtC;IACA,IAAIR,KAAKS,MAAM,EAAE;QACf1B,SAASA,SAASZ,WAAWuC,SAAS;IACxC;IACA,IAAIV,KAAKW,aAAa,EAAE;QACtB5B,SAASA,SAASZ,WAAWyC,gBAAgB;IAC/C;IACA,IAAIZ,KAAKa,SAAS,EAAE;QAClB9B,SAASA,SAASZ,WAAW2C,YAAY;IAC3C;IACA,IAAId,KAAKe,SAAS,EAAE;QAClBhC,SAASA,SAASZ,WAAW6C,YAAY;IAC3C;IACA,IAAIhB,KAAKiB,WAAW,EAAE;QACpBlC,SAASA,SAASZ,WAAW+C,cAAc;IAC7C;IACA,IAAIlB,KAAKmB,IAAI,EAAE;QACbpC,SAASA,SAASZ,WAAWiD,OAAO;IACtC;IACA,OAAOrC;AACT"}
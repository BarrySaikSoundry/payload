{"version":3,"sources":["../../../../src/features/blocks/plugin/index.tsx"],"sourcesContent":["'use client'\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { $insertNodeToNearestRoot, mergeRegister } from '@lexical/utils'\nimport {\n  $getPreviousSelection,\n  $getSelection,\n  $isParagraphNode,\n  $isRangeSelection,\n  COMMAND_PRIORITY_EDITOR,\n} from 'lexical'\nimport React, { useEffect } from 'react'\n\nimport type { PluginComponent } from '../../typesClient.js'\nimport type { BlocksFeatureClientProps } from '../feature.client.js'\nimport type { BlockFields } from '../nodes/BlocksNode.js'\n\nimport { BlocksDrawerComponent } from '../drawer/index.js'\nimport { $createBlockNode, BlockNode } from '../nodes/BlocksNode.js'\nimport { INSERT_BLOCK_COMMAND } from './commands.js'\n\nexport type InsertBlockPayload = Exclude<BlockFields, 'id'>\n\nexport const BlocksPlugin: PluginComponent<BlocksFeatureClientProps> = () => {\n  const [editor] = useLexicalComposerContext()\n\n  useEffect(() => {\n    if (!editor.hasNodes([BlockNode])) {\n      throw new Error('BlocksPlugin: BlocksNode not registered on editor')\n    }\n\n    return mergeRegister(\n      editor.registerCommand<InsertBlockPayload>(\n        INSERT_BLOCK_COMMAND,\n        (payload: InsertBlockPayload) => {\n          editor.update(() => {\n            const selection = $getSelection() || $getPreviousSelection()\n\n            if ($isRangeSelection(selection)) {\n              const blockNode = $createBlockNode(payload)\n              // Insert blocks node BEFORE potentially removing focusNode, as $insertNodeToNearestRoot errors if the focusNode doesn't exist\n              $insertNodeToNearestRoot(blockNode)\n\n              const { focus } = selection\n              const focusNode = focus.getNode()\n\n              // First, delete currently selected node if it's an empty paragraph and if there are sufficient\n              // paragraph nodes (more than 1) left in the parent node, so that we don't \"trap\" the user\n              if (\n                $isParagraphNode(focusNode) &&\n                focusNode.getTextContentSize() === 0 &&\n                focusNode\n                  .getParent()\n                  .getChildren()\n                  .filter((node) => $isParagraphNode(node)).length > 1\n              ) {\n                focusNode.remove()\n              }\n            }\n          })\n\n          return true\n        },\n        COMMAND_PRIORITY_EDITOR,\n      ),\n    )\n  }, [editor])\n\n  return <BlocksDrawerComponent />\n}\n"],"names":["useLexicalComposerContext","$insertNodeToNearestRoot","mergeRegister","$getPreviousSelection","$getSelection","$isParagraphNode","$isRangeSelection","COMMAND_PRIORITY_EDITOR","React","useEffect","BlocksDrawerComponent","$createBlockNode","BlockNode","INSERT_BLOCK_COMMAND","BlocksPlugin","editor","hasNodes","Error","registerCommand","payload","update","selection","blockNode","focus","focusNode","getNode","getTextContentSize","getParent","getChildren","filter","node","length","remove"],"mappings":"AAAA;;AACA,SAASA,yBAAyB,QAAQ,2CAA0C;AACpF,SAASC,wBAAwB,EAAEC,aAAa,QAAQ,iBAAgB;AACxE,SACEC,qBAAqB,EACrBC,aAAa,EACbC,gBAAgB,EAChBC,iBAAiB,EACjBC,uBAAuB,QAClB,UAAS;AAChB,OAAOC,SAASC,SAAS,QAAQ,QAAO;AAMxC,SAASC,qBAAqB,QAAQ,qBAAoB;AAC1D,SAASC,gBAAgB,EAAEC,SAAS,QAAQ,yBAAwB;AACpE,SAASC,oBAAoB,QAAQ,gBAAe;AAIpD,OAAO,MAAMC,eAA0D;IACrE,MAAM,CAACC,OAAO,GAAGf;IAEjBS,UAAU;QACR,IAAI,CAACM,OAAOC,QAAQ,CAAC;YAACJ;SAAU,GAAG;YACjC,MAAM,IAAIK,MAAM;QAClB;QAEA,OAAOf,cACLa,OAAOG,eAAe,CACpBL,sBACA,CAACM;YACCJ,OAAOK,MAAM,CAAC;gBACZ,MAAMC,YAAYjB,mBAAmBD;gBAErC,IAAIG,kBAAkBe,YAAY;oBAChC,MAAMC,YAAYX,iBAAiBQ;oBACnC,8HAA8H;oBAC9HlB,yBAAyBqB;oBAEzB,MAAM,EAAEC,KAAK,EAAE,GAAGF;oBAClB,MAAMG,YAAYD,MAAME,OAAO;oBAE/B,+FAA+F;oBAC/F,0FAA0F;oBAC1F,IACEpB,iBAAiBmB,cACjBA,UAAUE,kBAAkB,OAAO,KACnCF,UACGG,SAAS,GACTC,WAAW,GACXC,MAAM,CAAC,CAACC,OAASzB,iBAAiByB,OAAOC,MAAM,GAAG,GACrD;wBACAP,UAAUQ,MAAM;oBAClB;gBACF;YACF;YAEA,OAAO;QACT,GACAzB;IAGN,GAAG;QAACQ;KAAO;IAEX,qBAAO,KAACL;AACV,EAAC"}
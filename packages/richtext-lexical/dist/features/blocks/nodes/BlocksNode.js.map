{"version":3,"sources":["../../../../src/features/blocks/nodes/BlocksNode.tsx"],"sourcesContent":["import type { SerializedDecoratorBlockNode } from '@lexical/react/LexicalDecoratorBlockNode.js'\nimport type {\n  DOMConversionMap,\n  DOMExportOutput,\n  EditorConfig,\n  ElementFormatType,\n  LexicalEditor,\n  LexicalNode,\n  NodeKey,\n  Spread,\n} from 'lexical'\n\nimport { DecoratorBlockNode } from '@lexical/react/LexicalDecoratorBlockNode.js'\nimport ObjectID from 'bson-objectid'\nimport React, { type JSX } from 'react'\n\nexport type BlockFields<TBlockFields extends object = Record<string, unknown>> = {\n  /** Block form data */\n  blockName: string\n  blockType: string\n  id: string\n} & TBlockFields\n\nconst BlockComponent = React.lazy(() =>\n  import('../component/index.js').then((module) => ({\n    default: module.BlockComponent,\n  })),\n)\n\nexport type SerializedBlockNode<TBlockFields extends object = Record<string, unknown>> = Spread<\n  {\n    children?: never // required so that our typed editor state doesn't automatically add children\n    fields: BlockFields<TBlockFields>\n    type: 'block'\n  },\n  SerializedDecoratorBlockNode\n>\n\nexport class BlockNode extends DecoratorBlockNode {\n  __fields: BlockFields\n\n  constructor({\n    fields,\n    format,\n    key,\n  }: {\n    fields: BlockFields\n    format?: ElementFormatType\n    key?: NodeKey\n  }) {\n    super(format, key)\n    this.__fields = fields\n  }\n\n  static clone(node: BlockNode): BlockNode {\n    return new BlockNode({\n      fields: node.__fields,\n      format: node.__format,\n      key: node.__key,\n    })\n  }\n\n  static getType(): string {\n    return 'block'\n  }\n\n  static importDOM(): DOMConversionMap<HTMLDivElement> | null {\n    return {}\n  }\n\n  static importJSON(serializedNode: SerializedBlockNode): BlockNode {\n    if (serializedNode.version === 1) {\n      // Convert (version 1 had the fields wrapped in another, unnecessary data property)\n      serializedNode = {\n        ...serializedNode,\n        fields: {\n          ...(serializedNode as any).fields.data,\n        },\n        version: 2,\n      }\n    }\n    const node = $createBlockNode(serializedNode.fields)\n    node.setFormat(serializedNode.format)\n    return node\n  }\n\n  static isInline(): false {\n    return false\n  }\n  decorate(editor: LexicalEditor, config: EditorConfig): JSX.Element {\n    // @ts-expect-error\n    return <BlockComponent formData={this.getFields()} nodeKey={this.getKey()} />\n  }\n\n  exportDOM(): DOMExportOutput {\n    const element = document.createElement('div')\n\n    const text = document.createTextNode(this.getTextContent())\n    element.append(text)\n    return { element }\n  }\n\n  exportJSON(): SerializedBlockNode {\n    return {\n      ...super.exportJSON(),\n      type: 'block',\n      fields: this.getFields(),\n      version: 2,\n    }\n  }\n\n  getFields(): BlockFields {\n    return this.getLatest().__fields\n  }\n\n  getTextContent(): string {\n    return `Block Field`\n  }\n\n  setFields(fields: BlockFields): void {\n    const fieldsCopy = JSON.parse(JSON.stringify(fields)) as BlockFields\n\n    const writable = this.getWritable()\n    writable.__fields = fieldsCopy\n  }\n}\n\nexport function $createBlockNode(fields: Exclude<BlockFields, 'id'>): BlockNode {\n  return new BlockNode({\n    fields: {\n      ...fields,\n      id: fields?.id || new ObjectID.default().toHexString(),\n    },\n  })\n}\n\nexport function $isBlockNode(node: BlockNode | LexicalNode | null | undefined): node is BlockNode {\n  return node instanceof BlockNode\n}\n"],"names":["DecoratorBlockNode","ObjectID","React","BlockComponent","lazy","then","module","default","BlockNode","__fields","constructor","fields","format","key","clone","node","__format","__key","getType","importDOM","importJSON","serializedNode","version","data","$createBlockNode","setFormat","isInline","decorate","editor","config","formData","getFields","nodeKey","getKey","exportDOM","element","document","createElement","text","createTextNode","getTextContent","append","exportJSON","type","getLatest","setFields","fieldsCopy","JSON","parse","stringify","writable","getWritable","id","toHexString","$isBlockNode"],"mappings":";AAYA,SAASA,kBAAkB,QAAQ,8CAA6C;AAChF,OAAOC,cAAc,gBAAe;AACpC,OAAOC,WAAyB,QAAO;AASvC,MAAMC,+BAAiBD,MAAME,IAAI,CAAC,IAChC,MAAM,CAAC,yBAAyBC,IAAI,CAAC,CAACC,SAAY,CAAA;YAChDC,SAASD,OAAOH,cAAc;QAChC,CAAA;AAYF,OAAO,MAAMK,kBAAkBR;IAC7BS,SAAqB;IAErBC,YAAY,EACVC,MAAM,EACNC,MAAM,EACNC,GAAG,EAKJ,CAAE;QACD,KAAK,CAACD,QAAQC;QACd,IAAI,CAACJ,QAAQ,GAAGE;IAClB;IAEA,OAAOG,MAAMC,IAAe,EAAa;QACvC,OAAO,IAAIP,UAAU;YACnBG,QAAQI,KAAKN,QAAQ;YACrBG,QAAQG,KAAKC,QAAQ;YACrBH,KAAKE,KAAKE,KAAK;QACjB;IACF;IAEA,OAAOC,UAAkB;QACvB,OAAO;IACT;IAEA,OAAOC,YAAqD;QAC1D,OAAO,CAAC;IACV;IAEA,OAAOC,WAAWC,cAAmC,EAAa;QAChE,IAAIA,eAAeC,OAAO,KAAK,GAAG;YAChC,mFAAmF;YACnFD,iBAAiB;gBACf,GAAGA,cAAc;gBACjBV,QAAQ;oBACN,GAAG,AAACU,eAAuBV,MAAM,CAACY,IAAI;gBACxC;gBACAD,SAAS;YACX;QACF;QACA,MAAMP,OAAOS,iBAAiBH,eAAeV,MAAM;QACnDI,KAAKU,SAAS,CAACJ,eAAeT,MAAM;QACpC,OAAOG;IACT;IAEA,OAAOW,WAAkB;QACvB,OAAO;IACT;IACAC,SAASC,MAAqB,EAAEC,MAAoB,EAAe;QACjE,mBAAmB;QACnB,qBAAO,KAAC1B;YAAe2B,UAAU,IAAI,CAACC,SAAS;YAAIC,SAAS,IAAI,CAACC,MAAM;;IACzE;IAEAC,YAA6B;QAC3B,MAAMC,UAAUC,SAASC,aAAa,CAAC;QAEvC,MAAMC,OAAOF,SAASG,cAAc,CAAC,IAAI,CAACC,cAAc;QACxDL,QAAQM,MAAM,CAACH;QACf,OAAO;YAAEH;QAAQ;IACnB;IAEAO,aAAkC;QAChC,OAAO;YACL,GAAG,KAAK,CAACA,YAAY;YACrBC,MAAM;YACNhC,QAAQ,IAAI,CAACoB,SAAS;YACtBT,SAAS;QACX;IACF;IAEAS,YAAyB;QACvB,OAAO,IAAI,CAACa,SAAS,GAAGnC,QAAQ;IAClC;IAEA+B,iBAAyB;QACvB,OAAO,CAAC,WAAW,CAAC;IACtB;IAEAK,UAAUlC,MAAmB,EAAQ;QACnC,MAAMmC,aAAaC,KAAKC,KAAK,CAACD,KAAKE,SAAS,CAACtC;QAE7C,MAAMuC,WAAW,IAAI,CAACC,WAAW;QACjCD,SAASzC,QAAQ,GAAGqC;IACtB;AACF;AAEA,OAAO,SAAStB,iBAAiBb,MAAkC;IACjE,OAAO,IAAIH,UAAU;QACnBG,QAAQ;YACN,GAAGA,MAAM;YACTyC,IAAIzC,QAAQyC,MAAM,IAAInD,SAASM,OAAO,GAAG8C,WAAW;QACtD;IACF;AACF;AAEA,OAAO,SAASC,aAAavC,IAAgD;IAC3E,OAAOA,gBAAgBP;AACzB"}
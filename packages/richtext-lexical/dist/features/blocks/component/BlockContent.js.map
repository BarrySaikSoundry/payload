{"version":3,"sources":["../../../../src/features/blocks/component/BlockContent.tsx"],"sourcesContent":["import type { FormFieldBase } from '@payloadcms/ui'\nimport type { FieldMap, ReducedBlock } from '@payloadcms/ui/utilities/buildComponentMap'\nimport type { CollapsedPreferences, Data, FormState } from 'payload'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { getTranslation } from '@payloadcms/translations'\nimport {\n  Button,\n  Collapsible,\n  ErrorPill,\n  Pill,\n  RenderFields,\n  SectionTitle,\n  useDocumentInfo,\n  useFormSubmitted,\n  useTranslation,\n} from '@payloadcms/ui'\nimport { dequal } from 'dequal/lite' // lite: no need for Map and Set support\nimport { $getNodeByKey } from 'lexical'\nimport React, { useCallback } from 'react'\n\nimport type { SanitizedClientEditorConfig } from '../../../lexical/config/types.js'\nimport type { BlockFields, BlockNode } from '../nodes/BlocksNode.js'\n\nimport { FormSavePlugin } from './FormSavePlugin.js'\n\ntype Props = {\n  baseClass: string\n  field: {\n    editorConfig: SanitizedClientEditorConfig // With rendered features n stuff\n    name: string\n    richTextComponentMap: Map<string, React.ReactNode>\n  } & FormFieldBase\n  formData: BlockFields\n  formSchema: FieldMap\n  nodeKey: string\n  path: string\n  reducedBlock: ReducedBlock\n  schemaPath: string\n}\n\n/**\n * The actual content of the Block. This should be INSIDE a Form component,\n * scoped to the block. All format operations in here are thus scoped to the block's form, and\n * not the whole document.\n */\nexport const BlockContent: React.FC<Props> = (props) => {\n  const {\n    baseClass,\n    field,\n    formData,\n    formSchema,\n    nodeKey,\n    reducedBlock: { labels },\n    schemaPath,\n  } = props\n\n  const { i18n } = useTranslation()\n  const [editor] = useLexicalComposerContext()\n  // Used for saving collapsed to preferences (and gettin' it from there again)\n  // Remember, these preferences are scoped to the whole document, not just this form. This\n  // is important to consider for the data path used in setDocFieldPreferences\n  const { getDocPreferences, setDocFieldPreferences } = useDocumentInfo()\n\n  const [isCollapsed, setIsCollapsed] = React.useState<boolean>(() => {\n    let initialState = false\n\n    void getDocPreferences().then((currentDocPreferences) => {\n      const currentFieldPreferences = currentDocPreferences?.fields[field.name]\n\n      const collapsedArray = currentFieldPreferences?.collapsed\n\n      if (collapsedArray && collapsedArray.includes(formData.id)) {\n        initialState = true\n        setIsCollapsed(true)\n      }\n    })\n    return initialState\n  })\n\n  const hasSubmitted = useFormSubmitted()\n\n  const [errorCount, setErrorCount] = React.useState(0)\n\n  const fieldHasErrors = hasSubmitted && errorCount > 0\n\n  const classNames = [\n    `${baseClass}__row`,\n    fieldHasErrors ? `${baseClass}__row--has-errors` : `${baseClass}__row--no-errors`,\n  ]\n    .filter(Boolean)\n    .join(' ')\n\n  const onFormChange = useCallback(\n    ({\n      fullFieldsWithValues,\n      newFormData,\n    }: {\n      fullFieldsWithValues: FormState\n      newFormData: Data\n    }) => {\n      newFormData = {\n        ...newFormData,\n        id: formData.id,\n        blockType: formData.blockType,\n      }\n\n      // Recursively remove all undefined values from even being present in formData, as they will\n      // cause isDeepEqual to return false if, for example, formData has a key that fields.data\n      // does not have, even if it's undefined.\n      // Currently, this happens if a block has another sub-blocks field. Inside formData, that sub-blocks field has an undefined blockName property.\n      // Inside of fields.data however, that sub-blocks blockName property does not exist at all.\n      function removeUndefinedAndNullAndEmptyArraysRecursively(obj: object) {\n        for (const key in obj) {\n          const value = obj[key]\n          if (Array.isArray(value) && !value?.length) {\n            delete obj[key]\n          } else if (value && typeof value === 'object') {\n            removeUndefinedAndNullAndEmptyArraysRecursively(value)\n          } else if (value === undefined || value === null) {\n            delete obj[key]\n          }\n        }\n      }\n      removeUndefinedAndNullAndEmptyArraysRecursively(newFormData)\n\n      removeUndefinedAndNullAndEmptyArraysRecursively(formData)\n\n      // Only update if the data has actually changed. Otherwise, we may be triggering an unnecessary value change,\n      // which would trigger the \"Leave without saving\" dialog unnecessarily\n      if (!dequal(formData, newFormData)) {\n        // Running this in the next tick in the meantime fixes this issue: https://github.com/payloadcms/payload/issues/4108\n        // I don't know why. When this is called immediately, it might focus out of a nested lexical editor field if an update is made there.\n        // My hypothesis is that the nested editor might not have fully finished its update cycle yet. By updating in the next tick, we\n        // ensure that the nested editor has finished its update cycle before we update the block node.\n        setTimeout(() => {\n          editor.update(() => {\n            const node: BlockNode = $getNodeByKey(nodeKey)\n            if (node) {\n              node.setFields(newFormData as BlockFields)\n            }\n          })\n        }, 0)\n      }\n\n      // update error count\n      if (hasSubmitted) {\n        let rowErrorCount = 0\n        for (const formField of Object.values(fullFieldsWithValues)) {\n          if (formField?.valid === false) {\n            rowErrorCount++\n          }\n        }\n        setErrorCount(rowErrorCount)\n      }\n    },\n    [editor, nodeKey, hasSubmitted, formData],\n  )\n\n  const onCollapsedChange = useCallback(\n    (changedCollapsed: boolean) => {\n      void getDocPreferences().then((currentDocPreferences) => {\n        const currentFieldPreferences = currentDocPreferences?.fields[field.name]\n\n        const collapsedArray = currentFieldPreferences?.collapsed\n\n        const newCollapsed: CollapsedPreferences =\n          collapsedArray && collapsedArray?.length ? collapsedArray : []\n\n        if (changedCollapsed) {\n          if (!newCollapsed.includes(formData.id)) {\n            newCollapsed.push(formData.id)\n          }\n        } else {\n          if (newCollapsed.includes(formData.id)) {\n            newCollapsed.splice(newCollapsed.indexOf(formData.id), 1)\n          }\n        }\n\n        setDocFieldPreferences(field.name, {\n          collapsed: newCollapsed,\n          hello: 'hi',\n        })\n      })\n    },\n    [getDocPreferences, field.name, setDocFieldPreferences, formData.id],\n  )\n\n  const removeBlock = useCallback(() => {\n    editor.update(() => {\n      $getNodeByKey(nodeKey).remove()\n    })\n  }, [editor, nodeKey])\n\n  return (\n    <React.Fragment>\n      <Collapsible\n        className={classNames}\n        collapsibleStyle={fieldHasErrors ? 'error' : 'default'}\n        header={\n          <div className={`${baseClass}__block-header`}>\n            <div>\n              <Pill\n                className={`${baseClass}__block-pill ${baseClass}__block-pill-${formData?.blockType}`}\n                pillStyle=\"white\"\n              >\n                {typeof labels.singular === 'string'\n                  ? getTranslation(labels.singular, i18n)\n                  : '[Singular Label]'}\n              </Pill>\n              <SectionTitle path=\"blockName\" readOnly={field?.readOnly} />\n              {fieldHasErrors && <ErrorPill count={errorCount} i18n={i18n} withMessage />}\n            </div>\n            {editor.isEditable() && (\n              <Button\n                buttonStyle=\"icon-label\"\n                className={`${baseClass}__removeButton`}\n                disabled={field?.readOnly}\n                icon=\"x\"\n                onClick={(e) => {\n                  e.preventDefault()\n                  removeBlock()\n                }}\n                round\n                tooltip=\"Remove Block\"\n              />\n            )}\n          </div>\n        }\n        isCollapsed={isCollapsed}\n        key={0}\n        onToggle={(incomingCollapsedState) => {\n          onCollapsedChange(incomingCollapsedState)\n          setIsCollapsed(incomingCollapsedState)\n        }}\n      >\n        <RenderFields\n          className={`${baseClass}__fields`}\n          fieldMap={Array.isArray(formSchema) ? formSchema : []}\n          forceRender\n          margins=\"small\"\n          path=\"\" // Leaving path empty makes it so field values are not prefixed / scoped by the entire schemaPath. e.g. we can access \"myField\" instead of \"someLexicalField.feature.blocks.someArrayB\" // TODO: Could there be any implications leaving path different than schemaPath?\n          readOnly={false}\n          schemaPath={schemaPath} // Having the correct schemaPath here allows sub-fields (like array > addRow) to run correct form-state calls and retrieve their needed form state from the server\n        />\n      </Collapsible>\n\n      <FormSavePlugin onChange={onFormChange} />\n    </React.Fragment>\n  )\n}\n"],"names":["useLexicalComposerContext","getTranslation","Button","Collapsible","ErrorPill","Pill","RenderFields","SectionTitle","useDocumentInfo","useFormSubmitted","useTranslation","dequal","$getNodeByKey","React","useCallback","FormSavePlugin","BlockContent","props","baseClass","field","formData","formSchema","nodeKey","reducedBlock","labels","schemaPath","i18n","editor","getDocPreferences","setDocFieldPreferences","isCollapsed","setIsCollapsed","useState","initialState","then","currentDocPreferences","currentFieldPreferences","fields","name","collapsedArray","collapsed","includes","id","hasSubmitted","errorCount","setErrorCount","fieldHasErrors","classNames","filter","Boolean","join","onFormChange","fullFieldsWithValues","newFormData","blockType","removeUndefinedAndNullAndEmptyArraysRecursively","obj","key","value","Array","isArray","length","undefined","setTimeout","update","node","setFields","rowErrorCount","formField","Object","values","valid","onCollapsedChange","changedCollapsed","newCollapsed","push","splice","indexOf","hello","removeBlock","remove","Fragment","className","collapsibleStyle","header","div","pillStyle","singular","path","readOnly","count","withMessage","isEditable","buttonStyle","disabled","icon","onClick","e","preventDefault","round","tooltip","onToggle","incomingCollapsedState","fieldMap","forceRender","margins","onChange"],"mappings":"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"}
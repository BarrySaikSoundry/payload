{"version":3,"sources":["../../../../src/features/horizontalRule/nodes/HorizontalRuleNode.tsx"],"sourcesContent":["import type {\n  DOMConversionMap,\n  DOMConversionOutput,\n  DOMExportOutput,\n  EditorConfig,\n  LexicalCommand,\n  LexicalNode,\n  SerializedLexicalNode,\n  Spread,\n} from 'lexical'\n\nimport { addClassNamesToElement } from '@lexical/utils'\nimport { $applyNodeReplacement, DecoratorNode, createCommand } from 'lexical'\nimport * as React from 'react'\n\nconst HorizontalRuleComponent = React.lazy(() =>\n  import('../component/index.js').then((module) => ({\n    default: module.HorizontalRuleComponent,\n  })),\n)\n\n/**\n * Serialized representation of a horizontal rule node. Serialized = converted to JSON. This is what is stored in the database / in the lexical editor state.\n */\nexport type SerializedHorizontalRuleNode = Spread<\n  {\n    children?: never // required so that our typed editor state doesn't automatically add children\n    type: 'horizontalrule'\n  },\n  SerializedLexicalNode\n>\n\nexport const INSERT_HORIZONTAL_RULE_COMMAND: LexicalCommand<void> = createCommand(\n  'INSERT_HORIZONTAL_RULE_COMMAND',\n)\n\n/**\n * This node is a DecoratorNode. DecoratorNodes allow you to render React components in the editor.\n *\n * They need both createDom and decorate functions. createDom => outside of the html. decorate => React Component inside of the html.\n *\n * If we used DecoratorBlockNode instead, we would only need a decorate method\n */\nexport class HorizontalRuleNode extends DecoratorNode<React.ReactElement> {\n  static clone(node: HorizontalRuleNode): HorizontalRuleNode {\n    return new HorizontalRuleNode(node.__key)\n  }\n\n  static getType(): string {\n    return 'horizontalrule'\n  }\n\n  /**\n   * Defines what happens if you copy an hr element from another page and paste it into the lexical editor\n   *\n   * This also determines the behavior of lexical's internal HTML -> Lexical converter\n   */\n  static importDOM(): DOMConversionMap | null {\n    return {\n      hr: () => ({\n        conversion: $convertHorizontalRuleElement,\n        priority: 0,\n      }),\n    }\n  }\n\n  /**\n   * The data for this node is stored serialized as JSON. This is the \"load function\" of that node: it takes the saved data and converts it into a node.\n   */\n  static importJSON(serializedNode: SerializedHorizontalRuleNode): HorizontalRuleNode {\n    return $createHorizontalRuleNode()\n  }\n\n  /**\n   * Determines how the hr element is rendered in the lexical editor. This is only the \"initial\" / \"outer\" HTML element.\n   */\n  createDOM(config: EditorConfig): HTMLElement {\n    const element = document.createElement('hr')\n    addClassNamesToElement(element, config.theme.hr)\n    return element\n  }\n\n  /**\n   * Allows you to render a React component within whatever createDOM returns.\n   */\n  decorate(): React.ReactElement {\n    return <HorizontalRuleComponent nodeKey={this.__key} />\n  }\n\n  /**\n   * Opposite of importDOM, this function defines what happens when you copy an hr element from the lexical editor and paste it into another page.\n   *\n   * This also determines the behavior of lexical's internal Lexical -> HTML converter\n   */\n  exportDOM(): DOMExportOutput {\n    return { element: document.createElement('hr') }\n  }\n  /**\n   * Opposite of importJSON. This determines what data is saved in the database / in the lexical editor state.\n   */\n  exportJSON(): SerializedLexicalNode {\n    return {\n      type: 'horizontalrule',\n      version: 1,\n    }\n  }\n\n  getTextContent(): string {\n    return '\\n'\n  }\n\n  isInline(): false {\n    return false\n  }\n\n  updateDOM(): boolean {\n    return false\n  }\n}\n\nfunction $convertHorizontalRuleElement(): DOMConversionOutput {\n  return { node: $createHorizontalRuleNode() }\n}\n\nexport function $createHorizontalRuleNode(): HorizontalRuleNode {\n  return $applyNodeReplacement(new HorizontalRuleNode())\n}\n\nexport function $isHorizontalRuleNode(\n  node: LexicalNode | null | undefined,\n): node is HorizontalRuleNode {\n  return node instanceof HorizontalRuleNode\n}\n"],"names":["addClassNamesToElement","$applyNodeReplacement","DecoratorNode","createCommand","React","HorizontalRuleComponent","lazy","then","module","default","INSERT_HORIZONTAL_RULE_COMMAND","HorizontalRuleNode","clone","node","__key","getType","importDOM","hr","conversion","$convertHorizontalRuleElement","priority","importJSON","serializedNode","$createHorizontalRuleNode","createDOM","config","element","document","createElement","theme","decorate","nodeKey","exportDOM","exportJSON","type","version","getTextContent","isInline","updateDOM","$isHorizontalRuleNode"],"mappings":";AAWA,SAASA,sBAAsB,QAAQ,iBAAgB;AACvD,SAASC,qBAAqB,EAAEC,aAAa,EAAEC,aAAa,QAAQ,UAAS;AAC7E,YAAYC,WAAW,QAAO;AAE9B,MAAMC,wCAA0BD,MAAME,IAAI,CAAC,IACzC,MAAM,CAAC,yBAAyBC,IAAI,CAAC,CAACC,SAAY,CAAA;YAChDC,SAASD,OAAOH,uBAAuB;QACzC,CAAA;AAcF,OAAO,MAAMK,iCAAuDP,cAClE,kCACD;AAED;;;;;;CAMC,GACD,OAAO,MAAMQ,2BAA2BT;IACtC,OAAOU,MAAMC,IAAwB,EAAsB;QACzD,OAAO,IAAIF,mBAAmBE,KAAKC,KAAK;IAC1C;IAEA,OAAOC,UAAkB;QACvB,OAAO;IACT;IAEA;;;;GAIC,GACD,OAAOC,YAAqC;QAC1C,OAAO;YACLC,IAAI,IAAO,CAAA;oBACTC,YAAYC;oBACZC,UAAU;gBACZ,CAAA;QACF;IACF;IAEA;;GAEC,GACD,OAAOC,WAAWC,cAA4C,EAAsB;QAClF,OAAOC;IACT;IAEA;;GAEC,GACDC,UAAUC,MAAoB,EAAe;QAC3C,MAAMC,UAAUC,SAASC,aAAa,CAAC;QACvC5B,uBAAuB0B,SAASD,OAAOI,KAAK,CAACZ,EAAE;QAC/C,OAAOS;IACT;IAEA;;GAEC,GACDI,WAA+B;QAC7B,qBAAO,KAACzB;YAAwB0B,SAAS,IAAI,CAACjB,KAAK;;IACrD;IAEA;;;;GAIC,GACDkB,YAA6B;QAC3B,OAAO;YAAEN,SAASC,SAASC,aAAa,CAAC;QAAM;IACjD;IACA;;GAEC,GACDK,aAAoC;QAClC,OAAO;YACLC,MAAM;YACNC,SAAS;QACX;IACF;IAEAC,iBAAyB;QACvB,OAAO;IACT;IAEAC,WAAkB;QAChB,OAAO;IACT;IAEAC,YAAqB;QACnB,OAAO;IACT;AACF;AAEA,SAASnB;IACP,OAAO;QAAEN,MAAMU;IAA4B;AAC7C;AAEA,OAAO,SAASA;IACd,OAAOtB,sBAAsB,IAAIU;AACnC;AAEA,OAAO,SAAS4B,sBACd1B,IAAoC;IAEpC,OAAOA,gBAAgBF;AACzB"}
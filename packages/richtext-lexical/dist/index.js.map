{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import type { JSONSchema4 } from 'json-schema'\nimport type {\n  EditorConfig as LexicalEditorConfig,\n  SerializedEditorState,\n  SerializedLexicalNode,\n} from 'lexical'\n\nimport { withMergedProps } from '@payloadcms/ui/shared'\nimport { fileURLToPath } from 'node:url'\nimport path from 'path'\nimport {\n  afterChangeTraverseFields,\n  afterReadTraverseFields,\n  beforeChangeTraverseFields,\n  beforeValidateTraverseFields,\n  getDependencies,\n  withNullableJSONSchemaType,\n} from 'payload'\n\nimport type { FeatureProviderServer, ResolvedServerFeatureMap } from './features/typesServer.js'\nimport type { SanitizedServerEditorConfig } from './lexical/config/types.js'\nimport type {\n  AdapterProps,\n  LexicalEditorProps,\n  LexicalRichTextAdapter,\n  LexicalRichTextAdapterProvider,\n} from './types.js'\n\n// eslint-disable-next-line payload/no-imports-from-exports-dir\nimport { RichTextCell, RichTextField } from './exports/client/index.js'\nimport { i18n } from './i18n.js'\nimport { defaultEditorConfig, defaultEditorFeatures } from './lexical/config/server/default.js'\nimport { loadFeatures } from './lexical/config/server/loader.js'\nimport {\n  sanitizeServerEditorConfig,\n  sanitizeServerFeatures,\n} from './lexical/config/server/sanitize.js'\nimport { cloneDeep } from './lexical/utils/cloneDeep.js'\nimport { populateLexicalPopulationPromises } from './populateGraphQL/populateLexicalPopulationPromises.js'\nimport { getGenerateComponentMap } from './utilities/generateComponentMap.js'\nimport { getGenerateSchemaMap } from './utilities/generateSchemaMap.js'\nimport { recurseNodeTree } from './utilities/recurseNodeTree.js'\nimport { richTextValidateHOC } from './validate/index.js'\n\nlet defaultSanitizedServerEditorConfig: SanitizedServerEditorConfig = null\n\nconst filename = fileURLToPath(import.meta.url)\nconst dirname = path.dirname(filename)\n\nexport function lexicalEditor(props?: LexicalEditorProps): LexicalRichTextAdapterProvider {\n  return async ({ config, isRoot }) => {\n    if (process.env.NODE_ENV !== 'production') {\n      const resolvedDependencies = await getDependencies(dirname, [\n        'lexical',\n        '@lexical/headless',\n        '@lexical/link',\n        '@lexical/list',\n        '@lexical/mark',\n        '@lexical/markdown',\n        '@lexical/react',\n        '@lexical/rich-text',\n        '@lexical/selection',\n        '@lexical/utils',\n      ])\n\n      // Go through each resolved dependency. If any dependency has a mismatching version, throw an error\n      const foundVersions: {\n        [version: string]: string\n      } = {}\n      for (const [_pkg, { version }] of resolvedDependencies.resolved) {\n        if (!Object.keys(foundVersions).includes(version)) {\n          foundVersions[version] = _pkg\n        }\n      }\n      if (Object.keys(foundVersions).length > 1) {\n        const formattedVersionsWithPackageNameString = Object.entries(foundVersions)\n          .map(([version, pkg]) => `${pkg}@${version}`)\n          .join(', ')\n\n        throw new Error(\n          `Mismatching lexical dependency versions found: ${formattedVersionsWithPackageNameString}. All lexical and @lexical/* packages must have the same version. This is an error with your set-up, caused by you, not a bug in payload. Please go to your package.json and ensure all lexical and @lexical/* packages have the same version.`,\n        )\n      }\n    }\n\n    let features: FeatureProviderServer<any, any, any>[] = []\n    let resolvedFeatureMap: ResolvedServerFeatureMap\n\n    let finalSanitizedEditorConfig: SanitizedServerEditorConfig // For server only\n    if (!props || (!props.features && !props.lexical)) {\n      if (!defaultSanitizedServerEditorConfig) {\n        defaultSanitizedServerEditorConfig = await sanitizeServerEditorConfig(\n          defaultEditorConfig,\n          config,\n        )\n        features = cloneDeep(defaultEditorFeatures)\n      }\n\n      finalSanitizedEditorConfig = cloneDeep(defaultSanitizedServerEditorConfig)\n\n      resolvedFeatureMap = finalSanitizedEditorConfig.resolvedFeatureMap\n    } else {\n      const rootEditor = config.editor\n      let rootEditorFeatures: FeatureProviderServer<unknown, unknown, unknown>[] = []\n      if (typeof rootEditor === 'object' && 'features' in rootEditor) {\n        rootEditorFeatures = (rootEditor as LexicalRichTextAdapter).features\n      }\n\n      features =\n        props.features && typeof props.features === 'function'\n          ? props.features({\n              defaultFeatures: cloneDeep(defaultEditorFeatures),\n              rootFeatures: rootEditorFeatures,\n            })\n          : (props.features as FeatureProviderServer<unknown, unknown, unknown>[])\n      if (!features) {\n        features = cloneDeep(defaultEditorFeatures)\n      }\n\n      const lexical: LexicalEditorConfig = props.lexical\n\n      resolvedFeatureMap = await loadFeatures({\n        config,\n        isRoot,\n        unSanitizedEditorConfig: {\n          features,\n          lexical: lexical ? lexical : defaultEditorConfig.lexical,\n        },\n      })\n\n      finalSanitizedEditorConfig = {\n        features: sanitizeServerFeatures(resolvedFeatureMap),\n        lexical: lexical ? lexical : defaultEditorConfig.lexical,\n        resolvedFeatureMap,\n      }\n    }\n\n    const featureI18n = finalSanitizedEditorConfig.features.i18n\n    for (const lang in i18n) {\n      if (!featureI18n[lang]) {\n        featureI18n[lang] = {\n          lexical: {},\n        }\n      }\n\n      featureI18n[lang].lexical.general = i18n[lang]\n    }\n\n    return {\n      CellComponent: withMergedProps({\n        Component: RichTextCell,\n        toMergeIntoProps: {\n          admin: props?.admin,\n          lexicalEditorConfig: finalSanitizedEditorConfig.lexical,\n        },\n      }),\n      FieldComponent: withMergedProps({\n        Component: RichTextField,\n        toMergeIntoProps: {\n          admin: props?.admin,\n          lexicalEditorConfig: finalSanitizedEditorConfig.lexical,\n        },\n      }),\n      editorConfig: finalSanitizedEditorConfig,\n      features,\n      generateComponentMap: getGenerateComponentMap({\n        resolvedFeatureMap,\n      }),\n      generateSchemaMap: getGenerateSchemaMap({\n        resolvedFeatureMap,\n      }),\n      graphQLPopulationPromises({\n        context,\n        currentDepth,\n        depth,\n        draft,\n        field,\n        fieldPromises,\n        findMany,\n        flattenLocales,\n        overrideAccess,\n        populationPromises,\n        req,\n        showHiddenFields,\n        siblingDoc,\n      }) {\n        // check if there are any features with nodes which have populationPromises for this field\n        if (finalSanitizedEditorConfig?.features?.graphQLPopulationPromises?.size) {\n          populateLexicalPopulationPromises({\n            context,\n            currentDepth: currentDepth ?? 0,\n            depth,\n            draft,\n            editorPopulationPromises: finalSanitizedEditorConfig.features.graphQLPopulationPromises,\n            field,\n            fieldPromises,\n            findMany,\n            flattenLocales,\n            overrideAccess,\n            populationPromises,\n            req,\n            showHiddenFields,\n            siblingDoc,\n          })\n        }\n      },\n      hooks: {\n        afterChange: [\n          async ({\n            collection,\n            context: _context,\n            global,\n            operation,\n            path,\n            req,\n            schemaPath,\n            value,\n          }) => {\n            if (\n              !finalSanitizedEditorConfig.features.hooks.afterChange.size &&\n              !finalSanitizedEditorConfig.features.getSubFields.size\n            ) {\n              return value\n            }\n            const context: any = _context\n            const nodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = {}\n\n            /**\n             * Get the originalNodeIDMap from the beforeValidate hook, which is always run before this hook.\n             */\n            const originalNodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = context?.internal?.richText?.[path.join('.')]?.originalNodeIDMap\n\n            if (!originalNodeIDMap || !Object.keys(originalNodeIDMap).length || !value) {\n              return value\n            }\n\n            recurseNodeTree({\n              nodeIDMap,\n              nodes: (value as SerializedEditorState)?.root?.children ?? [],\n            })\n\n            // eslint-disable-next-line prefer-const\n            for (let [id, node] of Object.entries(nodeIDMap)) {\n              const afterChangeHooks = finalSanitizedEditorConfig.features.hooks.afterChange\n              if (afterChangeHooks?.has(node.type)) {\n                for (const hook of afterChangeHooks.get(node.type)) {\n                  if (!originalNodeIDMap[id]) {\n                    console.warn(\n                      '(afterChange) No original node found for node with id',\n                      id,\n                      'node:',\n                      node,\n                      'path',\n                      path.join('.'),\n                    )\n                    continue\n                  }\n                  node = await hook({\n                    context,\n                    node,\n                    operation,\n                    originalNode: originalNodeIDMap[id],\n                    parentRichTextFieldPath: path,\n                    parentRichTextFieldSchemaPath: schemaPath,\n                    req,\n                  })\n                }\n              }\n              const subFieldFn = finalSanitizedEditorConfig.features.getSubFields.get(node.type)\n              const subFieldDataFn = finalSanitizedEditorConfig.features.getSubFieldsData.get(\n                node.type,\n              )\n\n              if (subFieldFn) {\n                const subFields = subFieldFn({ node, req })\n                const data = subFieldDataFn({ node, req }) ?? {}\n                const originalData = subFieldDataFn({ node: originalNodeIDMap[id], req }) ?? {}\n\n                if (subFields?.length) {\n                  await afterChangeTraverseFields({\n                    collection,\n                    context,\n                    data: originalData,\n                    doc: data,\n                    fields: subFields,\n                    global,\n                    operation,\n                    path,\n                    previousDoc: data,\n                    previousSiblingDoc: { ...data },\n                    req,\n                    schemaPath,\n                    siblingData: originalData || {},\n                    siblingDoc: { ...data },\n                  })\n                }\n              }\n            }\n            return value\n          },\n        ],\n        afterRead: [\n          /**\n           * afterRead hooks do not receive the originalNode. Thus, they can run on all nodes, not just nodes with an ID.\n           */\n          async ({\n            collection,\n            context: context,\n            currentDepth,\n            depth,\n            draft,\n            fallbackLocale,\n            fieldPromises,\n            findMany,\n            flattenLocales,\n            global,\n            locale,\n            overrideAccess,\n            path,\n            populationPromises,\n            req,\n            schemaPath,\n            showHiddenFields,\n            triggerAccessControl,\n            triggerHooks,\n            value,\n          }) => {\n            if (\n              !finalSanitizedEditorConfig.features.hooks.afterRead.size &&\n              !finalSanitizedEditorConfig.features.getSubFields.size\n            ) {\n              return value\n            }\n            const flattenedNodes: SerializedLexicalNode[] = []\n\n            recurseNodeTree({\n              flattenedNodes,\n              nodes: (value as SerializedEditorState)?.root?.children ?? [],\n            })\n\n            for (let node of flattenedNodes) {\n              const afterReadHooks = finalSanitizedEditorConfig.features.hooks.afterRead\n              if (afterReadHooks?.has(node.type)) {\n                for (const hook of afterReadHooks.get(node.type)) {\n                  node = await hook({\n                    context,\n                    currentDepth,\n                    depth,\n                    draft,\n                    fallbackLocale,\n                    fieldPromises,\n                    findMany,\n                    flattenLocales,\n                    locale,\n                    node,\n                    overrideAccess,\n                    parentRichTextFieldPath: path,\n                    parentRichTextFieldSchemaPath: schemaPath,\n                    populationPromises,\n                    req,\n                    showHiddenFields,\n                    triggerAccessControl,\n                    triggerHooks,\n                  })\n                }\n              }\n              const subFieldFn = finalSanitizedEditorConfig.features.getSubFields.get(node.type)\n              const subFieldDataFn = finalSanitizedEditorConfig.features.getSubFieldsData.get(\n                node.type,\n              )\n\n              if (subFieldFn) {\n                const subFields = subFieldFn({ node, req })\n                const data = subFieldDataFn({ node, req }) ?? {}\n\n                if (subFields?.length) {\n                  afterReadTraverseFields({\n                    collection,\n                    context,\n                    currentDepth,\n                    depth,\n                    doc: data,\n                    draft,\n                    fallbackLocale,\n                    fieldPromises,\n                    fields: subFields,\n                    findMany,\n                    flattenLocales,\n                    global,\n                    locale,\n                    overrideAccess,\n                    path,\n                    populationPromises,\n                    req,\n                    schemaPath,\n                    showHiddenFields,\n                    siblingDoc: data,\n                    triggerAccessControl,\n                    triggerHooks,\n                  })\n                }\n              }\n            }\n\n            return value\n          },\n        ],\n        beforeChange: [\n          async ({\n            collection,\n            context: _context,\n            duplicate,\n            errors,\n            field,\n            global,\n            mergeLocaleActions,\n            operation,\n            path,\n            req,\n            schemaPath,\n            siblingData,\n            siblingDocWithLocales,\n            skipValidation,\n            value,\n          }) => {\n            if (\n              !finalSanitizedEditorConfig.features.hooks.beforeChange.size &&\n              !finalSanitizedEditorConfig.features.getSubFields.size\n            ) {\n              return value\n            }\n\n            const context: any = _context\n            const nodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = {}\n\n            /**\n             * Get the originalNodeIDMap from the beforeValidate hook, which is always run before this hook.\n             */\n            const originalNodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = context?.internal?.richText?.[path.join('.')]?.originalNodeIDMap\n\n            if (!originalNodeIDMap || !Object.keys(originalNodeIDMap).length || !value) {\n              return value\n            }\n\n            const originalNodeWithLocalesIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = {}\n\n            recurseNodeTree({\n              nodeIDMap,\n              nodes: (value as SerializedEditorState)?.root?.children ?? [],\n            })\n\n            if (siblingDocWithLocales?.[field.name]) {\n              recurseNodeTree({\n                nodeIDMap: originalNodeWithLocalesIDMap,\n                nodes:\n                  (siblingDocWithLocales[field.name] as SerializedEditorState)?.root?.children ??\n                  [],\n              })\n            }\n\n            // eslint-disable-next-line prefer-const\n            for (let [id, node] of Object.entries(nodeIDMap)) {\n              const beforeChangeHooks = finalSanitizedEditorConfig.features.hooks.beforeChange\n              if (beforeChangeHooks?.has(node.type)) {\n                for (const hook of beforeChangeHooks.get(node.type)) {\n                  if (!originalNodeIDMap[id]) {\n                    console.warn(\n                      '(beforeChange) No original node found for node with id',\n                      id,\n                      'node:',\n                      node,\n                      'path',\n                      path.join('.'),\n                    )\n                    continue\n                  }\n                  node = await hook({\n                    context,\n                    duplicate,\n                    errors,\n                    mergeLocaleActions,\n                    node,\n                    operation,\n                    originalNode: originalNodeIDMap[id],\n                    originalNodeWithLocales: originalNodeWithLocalesIDMap[id],\n                    parentRichTextFieldPath: path,\n                    parentRichTextFieldSchemaPath: schemaPath,\n                    req,\n                    skipValidation,\n                  })\n                }\n              }\n\n              const subFieldFn = finalSanitizedEditorConfig.features.getSubFields.get(node.type)\n              const subFieldDataFn = finalSanitizedEditorConfig.features.getSubFieldsData.get(\n                node.type,\n              )\n\n              if (subFieldFn) {\n                const subFields = subFieldFn({ node, req })\n                const data = subFieldDataFn({ node, req }) ?? {}\n                const originalData = subFieldDataFn({ node: originalNodeIDMap[id], req }) ?? {}\n                const originalDataWithLocales =\n                  subFieldDataFn({\n                    node: originalNodeWithLocalesIDMap[id],\n                    req,\n                  }) ?? {}\n\n                if (subFields?.length) {\n                  await beforeChangeTraverseFields({\n                    id,\n                    collection,\n                    context,\n                    data,\n                    doc: originalData,\n                    docWithLocales: originalDataWithLocales ?? {},\n                    duplicate,\n                    errors,\n                    fields: subFields,\n                    global,\n                    mergeLocaleActions,\n                    operation,\n                    path,\n                    req,\n                    schemaPath,\n                    siblingData: data,\n                    siblingDoc: originalData,\n                    siblingDocWithLocales: originalDataWithLocales ?? {},\n                    skipValidation,\n                  })\n                }\n              }\n            }\n\n            /**\n             * within the beforeChange hook, id's may be re-generated.\n             * Example:\n             * 1. Seed data contains IDs for block feature blocks.\n             * 2. Those are used in beforeValidate\n             * 3. in beforeChange, those IDs are regenerated, because you cannot provide IDs during document creation. See baseIDField beforeChange hook for reasoning\n             * 4. Thus, in order for all post-beforeChange hooks to receive the correct ID, we need to update the originalNodeIDMap with the new ID's, by regenerating the nodeIDMap.\n             * The reason this is not generated for every hook, is to save on performance. We know we only really have to generate it in beforeValidate, which is the first hook,\n             * and in beforeChange, which is where modifications to the provided IDs can occur.\n             */\n            const newOriginalNodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = {}\n\n            const previousValue = siblingData[field.name]\n\n            recurseNodeTree({\n              nodeIDMap: newOriginalNodeIDMap,\n              nodes: (previousValue as SerializedEditorState)?.root?.children ?? [],\n            })\n\n            if (!context.internal) {\n              // Add to context, for other hooks to use\n              context.internal = {}\n            }\n            if (!context.internal.richText) {\n              context.internal.richText = {}\n            }\n            context.internal.richText[path.join('.')] = {\n              originalNodeIDMap: newOriginalNodeIDMap,\n            }\n\n            return value\n          },\n        ],\n        beforeValidate: [\n          async ({\n            collection,\n            context,\n            global,\n            operation,\n            overrideAccess,\n            path,\n            previousValue,\n            req,\n            schemaPath,\n            value,\n          }) => {\n            // return value if there are NO hooks\n            if (\n              !finalSanitizedEditorConfig.features.hooks.beforeValidate.size &&\n              !finalSanitizedEditorConfig.features.hooks.afterChange.size &&\n              !finalSanitizedEditorConfig.features.hooks.beforeChange.size &&\n              !finalSanitizedEditorConfig.features.getSubFields.size\n            ) {\n              return value\n            }\n\n            /**\n             * beforeValidate is the first field hook which runs. This is where we can create the node map, which can then be used in the other hooks.\n             *\n             */\n\n            /**\n             * flattenedNodes contains all nodes in the editor, in the order they appear in the editor. They will be used for the following hooks:\n             * - afterRead\n             *\n             * The other hooks require nodes to have IDs, which is why those are ran only from the nodeIDMap. They require IDs because they have both doc/siblingDoc and data/siblingData, and\n             * thus require a reliable way to match new node data to old node data. Given that node positions can change in between hooks, this is only reliably possible for nodes which are saved with\n             * an ID.\n             */\n            //const flattenedNodes: SerializedLexicalNode[] = []\n\n            /**\n             * Only nodes with id's (so, nodes with hooks added to them) will be added to the nodeIDMap. They will be used for the following hooks:\n             * - afterChange\n             * - beforeChange\n             * - beforeValidate\n             * - beforeDuplicate\n             *\n             * Other hooks are handled by the flattenedNodes. All nodes in the nodeIDMap are part of flattenedNodes.\n             */\n\n            const originalNodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = {}\n\n            recurseNodeTree({\n              nodeIDMap: originalNodeIDMap,\n              nodes: (previousValue as SerializedEditorState)?.root?.children ?? [],\n            })\n\n            if (!context.internal) {\n              // Add to context, for other hooks to use\n              context.internal = {}\n            }\n            if (!(context as any).internal.richText) {\n              ;(context as any).internal.richText = {}\n            }\n            ;(context as any).internal.richText[path.join('.')] = {\n              originalNodeIDMap,\n            }\n\n            /**\n             * Now that the maps for all hooks are set up, we can run the validate hook\n             */\n            if (!finalSanitizedEditorConfig.features.hooks.beforeValidate.size) {\n              return value\n            }\n            const nodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = {}\n            recurseNodeTree({\n              //flattenedNodes,\n              nodeIDMap,\n              nodes: (value as SerializedEditorState)?.root?.children ?? [],\n            })\n\n            // eslint-disable-next-line prefer-const\n            for (let [id, node] of Object.entries(nodeIDMap)) {\n              const beforeValidateHooks = finalSanitizedEditorConfig.features.hooks.beforeValidate\n              if (beforeValidateHooks?.has(node.type)) {\n                for (const hook of beforeValidateHooks.get(node.type)) {\n                  if (!originalNodeIDMap[id]) {\n                    console.warn(\n                      '(beforeValidate) No original node found for node with id',\n                      id,\n                      'node:',\n                      node,\n                      'path',\n                      path.join('.'),\n                    )\n                    continue\n                  }\n                  node = await hook({\n                    context,\n                    node,\n                    operation,\n                    originalNode: originalNodeIDMap[id],\n                    overrideAccess,\n                    parentRichTextFieldPath: path,\n                    parentRichTextFieldSchemaPath: schemaPath,\n                    req,\n                  })\n                }\n              }\n              const subFieldFn = finalSanitizedEditorConfig.features.getSubFields.get(node.type)\n              const subFieldDataFn = finalSanitizedEditorConfig.features.getSubFieldsData.get(\n                node.type,\n              )\n\n              if (subFieldFn) {\n                const subFields = subFieldFn({ node, req })\n                const data = subFieldDataFn({ node, req }) ?? {}\n                const originalData = subFieldDataFn({ node: originalNodeIDMap[id], req }) ?? {}\n\n                if (subFields?.length) {\n                  await beforeValidateTraverseFields({\n                    id,\n                    collection,\n                    context,\n                    data,\n                    doc: originalData,\n                    fields: subFields,\n                    global,\n                    operation,\n                    overrideAccess,\n                    path,\n                    req,\n                    schemaPath,\n                    siblingData: data,\n                    siblingDoc: originalData,\n                  })\n                }\n              }\n            }\n\n            return value\n          },\n        ],\n      },\n      i18n: featureI18n,\n      outputSchema: ({\n        collectionIDFieldTypes,\n        config,\n        field,\n        interfaceNameDefinitions,\n        isRequired,\n      }) => {\n        let outputSchema: JSONSchema4 = {\n          // This schema matches the SerializedEditorState type so far, that it's possible to cast SerializedEditorState to this schema without any errors.\n          // In the future, we should\n          // 1) allow recursive children\n          // 2) Pass in all the different types for every node added to the editorconfig. This can be done with refs in the schema.\n          type: withNullableJSONSchemaType('object', isRequired),\n          properties: {\n            root: {\n              type: 'object',\n              additionalProperties: false,\n              properties: {\n                type: {\n                  type: 'string',\n                },\n                children: {\n                  type: 'array',\n                  items: {\n                    type: 'object',\n                    additionalProperties: true,\n                    properties: {\n                      type: {\n                        type: 'string',\n                      },\n                      version: {\n                        type: 'integer',\n                      },\n                    },\n                    required: ['type', 'version'],\n                  },\n                },\n                direction: {\n                  oneOf: [\n                    {\n                      enum: ['ltr', 'rtl'],\n                    },\n                    {\n                      type: 'null',\n                    },\n                  ],\n                },\n                format: {\n                  type: 'string',\n                  enum: ['left', 'start', 'center', 'right', 'end', 'justify', ''], // ElementFormatType, since the root node is an element\n                },\n                indent: {\n                  type: 'integer',\n                },\n                version: {\n                  type: 'integer',\n                },\n              },\n              required: ['children', 'direction', 'format', 'indent', 'type', 'version'],\n            },\n          },\n          required: ['root'],\n        }\n        for (const modifyOutputSchema of finalSanitizedEditorConfig.features.generatedTypes\n          .modifyOutputSchemas) {\n          outputSchema = modifyOutputSchema({\n            collectionIDFieldTypes,\n            config,\n            currentSchema: outputSchema,\n            field,\n            interfaceNameDefinitions,\n            isRequired,\n          })\n        }\n\n        return outputSchema\n      },\n      validate: richTextValidateHOC({\n        editorConfig: finalSanitizedEditorConfig,\n      }),\n    }\n  }\n}\n\nexport { AlignFeature } from './features/align/feature.server.js'\nexport { BlockquoteFeature } from './features/blockquote/feature.server.js'\nexport { BlocksFeature, type BlocksFeatureProps } from './features/blocks/feature.server.js'\nexport { type BlockFields, BlockNode } from './features/blocks/nodes/BlocksNode.js'\nexport { LinebreakHTMLConverter } from './features/converters/html/converter/converters/linebreak.js'\n\nexport { ParagraphHTMLConverter } from './features/converters/html/converter/converters/paragraph.js'\nexport { TextHTMLConverter } from './features/converters/html/converter/converters/text.js'\nexport { defaultHTMLConverters } from './features/converters/html/converter/defaultConverters.js'\n\nexport {\n  convertLexicalNodesToHTML,\n  convertLexicalToHTML,\n} from './features/converters/html/converter/index.js'\nexport type { HTMLConverter } from './features/converters/html/converter/types.js'\nexport {\n  HTMLConverterFeature,\n  type HTMLConverterFeatureProps,\n} from './features/converters/html/feature.server.js'\nexport { consolidateHTMLConverters, lexicalHTML } from './features/converters/html/field/index.js'\nexport { TestRecorderFeature } from './features/debug/testRecorder/feature.server.js'\nexport { TreeViewFeature } from './features/debug/treeView/feature.server.js'\nexport { EXPERIMENTAL_TableFeature } from './features/experimental_table/feature.server.js'\nexport { BoldFeature } from './features/format/bold/feature.server.js'\nexport { InlineCodeFeature } from './features/format/inlineCode/feature.server.js'\n\nexport { ItalicFeature } from './features/format/italic/feature.server.js'\nexport { StrikethroughFeature } from './features/format/strikethrough/feature.server.js'\nexport { SubscriptFeature } from './features/format/subscript/feature.server.js'\nexport { SuperscriptFeature } from './features/format/superscript/feature.server.js'\nexport { UnderlineFeature } from './features/format/underline/feature.server.js'\nexport { HeadingFeature, type HeadingFeatureProps } from './features/heading/feature.server.js'\nexport { HorizontalRuleFeature } from './features/horizontalRule/feature.server.js'\n\nexport { IndentFeature } from './features/indent/feature.server.js'\nexport { LinkFeature, type LinkFeatureServerProps } from './features/link/feature.server.js'\n\nexport { AutoLinkNode } from './features/link/nodes/AutoLinkNode.js'\nexport { LinkNode } from './features/link/nodes/LinkNode.js'\nexport type { LinkFields } from './features/link/nodes/types.js'\nexport { ChecklistFeature } from './features/lists/checklist/feature.server.js'\nexport { OrderedListFeature } from './features/lists/orderedList/feature.server.js'\nexport { UnorderedListFeature } from './features/lists/unorderedList/feature.server.js'\nexport { LexicalPluginToLexicalFeature } from './features/migrations/lexicalPluginToLexical/feature.server.js'\nexport { SlateBlockquoteConverter } from './features/migrations/slateToLexical/converter/converters/blockquote/index.js'\nexport { SlateHeadingConverter } from './features/migrations/slateToLexical/converter/converters/heading/index.js'\nexport { SlateIndentConverter } from './features/migrations/slateToLexical/converter/converters/indent/index.js'\nexport { SlateLinkConverter } from './features/migrations/slateToLexical/converter/converters/link/index.js'\nexport { SlateListItemConverter } from './features/migrations/slateToLexical/converter/converters/listItem/index.js'\nexport { SlateOrderedListConverter } from './features/migrations/slateToLexical/converter/converters/orderedList/index.js'\nexport { SlateRelationshipConverter } from './features/migrations/slateToLexical/converter/converters/relationship/index.js'\nexport { SlateUnknownConverter } from './features/migrations/slateToLexical/converter/converters/unknown/index.js'\nexport { SlateUnorderedListConverter } from './features/migrations/slateToLexical/converter/converters/unorderedList/index.js'\nexport { SlateUploadConverter } from './features/migrations/slateToLexical/converter/converters/upload/index.js'\nexport { defaultSlateConverters } from './features/migrations/slateToLexical/converter/defaultConverters.js'\n\nexport {\n  convertSlateNodesToLexical,\n  convertSlateToLexical,\n} from './features/migrations/slateToLexical/converter/index.js'\nexport type {\n  SlateNode,\n  SlateNodeConverter,\n} from './features/migrations/slateToLexical/converter/types.js'\nexport { SlateToLexicalFeature } from './features/migrations/slateToLexical/feature.server.js'\n\nexport { ParagraphFeature } from './features/paragraph/feature.server.js'\nexport {\n  RelationshipFeature,\n  type RelationshipFeatureProps,\n} from './features/relationship/feature.server.js'\nexport {\n  type RelationshipData,\n  RelationshipNode,\n} from './features/relationship/nodes/RelationshipNode.js'\n\nexport { FixedToolbarFeature } from './features/toolbars/fixed/feature.server.js'\nexport { InlineToolbarFeature } from './features/toolbars/inline/feature.server.js'\n\nexport type { ToolbarGroup, ToolbarGroupItem } from './features/toolbars/types.js'\nexport { createNode } from './features/typeUtilities.js' // Only useful in feature.server.ts\nexport type {\n  ClientComponentProps,\n  ClientFeature,\n  ClientFeatureProviderMap,\n  FeatureProviderClient,\n  FeatureProviderProviderClient,\n  PluginComponent,\n  PluginComponentWithAnchor,\n  ResolvedClientFeature,\n  ResolvedClientFeatureMap,\n  SanitizedClientFeatures,\n  SanitizedPlugin,\n} from './features/typesClient.js'\n\nexport type {\n  AfterChangeNodeHook,\n  AfterChangeNodeHookArgs,\n  AfterReadNodeHook,\n  AfterReadNodeHookArgs,\n  BaseNodeHookArgs,\n  BeforeChangeNodeHook,\n  BeforeChangeNodeHookArgs,\n  BeforeValidateNodeHook,\n  BeforeValidateNodeHookArgs,\n  FeatureProviderProviderServer,\n  FeatureProviderServer,\n  NodeValidation,\n  NodeWithHooks,\n  PopulationPromise,\n  ResolvedServerFeature,\n  ResolvedServerFeatureMap,\n  SanitizedServerFeatures,\n  ServerFeature,\n  ServerFeatureProviderMap,\n} from './features/typesServer.js'\n\nexport { UploadFeature } from './features/upload/feature.server.js'\n\nexport type { UploadFeatureProps } from './features/upload/feature.server.js'\nexport { type UploadData, UploadNode } from './features/upload/nodes/UploadNode.js'\n\nexport type { EditorConfigContextType } from './lexical/config/client/EditorConfigProvider.js'\nexport {\n  defaultEditorConfig,\n  defaultEditorFeatures,\n  defaultEditorLexicalConfig,\n} from './lexical/config/server/default.js'\n\nexport { loadFeatures, sortFeaturesForOptimalLoading } from './lexical/config/server/loader.js'\nexport {\n  sanitizeServerEditorConfig,\n  sanitizeServerFeatures,\n} from './lexical/config/server/sanitize.js'\n\nexport type {\n  ClientEditorConfig,\n  SanitizedClientEditorConfig,\n  SanitizedServerEditorConfig,\n  ServerEditorConfig,\n} from './lexical/config/types.js'\nexport { getEnabledNodes } from './lexical/nodes/index.js'\nexport type { AdapterProps }\n\nexport type {\n  SlashMenuGroup,\n  SlashMenuItem,\n} from './lexical/plugins/SlashMenu/LexicalTypeaheadMenuPlugin/types.js'\n\nexport {\n  DETAIL_TYPE_TO_DETAIL,\n  DOUBLE_LINE_BREAK,\n  ELEMENT_FORMAT_TO_TYPE,\n  ELEMENT_TYPE_TO_FORMAT,\n  IS_ALL_FORMATTING,\n  LTR_REGEX,\n  NON_BREAKING_SPACE,\n  NodeFormat,\n  RTL_REGEX,\n  TEXT_MODE_TO_TYPE,\n  TEXT_TYPE_TO_FORMAT,\n  TEXT_TYPE_TO_MODE,\n} from './lexical/utils/nodeFormat.js'\nexport { sanitizeUrl, validateUrl } from './lexical/utils/url.js'\n\nexport type * from './nodeTypes.js'\n\nexport { defaultRichTextValue } from './populateGraphQL/defaultValue.js'\n\nexport type { LexicalEditorProps, LexicalRichTextAdapter } from './types.js'\nexport { createServerFeature } from './utilities/createServerFeature.js'\nexport type { FieldsDrawerProps } from './utilities/fieldsDrawer/Drawer.js'\n\nexport { migrateSlateToLexical } from './utilities/migrateSlateToLexical/index.js'\n\nexport { upgradeLexicalData } from './utilities/upgradeLexicalData/index.js'\n"],"names":["withMergedProps","fileURLToPath","path","afterChangeTraverseFields","afterReadTraverseFields","beforeChangeTraverseFields","beforeValidateTraverseFields","getDependencies","withNullableJSONSchemaType","RichTextCell","RichTextField","i18n","defaultEditorConfig","defaultEditorFeatures","loadFeatures","sanitizeServerEditorConfig","sanitizeServerFeatures","cloneDeep","populateLexicalPopulationPromises","getGenerateComponentMap","getGenerateSchemaMap","recurseNodeTree","richTextValidateHOC","defaultSanitizedServerEditorConfig","filename","url","dirname","lexicalEditor","props","config","isRoot","process","env","NODE_ENV","resolvedDependencies","foundVersions","_pkg","version","resolved","Object","keys","includes","length","formattedVersionsWithPackageNameString","entries","map","pkg","join","Error","features","resolvedFeatureMap","finalSanitizedEditorConfig","lexical","rootEditor","editor","rootEditorFeatures","defaultFeatures","rootFeatures","unSanitizedEditorConfig","featureI18n","lang","general","CellComponent","Component","toMergeIntoProps","admin","lexicalEditorConfig","FieldComponent","editorConfig","generateComponentMap","generateSchemaMap","graphQLPopulationPromises","context","currentDepth","depth","draft","field","fieldPromises","findMany","flattenLocales","overrideAccess","populationPromises","req","showHiddenFields","siblingDoc","size","editorPopulationPromises","hooks","afterChange","collection","_context","global","operation","schemaPath","value","getSubFields","nodeIDMap","originalNodeIDMap","internal","richText","nodes","root","children","id","node","afterChangeHooks","has","type","hook","get","console","warn","originalNode","parentRichTextFieldPath","parentRichTextFieldSchemaPath","subFieldFn","subFieldDataFn","getSubFieldsData","subFields","data","originalData","doc","fields","previousDoc","previousSiblingDoc","siblingData","afterRead","fallbackLocale","locale","triggerAccessControl","triggerHooks","flattenedNodes","afterReadHooks","beforeChange","duplicate","errors","mergeLocaleActions","siblingDocWithLocales","skipValidation","originalNodeWithLocalesIDMap","name","beforeChangeHooks","originalNodeWithLocales","originalDataWithLocales","docWithLocales","newOriginalNodeIDMap","previousValue","beforeValidate","beforeValidateHooks","outputSchema","collectionIDFieldTypes","interfaceNameDefinitions","isRequired","properties","additionalProperties","items","required","direction","oneOf","enum","format","indent","modifyOutputSchema","generatedTypes","modifyOutputSchemas","currentSchema","validate","AlignFeature","BlockquoteFeature","BlocksFeature","BlockNode","LinebreakHTMLConverter","ParagraphHTMLConverter","TextHTMLConverter","defaultHTMLConverters","convertLexicalNodesToHTML","convertLexicalToHTML","HTMLConverterFeature","consolidateHTMLConverters","lexicalHTML","TestRecorderFeature","TreeViewFeature","EXPERIMENTAL_TableFeature","BoldFeature","InlineCodeFeature","ItalicFeature","StrikethroughFeature","SubscriptFeature","SuperscriptFeature","UnderlineFeature","HeadingFeature","HorizontalRuleFeature","IndentFeature","LinkFeature","AutoLinkNode","LinkNode","ChecklistFeature","OrderedListFeature","UnorderedListFeature","LexicalPluginToLexicalFeature","SlateBlockquoteConverter","SlateHeadingConverter","SlateIndentConverter","SlateLinkConverter","SlateListItemConverter","SlateOrderedListConverter","SlateRelationshipConverter","SlateUnknownConverter","SlateUnorderedListConverter","SlateUploadConverter","defaultSlateConverters","convertSlateNodesToLexical","convertSlateToLexical","SlateToLexicalFeature","ParagraphFeature","RelationshipFeature","RelationshipNode","FixedToolbarFeature","InlineToolbarFeature","createNode","UploadFeature","UploadNode","defaultEditorLexicalConfig","sortFeaturesForOptimalLoading","getEnabledNodes","DETAIL_TYPE_TO_DETAIL","DOUBLE_LINE_BREAK","ELEMENT_FORMAT_TO_TYPE","ELEMENT_TYPE_TO_FORMAT","IS_ALL_FORMATTING","LTR_REGEX","NON_BREAKING_SPACE","NodeFormat","RTL_REGEX","TEXT_MODE_TO_TYPE","TEXT_TYPE_TO_FORMAT","TEXT_TYPE_TO_MODE","sanitizeUrl","validateUrl","defaultRichTextValue","createServerFeature","migrateSlateToLexical","upgradeLexicalData"],"mappings":"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"}
{"version":3,"sources":["../../src/cell/index.tsx"],"sourcesContent":["'use client'\nimport type { EditorConfig as LexicalEditorConfig } from 'lexical'\nimport type { CellComponentProps } from 'payload'\n\nimport { createHeadlessEditor } from '@lexical/headless'\nimport { useClientFunctions, useTableCell } from '@payloadcms/ui'\nimport { $getRoot } from 'lexical'\nimport React, { useEffect, useState } from 'react'\n\nimport type { FeatureProviderClient } from '../features/typesClient.js'\nimport type { SanitizedClientEditorConfig } from '../lexical/config/types.js'\nimport type { GeneratedFeatureProviderComponent, LexicalFieldAdminProps } from '../types.js'\n\nimport { defaultEditorLexicalConfig } from '../lexical/config/client/default.js'\nimport { loadClientFeatures } from '../lexical/config/client/loader.js'\nimport { sanitizeClientEditorConfig } from '../lexical/config/client/sanitize.js'\nimport { getEnabledNodes } from '../lexical/nodes/index.js'\n\nexport const RichTextCell: React.FC<\n  {\n    admin?: LexicalFieldAdminProps\n    lexicalEditorConfig: LexicalEditorConfig\n  } & CellComponentProps\n> = (props) => {\n  const { admin, lexicalEditorConfig, richTextComponentMap } = props\n\n  const [preview, setPreview] = React.useState('Loading...')\n\n  const {\n    cellData,\n    cellProps: { schemaPath },\n  } = useTableCell()\n\n  const clientFunctions = useClientFunctions()\n  const [hasLoadedFeatures, setHasLoadedFeatures] = useState(false)\n\n  const [featureProviders, setFeatureProviders] = useState<\n    FeatureProviderClient<unknown, unknown>[]\n  >([])\n\n  const [finalSanitizedEditorConfig, setFinalSanitizedEditorConfig] =\n    useState<SanitizedClientEditorConfig>(null)\n\n  const featureProviderComponents: GeneratedFeatureProviderComponent[] = (\n    richTextComponentMap.get('features') as GeneratedFeatureProviderComponent[]\n  ).sort((a, b) => a.order - b.order) // order by order\n\n  let featureProvidersAndComponentsToLoad = 0 // feature providers and components\n  for (const featureProvider of featureProviderComponents) {\n    const featureComponentKeys = Array.from(richTextComponentMap.keys()).filter((key) =>\n      key.startsWith(`feature.${featureProvider.key}.components.`),\n    )\n\n    featureProvidersAndComponentsToLoad += 1\n    featureProvidersAndComponentsToLoad += featureComponentKeys.length\n  }\n\n  useEffect(() => {\n    if (!hasLoadedFeatures) {\n      const featureProvidersLocal: FeatureProviderClient<unknown, unknown>[] = []\n      let featureProvidersAndComponentsLoaded = 0 // feature providers and components only\n\n      Object.entries(clientFunctions).forEach(([key, plugin]) => {\n        if (key.startsWith(`lexicalFeature.${schemaPath}.`)) {\n          if (!key.includes('.lexical_internal_components.')) {\n            featureProvidersLocal.push(plugin)\n          }\n          featureProvidersAndComponentsLoaded++\n        }\n      })\n\n      if (featureProvidersAndComponentsLoaded === featureProvidersAndComponentsToLoad) {\n        setFeatureProviders(featureProvidersLocal)\n        setHasLoadedFeatures(true)\n\n        /**\n         * Loaded feature provided => create the final sanitized editor config\n         */\n\n        const resolvedClientFeatures = loadClientFeatures({\n          clientFunctions,\n          schemaPath,\n          unSanitizedEditorConfig: {\n            features: featureProvidersLocal,\n            lexical: lexicalEditorConfig,\n          },\n        })\n\n        setFinalSanitizedEditorConfig(\n          sanitizeClientEditorConfig(\n            lexicalEditorConfig ? lexicalEditorConfig : defaultEditorLexicalConfig,\n            resolvedClientFeatures,\n            admin,\n          ),\n        )\n      }\n    }\n  }, [\n    admin,\n    featureProviderComponents,\n    hasLoadedFeatures,\n    clientFunctions,\n    schemaPath,\n    featureProviderComponents.length,\n    featureProviders,\n    finalSanitizedEditorConfig,\n    lexicalEditorConfig,\n    richTextComponentMap,\n    featureProvidersAndComponentsToLoad,\n  ])\n\n  useEffect(() => {\n    if (!hasLoadedFeatures) {\n      return\n    }\n    let dataToUse = cellData\n    if (dataToUse == null || !hasLoadedFeatures || !finalSanitizedEditorConfig) {\n      setPreview('')\n      return\n    }\n\n    // Transform data through load hooks\n    if (finalSanitizedEditorConfig?.features?.hooks?.load?.length) {\n      finalSanitizedEditorConfig.features.hooks.load.forEach((hook) => {\n        dataToUse = hook({ incomingEditorState: dataToUse })\n      })\n    }\n\n    if (!dataToUse || typeof dataToUse !== 'object') {\n      setPreview('')\n      return\n    }\n\n    // If data is from Slate and not Lexical\n    if (Array.isArray(dataToUse) && !('root' in dataToUse)) {\n      setPreview('')\n      return\n    }\n\n    // If data is from payload-plugin-lexical\n    if ('jsonContent' in dataToUse) {\n      setPreview('')\n      return\n    }\n\n    // initialize headless editor\n    const headlessEditor = createHeadlessEditor({\n      namespace: finalSanitizedEditorConfig.lexical.namespace,\n      nodes: getEnabledNodes({ editorConfig: finalSanitizedEditorConfig }),\n      theme: finalSanitizedEditorConfig.lexical.theme,\n    })\n    headlessEditor.setEditorState(headlessEditor.parseEditorState(dataToUse))\n\n    const textContent =\n      headlessEditor.getEditorState().read(() => {\n        return $getRoot().getTextContent()\n      }) || ''\n\n    // Limiting the number of characters shown is done in a CSS rule\n    setPreview(textContent)\n  }, [cellData, lexicalEditorConfig, hasLoadedFeatures, finalSanitizedEditorConfig])\n\n  if (!hasLoadedFeatures) {\n    return (\n      <React.Fragment>\n        {Array.isArray(featureProviderComponents) &&\n          featureProviderComponents.map((featureProvider) => {\n            // get all components starting with key feature.${FeatureProvider.key}.components.{featureComponentKey}\n            const featureComponentKeys = Array.from(richTextComponentMap.keys()).filter((key) =>\n              key.startsWith(\n                `lexical_internal_feature.${featureProvider.key}.lexical_internal_components.`,\n              ),\n            )\n\n            const featureComponents: React.ReactNode[] = featureComponentKeys.map((key) => {\n              return richTextComponentMap.get(key)\n            })\n\n            return (\n              <React.Fragment key={featureProvider.key}>\n                {featureComponents?.length\n                  ? featureComponents.map((FeatureComponent) => {\n                      return FeatureComponent\n                    })\n                  : null}\n                {featureProvider.ClientFeature}\n              </React.Fragment>\n            )\n          })}\n      </React.Fragment>\n    )\n  }\n\n  return <span>{preview}</span>\n}\n"],"names":["createHeadlessEditor","useClientFunctions","useTableCell","$getRoot","React","useEffect","useState","defaultEditorLexicalConfig","loadClientFeatures","sanitizeClientEditorConfig","getEnabledNodes","RichTextCell","props","admin","lexicalEditorConfig","richTextComponentMap","preview","setPreview","cellData","cellProps","schemaPath","clientFunctions","hasLoadedFeatures","setHasLoadedFeatures","featureProviders","setFeatureProviders","finalSanitizedEditorConfig","setFinalSanitizedEditorConfig","featureProviderComponents","get","sort","a","b","order","featureProvidersAndComponentsToLoad","featureProvider","featureComponentKeys","Array","from","keys","filter","key","startsWith","length","featureProvidersLocal","featureProvidersAndComponentsLoaded","Object","entries","forEach","plugin","includes","push","resolvedClientFeatures","unSanitizedEditorConfig","features","lexical","dataToUse","hooks","load","hook","incomingEditorState","isArray","headlessEditor","namespace","nodes","editorConfig","theme","setEditorState","parseEditorState","textContent","getEditorState","read","getTextContent","Fragment","map","featureComponents","FeatureComponent","ClientFeature","span"],"mappings":"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"}
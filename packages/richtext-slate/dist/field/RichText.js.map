{"version":3,"sources":["../../src/field/RichText.tsx"],"sourcesContent":["'use client'\n\nimport type { FormFieldBase } from '@payloadcms/ui'\nimport type { ClientValidate } from 'payload'\nimport type { BaseEditor, BaseOperation } from 'slate'\nimport type { HistoryEditor } from 'slate-history'\nimport type { ReactEditor } from 'slate-react'\n\nimport { getTranslation } from '@payloadcms/translations'\nimport {\n  FieldDescription,\n  FieldError,\n  FieldLabel,\n  useEditDepth,\n  useField,\n  useFieldProps,\n  useTranslation,\n  withCondition,\n} from '@payloadcms/ui'\nimport { isHotkey } from 'is-hotkey'\nimport React, { useCallback, useEffect, useMemo, useRef } from 'react'\nimport { Node, Element as SlateElement, Text, Transforms, createEditor } from 'slate'\nimport { withHistory } from 'slate-history'\nimport { Editable, Slate, withReact } from 'slate-react'\n\nimport type { ElementNode, RichTextPlugin, TextNode } from '../types.js'\nimport type { EnabledFeatures } from './types.js'\n\nimport { defaultRichTextValue } from '../data/defaultValue.js'\nimport { richTextValidate } from '../data/validation.js'\nimport { listTypes } from './elements/listTypes.js'\nimport { hotkeys } from './hotkeys.js'\nimport './index.scss'\nimport { toggleLeaf } from './leaves/toggle.js'\nimport { withEnterBreakOut } from './plugins/withEnterBreakOut.js'\nimport { withHTML } from './plugins/withHTML.js'\nimport { ElementButtonProvider } from './providers/ElementButtonProvider.js'\nimport { ElementProvider } from './providers/ElementProvider.js'\nimport { LeafButtonProvider } from './providers/LeafButtonProvider.js'\nimport { LeafProvider } from './providers/LeafProvider.js'\n\nconst baseClass = 'rich-text'\n\ndeclare module 'slate' {\n  interface CustomTypes {\n    Editor: BaseEditor & HistoryEditor & ReactEditor\n    Element: ElementNode\n    Text: TextNode\n  }\n}\n\nconst RichTextField: React.FC<\n  {\n    elements: EnabledFeatures['elements']\n    leaves: EnabledFeatures['leaves']\n    name: string\n    placeholder?: string\n    plugins: RichTextPlugin[]\n    richTextComponentMap: Map<string, React.ReactNode>\n    width?: string\n  } & FormFieldBase\n> = (props) => {\n  const {\n    name,\n    CustomDescription,\n    CustomError,\n    CustomLabel,\n    className,\n    descriptionProps,\n    elements,\n    errorProps,\n    label,\n    labelProps,\n    leaves,\n    path: pathFromProps,\n    placeholder,\n    plugins,\n    readOnly: readOnlyFromProps,\n    required,\n    style,\n    validate = richTextValidate,\n    width,\n  } = props\n\n  const { i18n } = useTranslation()\n  const editorRef = useRef(null)\n  const toolbarRef = useRef(null)\n\n  const drawerDepth = useEditDepth()\n  const drawerIsOpen = drawerDepth > 1\n\n  const memoizedValidate: ClientValidate = useCallback(\n    (value, validationOptions) => {\n      if (typeof validate === 'function') {\n        return validate(value, {\n          ...validationOptions,\n          req: {\n            t: i18n.t,\n          },\n          required,\n        })\n      }\n    },\n    [validate, required, i18n],\n  )\n\n  const { path: pathFromContext, readOnly: readOnlyFromContext } = useFieldProps()\n\n  const { formInitializing, initialValue, path, schemaPath, setValue, showError, value } = useField(\n    {\n      path: pathFromContext ?? pathFromProps ?? name,\n      validate: memoizedValidate,\n    },\n  )\n\n  const disabled = readOnlyFromProps || readOnlyFromContext || formInitializing\n\n  const editor = useMemo(() => {\n    let CreatedEditor = withEnterBreakOut(withHistory(withReact(createEditor())))\n\n    CreatedEditor = withHTML(CreatedEditor)\n\n    if (plugins.length) {\n      CreatedEditor = plugins.reduce((editorWithPlugins, plugin) => {\n        return plugin(editorWithPlugins)\n      }, CreatedEditor)\n    }\n\n    return CreatedEditor\n  }, [plugins])\n\n  const renderElement = useCallback(\n    ({ attributes, children, element }) => {\n      // return <div {...attributes}>{children}</div>\n\n      const matchedElement = elements[element.type]\n      const Element = matchedElement?.Element\n\n      let attr = { ...attributes }\n\n      // this converts text alignment to margin when dealing with void elements\n      if (element.textAlign) {\n        if (element.type === 'relationship' || element.type === 'upload') {\n          switch (element.textAlign) {\n            case 'left':\n              attr = { ...attr, style: { marginRight: 'auto' } }\n              break\n            case 'right':\n              attr = { ...attr, style: { marginLeft: 'auto' } }\n              break\n            case 'center':\n              attr = { ...attr, style: { marginLeft: 'auto', marginRight: 'auto' } }\n              break\n            default:\n              attr = { ...attr, style: { textAlign: element.textAlign } }\n              break\n          }\n        } else if (element.type === 'li') {\n          switch (element.textAlign) {\n            case 'right':\n              attr = { ...attr, style: { listStylePosition: 'inside', textAlign: 'right' } }\n              break\n            case 'center':\n              attr = { ...attr, style: { listStylePosition: 'inside', textAlign: 'center' } }\n              break\n            case 'left':\n            default:\n              attr = { ...attr, style: { listStylePosition: 'outside', textAlign: 'left' } }\n              break\n          }\n        } else {\n          attr = { ...attr, style: { textAlign: element.textAlign } }\n        }\n      }\n\n      if (Element) {\n        const el = (\n          <ElementProvider\n            attributes={attr}\n            childNodes={children}\n            editorRef={editorRef}\n            element={element}\n            fieldProps={props}\n            path={path}\n            schemaPath={schemaPath}\n          >\n            {Element}\n          </ElementProvider>\n        )\n\n        return el\n      }\n\n      return <div {...attr}>{children}</div>\n    },\n    [elements, path, props, schemaPath],\n  )\n\n  const renderLeaf = useCallback(\n    ({ attributes, children, leaf }) => {\n      const matchedLeaves = Object.entries(leaves).filter(([leafName]) => leaf[leafName])\n\n      if (matchedLeaves.length > 0) {\n        return matchedLeaves.reduce(\n          (result, [, leafConfig], i) => {\n            if (leafConfig?.Leaf) {\n              const Leaf = leafConfig.Leaf\n\n              return (\n                <LeafProvider\n                  attributes={attributes}\n                  editorRef={editorRef}\n                  fieldProps={props}\n                  key={i}\n                  leaf={leaf}\n                  path={path}\n                  result={result}\n                  schemaPath={schemaPath}\n                >\n                  {Leaf}\n                </LeafProvider>\n              )\n            }\n\n            return result\n          },\n          <span {...attributes}>{children}</span>,\n        )\n      }\n\n      return <span {...attributes}>{children}</span>\n    },\n    [path, props, schemaPath, leaves],\n  )\n\n  // All slate changes fire the onChange event\n  // including selection changes\n  // so we will filter the set_selection operations out\n  // and only fire setValue when onChange is because of value\n  const handleChange = useCallback(\n    (val: unknown) => {\n      const ops = editor?.operations.filter((o: BaseOperation) => {\n        if (o) {\n          return o.type !== 'set_selection'\n        }\n        return false\n      })\n\n      if (ops && Array.isArray(ops) && ops.length > 0) {\n        if (!disabled && val !== defaultRichTextValue && val !== value) {\n          setValue(val)\n        }\n      }\n    },\n    [editor?.operations, disabled, setValue, value],\n  )\n\n  useEffect(() => {\n    function setClickableState(clickState: 'disabled' | 'enabled') {\n      const selectors = 'button, a, [role=\"button\"]'\n      const toolbarButtons: (HTMLAnchorElement | HTMLButtonElement)[] =\n        toolbarRef.current?.querySelectorAll(selectors)\n\n      ;(toolbarButtons || []).forEach((child) => {\n        const isButton = child.tagName === 'BUTTON'\n        const isDisabling = clickState === 'disabled'\n        child.setAttribute('tabIndex', isDisabling ? '-1' : '0')\n        if (isButton) child.setAttribute('disabled', isDisabling ? 'disabled' : null)\n      })\n    }\n\n    if (disabled) {\n      setClickableState('disabled')\n    }\n\n    return () => {\n      if (disabled) {\n        setClickableState('enabled')\n      }\n    }\n  }, [disabled])\n\n  // useEffect(() => {\n  //   // If there is a change to the initial value, we need to reset Slate history\n  //   // and clear selection because the old selection may no longer be valid\n  //   // as returned JSON may be modified in hooks and have a different shape\n  //   if (editor.selection) {\n  //     console.log('deselecting');\n  //     ReactEditor.deselect(editor);\n  //   }\n  // }, [path, editor]);\n\n  const classes = [\n    baseClass,\n    'field-type',\n    className,\n    showError && 'error',\n    disabled && `${baseClass}--read-only`,\n  ]\n    .filter(Boolean)\n    .join(' ')\n\n  let valueToRender = value\n\n  if (typeof valueToRender === 'string') {\n    try {\n      const parsedJSON = JSON.parse(valueToRender)\n      valueToRender = parsedJSON\n    } catch (err) {\n      valueToRender = null\n    }\n  }\n\n  if (!valueToRender) valueToRender = defaultRichTextValue\n\n  return (\n    <div\n      className={classes}\n      style={{\n        ...style,\n        width,\n      }}\n    >\n      <FieldLabel\n        CustomLabel={CustomLabel}\n        label={label}\n        required={required}\n        {...(labelProps || {})}\n      />\n      <div className={`${baseClass}__wrap`}>\n        <FieldError CustomError={CustomError} path={path} {...(errorProps || {})} />\n        <Slate\n          editor={editor}\n          key={JSON.stringify({ initialValue, path })} // makes sure slate is completely re-rendered when initialValue changes, bypassing the slate-internal value memoization. That way, external changes to the form will update the editor\n          onChange={handleChange}\n          value={valueToRender as any[]}\n        >\n          <div className={`${baseClass}__wrapper`}>\n            {Object.keys(elements)?.length + Object.keys(leaves)?.length > 0 && (\n              <div\n                className={[`${baseClass}__toolbar`, drawerIsOpen && `${baseClass}__drawerIsOpen`]\n                  .filter(Boolean)\n                  .join(' ')}\n                ref={toolbarRef}\n              >\n                <div className={`${baseClass}__toolbar-wrap`}>\n                  {Object.values(elements).map((element) => {\n                    const Button = element?.Button\n\n                    if (Button) {\n                      return (\n                        <ElementButtonProvider\n                          disabled={disabled}\n                          fieldProps={props}\n                          key={element.name}\n                          path={path}\n                          schemaPath={schemaPath}\n                        >\n                          {Button}\n                        </ElementButtonProvider>\n                      )\n                    }\n\n                    return null\n                  })}\n                  {Object.values(leaves).map((leaf) => {\n                    const Button = leaf?.Button\n\n                    if (Button) {\n                      return (\n                        <LeafButtonProvider\n                          fieldProps={props}\n                          key={leaf.name}\n                          path={path}\n                          schemaPath={schemaPath}\n                        >\n                          {Button}\n                        </LeafButtonProvider>\n                      )\n                    }\n\n                    return null\n                  })}\n                </div>\n              </div>\n            )}\n            <div className={`${baseClass}__editor`} ref={editorRef}>\n              <Editable\n                className={`${baseClass}__input`}\n                id={`field-${path.replace(/\\./g, '__')}`}\n                onKeyDown={(event) => {\n                  if (event.key === 'Enter') {\n                    if (event.shiftKey) {\n                      event.preventDefault()\n                      editor.insertText('\\n')\n                    } else {\n                      const selectedElement = Node.descendant(\n                        editor,\n                        editor.selection.anchor.path.slice(0, -1),\n                      )\n\n                      if (SlateElement.isElement(selectedElement)) {\n                        // Allow hard enter to \"break out\" of certain elements\n                        if (editor.shouldBreakOutOnEnter(selectedElement)) {\n                          event.preventDefault()\n                          const selectedLeaf = Node.descendant(editor, editor.selection.anchor.path)\n\n                          if (\n                            Text.isText(selectedLeaf) &&\n                            String(selectedLeaf.text).length === editor.selection.anchor.offset\n                          ) {\n                            Transforms.insertNodes(editor, { children: [{ text: '' }] })\n                          } else {\n                            Transforms.splitNodes(editor)\n                            Transforms.setNodes(editor, {})\n                          }\n                        }\n                      }\n                    }\n                  }\n\n                  if (event.key === 'Backspace') {\n                    const selectedElement = Node.descendant(\n                      editor,\n                      editor.selection.anchor.path.slice(0, -1),\n                    )\n\n                    if (SlateElement.isElement(selectedElement) && selectedElement.type === 'li') {\n                      const selectedLeaf = Node.descendant(editor, editor.selection.anchor.path)\n                      if (Text.isText(selectedLeaf) && String(selectedLeaf.text).length === 0) {\n                        event.preventDefault()\n                        Transforms.unwrapNodes(editor, {\n                          match: (n) => SlateElement.isElement(n) && listTypes.includes(n.type),\n                          mode: 'lowest',\n                          split: true,\n                        })\n\n                        Transforms.setNodes(editor, { type: undefined })\n                      }\n                    } else if (editor.isVoid(selectedElement)) {\n                      Transforms.removeNodes(editor)\n                    }\n                  }\n\n                  Object.keys(hotkeys).forEach((hotkey) => {\n                    if (isHotkey(hotkey, event as any)) {\n                      event.preventDefault()\n                      const mark = hotkeys[hotkey]\n                      toggleLeaf(editor, mark)\n                    }\n                  })\n                }}\n                placeholder={getTranslation(placeholder, i18n)}\n                readOnly={disabled}\n                renderElement={renderElement}\n                renderLeaf={renderLeaf}\n                spellCheck\n              />\n            </div>\n          </div>\n        </Slate>\n        {CustomDescription !== undefined ? (\n          CustomDescription\n        ) : (\n          <FieldDescription {...(descriptionProps || {})} />\n        )}\n      </div>\n    </div>\n  )\n}\n\nexport const RichText = withCondition(RichTextField)\n"],"names":["getTranslation","FieldDescription","FieldError","FieldLabel","useEditDepth","useField","useFieldProps","useTranslation","withCondition","isHotkey","React","useCallback","useEffect","useMemo","useRef","Node","Element","SlateElement","Text","Transforms","createEditor","withHistory","Editable","Slate","withReact","defaultRichTextValue","richTextValidate","listTypes","hotkeys","toggleLeaf","withEnterBreakOut","withHTML","ElementButtonProvider","ElementProvider","LeafButtonProvider","LeafProvider","baseClass","RichTextField","props","name","CustomDescription","CustomError","CustomLabel","className","descriptionProps","elements","errorProps","label","labelProps","leaves","path","pathFromProps","placeholder","plugins","readOnly","readOnlyFromProps","required","style","validate","width","i18n","editorRef","toolbarRef","drawerDepth","drawerIsOpen","memoizedValidate","value","validationOptions","req","t","pathFromContext","readOnlyFromContext","formInitializing","initialValue","schemaPath","setValue","showError","disabled","editor","CreatedEditor","length","reduce","editorWithPlugins","plugin","renderElement","attributes","children","element","matchedElement","type","attr","textAlign","marginRight","marginLeft","listStylePosition","el","childNodes","fieldProps","div","renderLeaf","leaf","matchedLeaves","Object","entries","filter","leafName","result","leafConfig","i","Leaf","span","handleChange","val","ops","operations","o","Array","isArray","setClickableState","clickState","selectors","toolbarButtons","current","querySelectorAll","forEach","child","isButton","tagName","isDisabling","setAttribute","classes","Boolean","join","valueToRender","parsedJSON","JSON","parse","err","onChange","keys","ref","values","map","Button","id","replace","onKeyDown","event","key","shiftKey","preventDefault","insertText","selectedElement","descendant","selection","anchor","slice","isElement","shouldBreakOutOnEnter","selectedLeaf","isText","String","text","offset","insertNodes","splitNodes","setNodes","unwrapNodes","match","n","includes","mode","split","undefined","isVoid","removeNodes","hotkey","mark","spellCheck","stringify","RichText"],"mappings":"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"}
{"version":3,"sources":["../../src/lib/write-env-file.ts"],"sourcesContent":["import fs from 'fs-extra'\nimport path from 'path'\n\nimport type { CliArgs, ProjectTemplate } from '../types.js'\n\nimport { debug, error } from '../utils/log.js'\n\n/** Parse and swap .env.example values and write .env */\nexport async function writeEnvFile(args: {\n  cliArgs: CliArgs\n  databaseUri: string\n  payloadSecret: string\n  projectDir: string\n  template?: ProjectTemplate\n}): Promise<void> {\n  const { cliArgs, databaseUri, payloadSecret, projectDir, template } = args\n\n  if (cliArgs['--dry-run']) {\n    debug(`DRY RUN: .env file created`)\n    return\n  }\n\n  const envOutputPath = path.join(projectDir, '.env')\n\n  try {\n    let fileContents: string\n\n    if (template?.type === 'starter') {\n      // Parse .env file into key/value pairs\n      const envExample = path.join(projectDir, '.env.example')\n      const envFile = await fs.readFile(envExample, 'utf8')\n\n      fileContents =\n        `# Added by Payload\\n` +\n        envFile\n          .split('\\n')\n          .filter((e) => e)\n          .map((line) => {\n            if (line.startsWith('#') || !line.includes('=')) return line\n\n            const split = line.split('=')\n            const key = split[0]\n            let value = split[1]\n\n            if (key === 'MONGODB_URI' || key === 'MONGO_URL' || key === 'DATABASE_URI') {\n              value = databaseUri\n            }\n            if (key === 'PAYLOAD_SECRET' || key === 'PAYLOAD_SECRET_KEY') {\n              value = payloadSecret\n            }\n\n            return `${key}=${value}`\n          })\n          .join('\\n')\n    } else {\n      fileContents = `# Added by Payload\\nDATABASE_URI=${databaseUri}\\nPAYLOAD_SECRET=${payloadSecret}\\n`\n    }\n\n    if (fs.existsSync(envOutputPath)) {\n      const existingEnv = await fs.readFile(envOutputPath, 'utf8')\n      const newEnv = existingEnv + '\\n# Added by Payload' + fileContents\n      await fs.writeFile(envOutputPath, newEnv)\n    } else {\n      await fs.writeFile(envOutputPath, fileContents)\n    }\n  } catch (err: unknown) {\n    error('Unable to write .env file')\n    if (err instanceof Error) {\n      error(err.message)\n    }\n    process.exit(1)\n  }\n}\n"],"names":["fs","path","debug","error","writeEnvFile","args","cliArgs","databaseUri","payloadSecret","projectDir","template","envOutputPath","join","fileContents","type","envExample","envFile","readFile","split","filter","e","map","line","startsWith","includes","key","value","existsSync","existingEnv","newEnv","writeFile","err","Error","message","process","exit"],"mappings":"AAAA,OAAOA,QAAQ,WAAU;AACzB,OAAOC,UAAU,OAAM;AAIvB,SAASC,KAAK,EAAEC,KAAK,QAAQ,kBAAiB;AAE9C,sDAAsD,GACtD,OAAO,eAAeC,aAAaC,IAMlC;IACC,MAAM,EAAEC,OAAO,EAAEC,WAAW,EAAEC,aAAa,EAAEC,UAAU,EAAEC,QAAQ,EAAE,GAAGL;IAEtE,IAAIC,OAAO,CAAC,YAAY,EAAE;QACxBJ,MAAM,CAAC,0BAA0B,CAAC;QAClC;IACF;IAEA,MAAMS,gBAAgBV,KAAKW,IAAI,CAACH,YAAY;IAE5C,IAAI;QACF,IAAII;QAEJ,IAAIH,UAAUI,SAAS,WAAW;YAChC,uCAAuC;YACvC,MAAMC,aAAad,KAAKW,IAAI,CAACH,YAAY;YACzC,MAAMO,UAAU,MAAMhB,GAAGiB,QAAQ,CAACF,YAAY;YAE9CF,eACE,CAAC,oBAAoB,CAAC,GACtBG,QACGE,KAAK,CAAC,MACNC,MAAM,CAAC,CAACC,IAAMA,GACdC,GAAG,CAAC,CAACC;gBACJ,IAAIA,KAAKC,UAAU,CAAC,QAAQ,CAACD,KAAKE,QAAQ,CAAC,MAAM,OAAOF;gBAExD,MAAMJ,QAAQI,KAAKJ,KAAK,CAAC;gBACzB,MAAMO,MAAMP,KAAK,CAAC,EAAE;gBACpB,IAAIQ,QAAQR,KAAK,CAAC,EAAE;gBAEpB,IAAIO,QAAQ,iBAAiBA,QAAQ,eAAeA,QAAQ,gBAAgB;oBAC1EC,QAAQnB;gBACV;gBACA,IAAIkB,QAAQ,oBAAoBA,QAAQ,sBAAsB;oBAC5DC,QAAQlB;gBACV;gBAEA,OAAO,CAAC,EAAEiB,IAAI,CAAC,EAAEC,MAAM,CAAC;YAC1B,GACCd,IAAI,CAAC;QACZ,OAAO;YACLC,eAAe,CAAC,iCAAiC,EAAEN,YAAY,iBAAiB,EAAEC,cAAc,EAAE,CAAC;QACrG;QAEA,IAAIR,GAAG2B,UAAU,CAAChB,gBAAgB;YAChC,MAAMiB,cAAc,MAAM5B,GAAGiB,QAAQ,CAACN,eAAe;YACrD,MAAMkB,SAASD,cAAc,yBAAyBf;YACtD,MAAMb,GAAG8B,SAAS,CAACnB,eAAekB;QACpC,OAAO;YACL,MAAM7B,GAAG8B,SAAS,CAACnB,eAAeE;QACpC;IACF,EAAE,OAAOkB,KAAc;QACrB5B,MAAM;QACN,IAAI4B,eAAeC,OAAO;YACxB7B,MAAM4B,IAAIE,OAAO;QACnB;QACAC,QAAQC,IAAI,CAAC;IACf;AACF"}
{"version":3,"sources":["../src/traverseFields.ts"],"sourcesContent":["import type { fieldSchemaToJSON } from 'payload/shared'\n\nimport type { PopulationsByCollection, UpdatedDocument } from './types.js'\n\nimport { traverseRichText } from './traverseRichText.js'\n\nexport const traverseFields = <T>(args: {\n  externallyUpdatedRelationship?: UpdatedDocument\n  fieldSchema: ReturnType<typeof fieldSchemaToJSON>\n  incomingData: T\n  populationsByCollection: PopulationsByCollection\n  result: T\n}): void => {\n  const {\n    externallyUpdatedRelationship,\n    fieldSchema: fieldSchemas,\n    incomingData,\n    populationsByCollection,\n    result,\n  } = args\n\n  fieldSchemas.forEach((fieldSchema) => {\n    if ('name' in fieldSchema && typeof fieldSchema.name === 'string') {\n      const fieldName = fieldSchema.name\n\n      switch (fieldSchema.type) {\n        case 'richText':\n          result[fieldName] = traverseRichText({\n            externallyUpdatedRelationship,\n            incomingData: incomingData[fieldName],\n            populationsByCollection,\n            result: result[fieldName],\n          })\n\n          break\n\n        case 'array':\n          if (Array.isArray(incomingData[fieldName])) {\n            result[fieldName] = incomingData[fieldName].map((incomingRow, i) => {\n              if (!result[fieldName]) {\n                result[fieldName] = []\n              }\n\n              if (!result[fieldName][i]) {\n                result[fieldName][i] = {}\n              }\n\n              traverseFields({\n                externallyUpdatedRelationship,\n                fieldSchema: fieldSchema.fields,\n                incomingData: incomingRow,\n                populationsByCollection,\n                result: result[fieldName][i],\n              })\n\n              return result[fieldName][i]\n            })\n          }\n\n          break\n\n        case 'blocks':\n          if (Array.isArray(incomingData[fieldName])) {\n            result[fieldName] = incomingData[fieldName].map((incomingBlock, i) => {\n              const incomingBlockJSON = fieldSchema.blocks[incomingBlock.blockType]\n\n              if (!result[fieldName]) {\n                result[fieldName] = []\n              }\n\n              if (\n                !result[fieldName][i] ||\n                result[fieldName][i].id !== incomingBlock.id ||\n                result[fieldName][i].blockType !== incomingBlock.blockType\n              ) {\n                result[fieldName][i] = {\n                  blockType: incomingBlock.blockType,\n                }\n              }\n\n              traverseFields({\n                externallyUpdatedRelationship,\n                fieldSchema: incomingBlockJSON.fields,\n                incomingData: incomingBlock,\n                populationsByCollection,\n                result: result[fieldName][i],\n              })\n\n              return result[fieldName][i]\n            })\n          } else {\n            result[fieldName] = []\n          }\n\n          break\n\n        case 'tabs':\n        case 'group':\n          if (!result[fieldName]) {\n            result[fieldName] = {}\n          }\n\n          traverseFields({\n            externallyUpdatedRelationship,\n            fieldSchema: fieldSchema.fields,\n            incomingData: incomingData[fieldName] || {},\n            populationsByCollection,\n            result: result[fieldName],\n          })\n\n          break\n\n        case 'upload':\n        case 'relationship':\n          // Handle `hasMany` relationships\n          if (fieldSchema.hasMany && Array.isArray(incomingData[fieldName])) {\n            if (!result[fieldName] || !incomingData[fieldName].length) {\n              result[fieldName] = []\n            }\n\n            incomingData[fieldName].forEach((incomingRelation, i) => {\n              // Handle `hasMany` polymorphic\n              if (Array.isArray(fieldSchema.relationTo)) {\n                // if the field doesn't exist on the result, create it\n                // the value will be populated later\n                if (!result[fieldName][i]) {\n                  result[fieldName][i] = {\n                    relationTo: incomingRelation.relationTo,\n                  }\n                }\n\n                const oldID = result[fieldName][i]?.value?.id\n                const oldRelation = result[fieldName][i]?.relationTo\n                const newID = incomingRelation.value\n                const newRelation = incomingRelation.relationTo\n\n                const hasChanged = newID !== oldID || newRelation !== oldRelation\n                const hasUpdated =\n                  newRelation === externallyUpdatedRelationship?.entitySlug &&\n                  newID === externallyUpdatedRelationship?.id\n\n                if (hasChanged || hasUpdated) {\n                  if (!populationsByCollection[newRelation]) {\n                    populationsByCollection[newRelation] = []\n                  }\n\n                  populationsByCollection[newRelation].push({\n                    id: incomingRelation.value,\n                    accessor: 'value',\n                    ref: result[fieldName][i],\n                  })\n                }\n              } else {\n                // Handle `hasMany` monomorphic\n                const hasChanged = incomingRelation !== result[fieldName][i]?.id\n                const hasUpdated =\n                  fieldSchema.relationTo === externallyUpdatedRelationship?.entitySlug &&\n                  incomingRelation === externallyUpdatedRelationship?.id\n\n                if (hasChanged || hasUpdated) {\n                  if (!populationsByCollection[fieldSchema.relationTo]) {\n                    populationsByCollection[fieldSchema.relationTo] = []\n                  }\n\n                  populationsByCollection[fieldSchema.relationTo].push({\n                    id: incomingRelation,\n                    accessor: i,\n                    ref: result[fieldName],\n                  })\n                }\n              }\n            })\n          } else {\n            // Handle `hasOne` polymorphic\n            if (Array.isArray(fieldSchema.relationTo)) {\n              // if the field doesn't exist on the result, create it\n              // the value will be populated later\n              if (!result[fieldName]) {\n                result[fieldName] = {\n                  relationTo: incomingData[fieldName]?.relationTo,\n                }\n              }\n\n              const hasNewValue =\n                incomingData[fieldName] &&\n                typeof incomingData[fieldName] === 'object' &&\n                incomingData[fieldName] !== null\n\n              const hasOldValue =\n                result[fieldName] &&\n                typeof result[fieldName] === 'object' &&\n                result[fieldName] !== null\n\n              const newID = hasNewValue\n                ? typeof incomingData[fieldName].value === 'object'\n                  ? incomingData[fieldName].value.id\n                  : incomingData[fieldName].value\n                : ''\n\n              const oldID = hasOldValue\n                ? typeof result[fieldName].value === 'object'\n                  ? result[fieldName].value.id\n                  : result[fieldName].value\n                : ''\n\n              const newRelation = hasNewValue ? incomingData[fieldName].relationTo : ''\n              const oldRelation = hasOldValue ? result[fieldName].relationTo : ''\n\n              const hasChanged = newID !== oldID || newRelation !== oldRelation\n              const hasUpdated =\n                newRelation === externallyUpdatedRelationship?.entitySlug &&\n                newID === externallyUpdatedRelationship?.id\n\n              // if the new value/relation is different from the old value/relation\n              // populate the new value, otherwise leave it alone\n              if (hasChanged || hasUpdated) {\n                // if the new value is not empty, populate it\n                // otherwise set the value to null\n                if (newID) {\n                  if (!populationsByCollection[newRelation]) {\n                    populationsByCollection[newRelation] = []\n                  }\n\n                  populationsByCollection[newRelation].push({\n                    id: newID,\n                    accessor: 'value',\n                    ref: result[fieldName],\n                  })\n                } else {\n                  result[fieldName] = null\n                }\n              }\n            } else {\n              // Handle `hasOne` monomorphic\n              const newID: number | string | undefined =\n                (incomingData[fieldName] &&\n                  typeof incomingData[fieldName] === 'object' &&\n                  incomingData[fieldName].id) ||\n                incomingData[fieldName]\n\n              const oldID: number | string | undefined =\n                (result[fieldName] &&\n                  typeof result[fieldName] === 'object' &&\n                  result[fieldName].id) ||\n                result[fieldName]\n\n              const hasChanged = newID !== oldID\n              const hasUpdated =\n                fieldSchema.relationTo === externallyUpdatedRelationship?.entitySlug &&\n                newID === externallyUpdatedRelationship?.id\n\n              // if the new value is different from the old value\n              // populate the new value, otherwise leave it alone\n              if (hasChanged || hasUpdated) {\n                // if the new value is not empty, populate it\n                // otherwise set the value to null\n                if (newID) {\n                  if (!populationsByCollection[fieldSchema.relationTo]) {\n                    populationsByCollection[fieldSchema.relationTo] = []\n                  }\n\n                  populationsByCollection[fieldSchema.relationTo].push({\n                    id: newID,\n                    accessor: fieldName,\n                    ref: result as Record<string, unknown>,\n                  })\n                } else {\n                  result[fieldName] = null\n                }\n              }\n            }\n          }\n\n          break\n\n        default:\n          result[fieldName] = incomingData[fieldName]\n      }\n    }\n  })\n}\n"],"names":["traverseRichText","traverseFields","args","externallyUpdatedRelationship","fieldSchema","fieldSchemas","incomingData","populationsByCollection","result","forEach","name","fieldName","type","Array","isArray","map","incomingRow","i","fields","incomingBlock","incomingBlockJSON","blocks","blockType","id","hasMany","length","incomingRelation","relationTo","oldID","value","oldRelation","newID","newRelation","hasChanged","hasUpdated","entitySlug","push","accessor","ref","hasNewValue","hasOldValue"],"mappings":"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"}